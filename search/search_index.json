{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":""},{"location":"#shaken-fist-an-open-cloud-aimed-at-small-and-edge-deployments","title":"Shaken Fist, an open cloud aimed at small and edge deployments","text":"<p>Shaken Fist is a deliberately opinionated cloud intended for small deployments. We spend a lot of time trying to do the simplest possible thing well, and keep our resource usage on idle deployments as low as possible. Shaken Fist has progressed from being a proof of concept to being a functional cloud, although the release numbers being below zero indicates that we are still stabilizing the REST API and that breaking changes might occur. 1.0 will be released when we are relatively sure of stability going forwards.</p> <p>Shaken Fist started a personal research project, but has grown into something which is starting to see wider contributions and some small commercial deployments.</p>"},{"location":"#the-underlying-idea","title":"The underlying idea","text":"<p>Originally Shaken Fist came about as a reaction to the increasing complexity of OpenStack, as well as a desire to experiment with alternative approaches to solving the problems that OpenStack Compute addresses. What I really wanted was a simple API to orchestrate virtual machines, but it needed to run with minimal resource overhead and be simple to deploy. I also wanted it to always work in a predictable way.</p> <p>One of the reasons OpenStack is so complicated and its behaviour varies is because it has many options to configure. The solution seemed obvious to me -- a cloud that is super opinionated. For each different functional requirement there is one option, and the simplest option is chosen where possible. Read on for some examples.</p>"},{"location":"#development-choices","title":"Development choices","text":"<p>If there is an existing library which does a thing, we use it. OpenStack suffered from being old (and having issues with re-writes being hard), as well as licensing constraints. We just use the code that others have provided to the community. Always.</p>"},{"location":"#deployment-choices","title":"Deployment choices","text":"<p>libvirt is the only supported hypervisor. Instances are specified to libvirt with simple templated XML. If your local requirements are different to what's in the template, you're welcome to change the template to meet your needs. If your template changes break things, you're also welcome to debug what went wrong for yourself.</p>"},{"location":"#id-like-to-subscribe-to-your-newsletter","title":"\"I'd like to subscribe to your newsletter\"","text":"<p>First off, we don't have a newsletter. That said, updates will be announced here as they happen. What we do have is useful links:</p> <ul> <li> <p>The Shaken Fist repository is where   the code for the server is, including the deployer. Its a good place to start.</p> </li> <li> <p>There is also the python client repository   contains the python API client, as well as the command line client that users   and shell scripts use to interact with Shaken Fist.</p> </li> </ul>"},{"location":"#what-is-shaken-fist-can-i-help","title":"What is Shaken Fist? Can I help?","text":"<p>The Shaken Fist Manifesto is our general conceptual starting point, ubt apart from that just reach out and have a chat.</p>"},{"location":"community/","title":"Welcome to the Shaken Fist community","text":"<p>First off, Shaken Fist is an open source project covered by the Apache2 license. The community is relatively small at this point and we're still working out what works for us. For now, we communicate through the following mechanisms:</p> <ul> <li>GitHub issues and pull requests in the various repositories.</li> <li>A slack workspace at https://shakenfist.slack.com -- unfortunately you need to be invited to that workspace, but we're happy to do that. If you're interested, please email mikal@stillhq.com.</li> </ul>"},{"location":"community/#supporters","title":"Supporters","text":"<p>We try to track supporters here. Our apologies if we've missed someone, let us know and we'll fix it.</p> <ul> <li>Michael Still and Andrew McCallum have contributed significant personal time to the project.</li> <li>Aptira has donated developer time, as well as provided invaluable feedback from the largest real world deployments that we've had so far.</li> <li>FifthDomain has also donated developer time.</li> <li>Shaken Fist was a recipient of a 2020 Icculus micro grant.</li> </ul>"},{"location":"features/","title":"Feature matrix","text":"<p>What features does Shaken Fist have now? What about in the future? This page attempts to document the currently implemented features, but it is a bit a moving target. If you're left wondering if something works, please reach out to us and ask.</p>"},{"location":"features/#high-level-functionality","title":"High level functionality","text":"<p>Our high level functionality is why you'd consider using Shaken Fist. Specifically, we support:</p> <ul> <li>instances: which are virtual machines deployed and managed by Shaken Fist.</li> <li>virtual networks: which are VXLAN meshes between hypervisors managed by Shaken Fist. These virtual networks do automatic IP address management, optionally provide DHCP and NAT, and support floating IPs for external accessability.</li> <li>resource efficiency: we try hard to not use much in terms of resources in an orchestration idle state (that is, your workload isn't changing), but we also deploy and configure Kernel Shared Memory (KSM) and make heavy use of qcow2 Copy On Write (COW) layers to reduce the resources used by a single instance. This means you can pack more instances onto a Shaken Fist cluster than you can alternative deployments of the same size from other projects.</li> </ul>"},{"location":"features/#object-types","title":"Object types","text":"<p>We also have a lot of implementation functionality that is quite useful, but not the sort of thing you'd put on a billboard. Let's work through that by object type.</p>"},{"location":"features/#artifacts","title":"Artifacts","text":"<p>Artifacts are Shaken Fist's object type for disk images -- the sort of thing that you would store in Glance in OpenStack. Artifacts can store downloaded disk images from the internet (the \"image\" type), snapshots of previous instances (the \"snapshot\" type), and arbitrary uploads (also stored with the \"image\" type). There is also a special \"label\" artifact type, which is an overlay on top of the other types. Its easiest to explain its behavior by explaining the lifecycle of an artifact.</p> <p>The normal way to get your first artifact is to download something from the internet. So for example, you might start an instance with a standard Ubuntu cloud image from https://cloud-images.ubuntu.com/. This would be done by specifying the URL of the image in the disk specification of the image: Shaken Fist will then download the image and store it as an artifact, and then start your instance. A second instance using the same image will then check the image at the URL hasn't changed, and if it hasn't use the same artifact as the first instance, skipping the repeated download.</p> <p>However, if the image has changed, a second version would be downloaded. Depending on the settings for the artifact, both versions are retained. By default Shaken Fist keeps the last three versions of each artifact, although this is configurable.</p> <p>Now let's assume that you have a nightly CI job which starts an instance from the latest Ubuntu cloud image, and performs some tests to ensure that it works for your software stack. You want to somehow mark for your other workloads what versions of the Ubuntu image are trusted, and you do this with a label. So, your CI job would specify the upstream URL for the cloud image, perform its tests, and then label the image if it passed those tests. Other Ubuntu users in your cloud could then specify that they wanted the most recent version which passed testing by specifying the label for their disk specification, instead of the upstream URL.</p> <p>Shaken Fist's CI does exactly this. Each night we download a set of cloud images, customize them to make the CI runs a bit faster (pre-installing packages and so forth), and then test that they work. At the end of that run we take a snapshot of the instance we customized, and label it with a label along the lines of \"sfci-ubuntu-2004\". CI jobs then use that label for their base disk. You can see the ansible we use to do this at https://github.com/shakenfist/shakenfist/blob/develop/deploy/ansible/ci-image.yml if you're interested.</p> <p>The following operations are exposed on artifacts by the REST API:</p> Operation Command line client API client list artifacts <code>artifact list</code> <code>get_artifacts()</code> show an artifact <code>artifact show</code> <code>get_artifact()</code> fetch an artifact from a URL without starting an instance <code>artifact cache</code> <code>cache_artifact()</code> upload <code>artifact upload</code> <code>create_upload()</code> followed by calls to <code>send_upload()</code> and then <code>upload_artifact()</code> download <code>artifact download</code> lookup the desired version's blob with <code>get_artifact()</code>, then download with <code>get_blob_data()</code> show detailed information about versions <code>artifact versions</code> <code>get_artifact_versions()</code> delete <code>artifact delete</code> <code>delete_artifact()</code> delete a version <code>artifact delete-version</code> <code>delete_artifact_version()</code> set the maximum number of versions <code>artifact max-versions</code> <code>set_artifact_max_versions()</code> <p>Note that artifacts exist in namespaces (since v0.6). This means that your artifacts are private to your namespace, and can't be seen or used by other namespaces. There are two exceptions -- the \"system\" administrative namespace can see all artifacts, and the \"system\" namespace can create artifacts visible to all other namespaces -- this is done with the shared flag on the relevant command line or API calls, and uses a \"sharedwithall\" namespace in the database.</p>"},{"location":"features/#blobs","title":"Blobs","text":"<p>Each version of an artifact is an object called a blob. Blobs are stored on Shaken Fist nodes, and are automatically replicated around the cluster as required. By default we store at least two copies of each blob, although this is configurable. Its possible we'll store a lot more copies than that, because we only reap excess copies when we start to run low on disk. This is because these blobs are often used during the startup of instances, so having a local cache of popular blobs can significantly improve instance start up times.</p> <p>All hypervisor nodes store blobs, but it is also possible to have \"storage only\" nodes which don't run VMs and just store blobs. In previous deployments we have used these storage nodes to handle having more blobs than we need for currently running instances -- for example historical snapshots we are fond of, but are unlikely to require frequent access to. The storage nodes were therefore a cheaper machine type with slower CPU and disk, but a lot more disk than our hypervisor nodes.</p> <p>So for example if you had an edge deployment where you are resource constrained, but also want to take nightly instance snapshots as a backup, you might have a more centrally located storage node and Shaken Fist would migrate unused blobs there to free up space on the edge nodes as required. If a blob only present on a storage only node is required for an instance start, a hypervisor node will fetch it at that time.</p> <p>Finally, blobs are reference counted. They can be used by more than one artifact (for example an image which is then labelled), and we also count how many instances are using a specific blob. We only delete a blob from disk when there are no remaining references to it.</p> <p>The following operations are exposed on blobs by the REST API:</p> Operation Command line client API client list blobs <code>blob list</code> <code>get_blobs()</code>"},{"location":"features/#events","title":"Events","text":"<p>Shaken Fist has an event logging system for the main object types. So for example, instead of reading through log files to find all the state changes that an instance went through, you can simply ask for a list of the events for that instance. This also means that the instance owner can see those logs without having to be given access to your log files.</p> <p>The following object types currently record events: artifacts; blobs; instances; networks; networkinterfaces; nodes; and uploads. In general, events are exposed in the API as operations on the object they relate to. So for example there is a <code>instance events</code> command, which calls the <code>get_instance_events()</code> API client call. Those various calls are documented by their object type.</p>"},{"location":"features/#networks","title":"Networks","text":"<p>Note that networks exist in namespaces. This means that your networks are private to your namespace, and can't be seen or used by other namespaces. There is one exception -- the \"system\" administrative namespace can see all networks.</p>"},{"location":"features/#instances","title":"Instances","text":"<p>Instances are the primary reason that you'd run Shaken Fist, so there's a lot to cover in their implementation. Obviously instances can be created, deleted, listed, and shown. Additionally, you can list the network interfaces on an instance, track and change metadata on a given instance (a simple key value store similar to OpenStack tags), request the current serial console output; and see events related to the instance. Instances can also have their power state managed: soft (ACPI) reboots; hard (power cycle) reboots; powered off; powered on; and paused.</p> <p>When creating an instance you can configure:</p> <ul> <li>the name of the instance</li> <li>how many vCPUs the instance has</li> <li>how much memory the instance has</li> <li>what network connections the instance has, including floating IP attachments and the network interface model to use</li> <li>what disks the instance has, their size, type, and bus</li> <li>what ssh key cloud-init should set up, if your instance includes cloud-init</li> <li>other arbitrary user data which will be passed to cloud-init, if installed</li> <li>the namespace of the instance</li> <li>what video card the instance has, including the model and amount of video memory</li> <li>whether BIOS boot or UEFI boot is used</li> <li>whether secure boot is enabled, including a NVRAM template if required</li> <li>what configuration drive type is used, with a default of OpenStack style</li> <li>key and value metadata</li> </ul> <p>Note that instances exist in namespaces. This means that your instances are private to your namespace, and can't be seen or used by other namespaces. There is one exception -- the \"system\" administrative namespace can see all instances.</p>"},{"location":"features/#other-features","title":"Other features","text":"<p>Shaken Fist supports the follow other features that are not directly related to an object type:</p> <ul> <li>JWT based API authentication</li> <li>graceful shutdown of hypervisors where current work is finished before the processes are stopped</li> <li>online upgrade of object versions as required</li> </ul>"},{"location":"features/#comparison-to-openstack","title":"Comparison to OpenStack","text":"<p>The development team's background is OpenStack, so we find it useful to provide a comparison between what OpenStack supports and what Shaken Fist supports. However, Shaken Fist does not intend to be a direct replacement for OpenStack, and implements many features not present in OpenStack (for example in guest agents).</p> <p>Here's a simple feature matrix listing when a feature was introduced:</p> Feature Implemented Planned Not Planned Servers / instances v0.1 Networks v0.1 Multiple NIC's for a given server v0.1 Pre-cache a server image v0.1 Floating IPs v0.1 Pause v0.1 Reboot (hard and soft) v0.1 Security groups Yes Text console v0.1 VDI v0.1 User data v0.1 Keypairs v0.1 Virtual networks allow overlapping IP allocations v0.1 REST API authentication and object ownership v0.2 Snapshots (of all disks) v0.1 Central API service v0.1 Scheduling v0.1 Volumes No plans Quotas No plans API versioning No plans Keystone style service lookup and URLs No plans Create multiple servers in a single request No plans Resize a server No plans Server groups No plans Change admin password No plans Rebuild a server No plans Shelve / unshelve No plans Trigger crash dump No plans Live migration No plans Flavors No plans Guest agents No plans Host aggregates No plans Server tags v0.2, we call them \"metadata\" ~~Persistence in MySQL~~ v0.1 Distributed etcd for locking and persistence v0.2 Production grade REST API via gunicorn v0.2 Python REST API client v0.1 golang REST API client v0.2 Terraform provider v0.2"},{"location":"manifesto/","title":"The Shaken Fist Manifesto","text":"<p>This document attempts to list Shaken Fist's defining features, give guidance on what type of features should be added to the project, how they should be implemented and how we work together.</p>"},{"location":"manifesto/#shaken-fist-defining-characteristics","title":"Shaken Fist Defining Characteristics","text":"<ul> <li>Shaken Fist is smaller, simpler cloud.</li> <li>It is designed for relatively small environments with minimum management overhead.</li> <li>Its features are highly opinionated. This means that the maintainers have chosen   the best (in their opinion) features to support.</li> <li>Opinionated features do not handle every single possible use case. This reduces   the code base size thus increasing long-term maintainability.</li> <li>The code base is understandable in its entirety by a single developer.</li> <li>A Shaken Fist cluster does not need a team of engineers to install or operate.</li> <li>A Shaken Fist cluster should be simple to set up. We define 'simple' as \"a person   with no knowledge of the project can build a reasonable cluster in an evening\".</li> </ul>"},{"location":"manifesto/#project-goals","title":"Project Goals","text":"<ul> <li>Allow simple management of virtual machine instances without complexity.</li> <li>Support networking between those machines and also facilitate access to external   networks.</li> <li>Avoid re-inventing the wheel (utilise other open source projects when appropriate).</li> </ul>"},{"location":"manifesto/#feature-guidelines","title":"Feature Guidelines","text":"<ul> <li>Features should be deliberately limited in the options available.</li> <li>The goal of limiting options is to reduce code complexity. If the option does   not add significant code complexity then it should added.</li> <li>The supported features and the options of those features should aim to cover   the majority of use cases.</li> <li>When a feature limits the available options, it should do so in a way that does   not overly restrict a project fork from adding that option.</li> <li>New code should conform to the conventions of the existing code base and written   to be easily understood.</li> <li>New code should have new tests (please).</li> </ul>"},{"location":"manifesto/#significant-opinionated-design-decisions","title":"Significant Opinionated Design Decisions","text":"<ul> <li>The only supported hypervisor is KVM managed by libvirt.</li> <li>Virtual networking is only implemented via VXLAN meshes.</li> <li>Single machine clusters should always be possible.</li> <li>Only the current Ubuntu LTS version and Debian supported by the main project   (pull requests to support other operating systems are encouraged).</li> </ul>"},{"location":"manifesto/#project-interaction-guidelines","title":"Project Interaction Guidelines","text":"<ul> <li>Always polite.</li> <li>Always generous.</li> <li>Being opinionated is encouraged (but gently).</li> <li>Updating the documentation is just as important as the code change itself.</li> <li>Developers who write tests are the most highly prized of all the developers.</li> </ul>"},{"location":"developer_guide/authentication/","title":"Authentication and Namespaces","text":"<p>Shaken Fist uses JWT tokens for authentication and access control. These tokens are created with a request to the REST API and then passed as part of subsequent calls in the form of a HTTP header on the request. The tokens can expire, in which case a caller needs to re-authenticate and then retry their request. The process to create and use a token is discussed further in the Authentication section below.</p> <p>Shaken Fist logically divides objects into \"namespaces\". These namespaces can be thought of as tenants, although there might be other reasons to divide resources into their own buckets -- for example the Shaken Fist CI system uses a namespace to store an archive of the images used for CI runs, and that namespace is referred to by the namespaces actually running tests. The process to create a namespace is discussed in the Creating namespaces section below.</p>"},{"location":"developer_guide/authentication/#namespaces","title":"Namespaces","text":"<p>All resources (instances, networks, network interfaces, and artifacts) are assigned to a namespace. Notably, blobs are not within namespaces and more than one artifact can refer to a given blob even if those artifacts are in different namespaces. It is assumed that knowing the UUID of a given blob implies that you can access it.</p> <p>All requests to Shaken Fist have a namespace context. The namespace \"system\" is reserved and is used for administrative actions. Please note that the authentication configuration created by the <code>getsf</code> installer is for the system namespace, and if used directly will result in instances and other objects being created in that namespace. While this is supported and will function as expected, it is probably undesirable for anything other than a single user installation.</p> <p>By default only requests in the system namespace are able to access resources in other (foreign) namespaces. Before Shaken Fist v0.7 this behavior was hard coded and not configurable. As of Shaken Fist v0.7, this is implemented in the form of \"trusts\", where every namespace is configured to \"trust\" the system namespace. This makes the resources visible to the system namespace. You cannot remove the trust of the system namespace from your namespaces. However, you can choose to trust additional namespaces, and this is done via the <code>sf-client namespace trust ...</code> series of commands and associated API calls.</p>"},{"location":"developer_guide/authentication/#authentication","title":"Authentication","text":"<p>When the <code>getsf</code> installer ran, it created two authentication artifacts on the primary node which are useful to get started with Shaken Fist. First off, there is <code>/etc/sf/sfrc</code>, which is a file you can source in your shell to provide authentication environment variables. These environment variables can be used by Shaken Fist command line clients, Ansible modules, and the Python API client implementation itself. An example <code>sfrc</code> looks like this:</p> <pre><code># Command line hinting\neval \"$(_SF_CLIENT_COMPLETE=bash_source sf-client)\"\n\n# Use the v3 etcd API\nexport ETCDCTL_API=3\n\n# Client auth\nexport SHAKENFIST_NAMESPACE=\"system\"\nexport SHAKENFIST_KEY=\"oisoSe7T\"\nexport SHAKENFIST_API_URL=\"https://shakenfist/api\"\n</code></pre> <p>The first two lines of the file enable tab completion for <code>sf-client</code> in a bash shell. The middle section defaults <code>etcd</code> to use the v3 API and can be ignored for now. The last three lines are the important authentication details:</p> <ul> <li>the namespace we want to use is called \"system\".</li> <li>our access key is \"oisoSe7T\".</li> <li>the URL the API exists at is \"https://shakenfist/api\"</li> </ul> <p><code>sfrc</code> is only useful to users of Unix-like shells, so there is also a JSON form of this configuration information, which is written by <code>getsf</code> at <code>/etc/sf/shakenfist.json</code>. Here's an example:</p> <pre><code>{\n    \"namespace\": \"system\",\n    \"key\": \"oisoSe7T\",\n    \"apiurl\": \"https://shakenfist/api\"\n}\n</code></pre> <p>The Shaken Fist command line clients, Ansible modules, and the Python API client will look for configuration in the following locations:</p> <ul> <li>environment variables.</li> <li><code>.shakenfist</code> in your home directory, that is <code>~/.shakenfist</code>.</li> <li><code>/etc/sf/shakenfist.json</code>.</li> </ul>"},{"location":"developer_guide/authentication/#creating-namespaces","title":"Creating namespaces","text":"<p>You can create your first namespace like this, assuming you are authenticated as the system namespace:</p> <pre><code>sf-client namespace create new-namespace\n</code></pre> <p>By default a new namespace has no access keys or trusts configured, and therefore is only accessible to users of the system namespace.</p>"},{"location":"developer_guide/authentication/#key-management","title":"Key management","text":"<p>Namespaces are accessed by providing a valid \"key\" for the namespace. While keys have names, they do not have to be usernames and passwords -- my mental model is more like API access tokens in something like GitHub than usernames and passwords. I tend to create a new key for each program which is interacting with the namespace, and then give it a descriptive name.</p> <p>You can create a new key like this:</p> <pre><code>sf-client namespace add-key namespace-name keyname key\n</code></pre> <p>There can be more than one key for a namespace. The key name is not used as part of the authentication process, and is largely used for key management (deleting the key) and logging which access token was used in the event logs.</p> Info <p>Please note the key prefix \"_service_key\" is reserved for internal use within Shaken Fist. This usage is discussed in the Inter-node Authentication section below.</p>"},{"location":"developer_guide/authentication/#authenticating-directly-to-the-rest-api","title":"Authenticating directly to the REST API","text":"<p>The authentication endpoint <code>/auth</code> is used to obtain a token to authenticate future API requests. For example, I can obtain an authentication token from the REST API using <code>curl</code> like this:</p> <pre><code>curl -X POST https://shakenfist/api/auth -d '{\"namespace\": \"system\", \"key\": \"oisoSe7T\"}'\n{\n    \"access_token\": \"eyJhbG...IkpXVCJ9.eyJmc...wwQ\",\n    \"token_type\": \"Bearer\",\n    \"expires_in\": 900\n}\n</code></pre> <p>That is, a HTTP POST request to the <code>/auth</code> endpoint for the REST API (in our case hosted at <code>https://shakenfist/api</code>) with a JSON body containing a dictionary of the namespace name and the key to use.</p> <p>In the response the <code>access_token</code> value of  <code>eyJhbG...IkpXVCJ9.eyJmc...wwQ</code> is our JWT token and has been truncated in this example for readability. Authentication tokens expire after a fixed period of time (nominally 15 minutes), but you will be informed that the token as expired by receiving a 401 Unauthorized response. If that occurs, simply create a new token as above and retry your request.</p> <p>Subsequent requests to the REST API pass the token via an <code>Authorization</code> HTTP header, and should request a <code>Content-Type</code> of <code>application/json</code>. For example, to list the namespaces in our deployment we would make a <code>curl</code> request like this:</p> <pre><code>curl -X GET https://shakenfist/api/auth/namespaces \\\n    -H 'Authorization: Bearer eyJhbG...IkpXVCJ9.eyJmc...wwQ' \\\n    -H 'Content-Type: application/json'\n[\n    {\n        \"name\": \"adhoc\",\n        \"state\": \"created\",\n        \"trust\": {\"full\": [\"system\"]}\n    }, {\n        \"name\": \"ci\",\n        \"state\": \"created\",\n        \"trust\": {\"full\": [\"system\"]}\n    }, {\n        \"name\": \"system\",\n        \"state\": \"created\",\n        \"trust\": {\"full\": [\"system\"]}\n    }\n]\n</code></pre> <p>The JSON response here has been formatted for readability.</p> Info <p>Note the word \"Bearer\" before the access token in the Authorization header.</p>"},{"location":"developer_guide/authentication/#contents-of-the-jwt-tokens","title":"Contents of the JWT tokens","text":"<p>JWT authentication tokens are base64 encoded parts separated by the <code>.</code> character. They are therefore trivial to decode. A decoded example (generated by the online decoder at https://jwt.io/) is:</p> <pre><code>{\n    \"alg\": \"HS256\",\n    \"typ\": \"JWT\"\n}\n.\n{\n    \"fresh\": false,\n    \"iat\": 1669786988,\n    \"jti\": \"906f4bfa-3218-4d07-a036-ac6b44ded67e\",\n    \"type\": \"access\",\n    \"sub\": [\n        \"system\",\n        \"deploy\"\n    ],\n    \"nbf\": 1669786988,\n    \"exp\": 1669787888,\n    \"iss\": \"shakenfist\",\n    \"nonce\": \"ByKNRUVBfMBoQC1Z\"\n}\n.\nHMACSHA256(\n    base64UrlEncode(header) + \".\" +\n    base64UrlEncode(payload),\n    your-256-bit-secret\n)\n</code></pre> <p>You can see here that Shaken Fist stores the authenticated namespace <code>system</code> and the key used to authenticate <code>deploy</code> under the <code>sub</code> key in this token. You should not assume that the content of JWT tokens produced by Shaken Fist are opaque to users.</p> <p>For releases prior to v0.7, the token was blindly trusted for authentication. From v0.7 we verify that the named key still exists in the namespace before authorizing API requests. This test is performed by updating a \"nonce\" value for a given key when the key is updated. The JWT token a caller is handed includes this nonce, and if the nonce we are handed on a request does not match the current value in the database the request is rejected.</p>"},{"location":"developer_guide/authentication/#inter-node-authentication","title":"Inter-node Authentication","text":"<p>Requests between Shaken Fist nodes use the same authentication system and REST API as external API requests. When a node makes an API request to another node, the originating node will create (or reuse) a \"service key\" specific to the namespace of the original request.</p> <p>When a request is made from the \"system\" namespace for a resource in a different namespace, the API request is made using the foreign namespace and the foreign namespace's service key.</p> <p>Service keys exist in the namespace's key data structures just as other keys do, and are therefore visible when you list keys. As of v0.7, service keys expire after five minutes, and are never reused. Before v0.7 service keys were always named \"_service_key\". From v0.7 service keys have a name of the form \"_service_key[a-zA-Z]+\".</p>"},{"location":"developer_guide/authentication/#key-storage","title":"Key Storage","text":"<p>Shaken Fist stores the access keys in <code>etcd</code>. The keys are stored as the base64 encoding of the key post salting and hashing. The python <code>bcrypt</code> library is used to perform salting, hashing, and key verification.</p>"},{"location":"developer_guide/ci_api_coverage/","title":"CI API Coverage","text":"<p>This document tracks the CI coverage for each of our public APIs. The intent to make it clear what is \"sufficiently tested\", and what needs further effort. This list is manually updated, so we'll need to show discipline in ensuring that we update it as we change APIs or CI.</p> <p>For this document we use the python API client as a model of what to cover, as its simpler to extract a list of calls from than the API implementation itself. We list whether we have CI which calls the API directly, CI which uses the python command line client to call the API, or both. The gold standard is both.</p>"},{"location":"developer_guide/ci_api_coverage/#get_instances","title":"get_instances","text":"<p>Whilst being implied by every test tearDown(), this call is explicitly used in:</p> <ul> <li>TestCirros.test_cirros_boot_no_network</li> <li>TestCirros.test_cirros_boot_network</li> <li>TestPlacement.test_local_placement_works</li> <li>TestPlacement.test_remote_placement_works</li> <li>TestSystemNamespace.test_system_namespace</li> <li>TestUbuntu.test_ubuntu_pings</li> </ul>"},{"location":"developer_guide/ci_api_coverage/#delete_all_instances","title":"delete_all_instances","text":"<p>Not tested.</p>"},{"location":"developer_guide/ci_api_coverage/#get_instance","title":"get_instance","text":"<p>All callers of await_instance_event call get_instance(). However, these more explicit tests exist as well:</p> <ul> <li>TestCacheImage.test_instance_invalid_image</li> </ul>"},{"location":"developer_guide/ci_api_coverage/#get_instance_interfaces","title":"get_instance_interfaces","text":"<ul> <li>TestMultipleNics.test_simple</li> <li>TestNetworking.test_virtual_networks_are_separate</li> <li>TestNetworking.test_overlapping_virtual_networks_are_separate</li> <li>TestNetworking.test_single_virtal_networks_work</li> <li>TestNetworking.test_specific_ip_request</li> <li>TestPlacement.test_local_placement_works</li> <li>TestPlacement.test_remote_placement_works</li> <li>TestStateChanges.test_lifecycle_events</li> <li>TestUbuntu.test_ubuntu_pings</li> </ul>"},{"location":"developer_guide/ci_api_coverage/#get_instance_metadata","title":"get_instance_metadata","text":"<ul> <li>TestInstanceMetadata.test_simple</li> </ul>"},{"location":"developer_guide/ci_api_coverage/#set_instance_metadata_item","title":"set_instance_metadata_item","text":"<ul> <li>TestInstanceMetadata.test_simple</li> </ul>"},{"location":"developer_guide/ci_api_coverage/#delete_instance_metadata_item","title":"delete_instance_metadata_item","text":"<p>Not tested.</p>"},{"location":"developer_guide/ci_api_coverage/#create_instance","title":"create_instance","text":"<p>Tested extensively in most other tests, so tests are not listed here.</p>"},{"location":"developer_guide/ci_api_coverage/#snapshot_instance","title":"snapshot_instance","text":"<ul> <li>TestSnapshots.test_single_disk_snapshots</li> <li>TestSnapshots.test_multiple_disk_snapshots</li> </ul>"},{"location":"developer_guide/ci_api_coverage/#get_instance_snapshots","title":"get_instance_snapshots","text":"<ul> <li>TestSnapshots.test_single_disk_snapshots</li> <li>TestSnapshots.test_multiple_disk_snapshots</li> </ul>"},{"location":"developer_guide/ci_api_coverage/#reboot_instance","title":"reboot_instance","text":"<ul> <li>TestStateChanges.test_lifecycle_events</li> </ul>"},{"location":"developer_guide/ci_api_coverage/#power_off_instance","title":"power_off_instance","text":"<ul> <li>TestStateChanges.test_lifecycle_events</li> </ul>"},{"location":"developer_guide/ci_api_coverage/#power_on_instance","title":"power_on_instance","text":"<ul> <li>TestStateChanges.test_lifecycle_events</li> </ul>"},{"location":"developer_guide/ci_api_coverage/#pause_instance","title":"pause_instance","text":"<ul> <li>TestStateChanges.test_lifecycle_events</li> </ul>"},{"location":"developer_guide/ci_api_coverage/#unpause_instance","title":"unpause_instance","text":"<ul> <li>TestStateChanges.test_lifecycle_events</li> </ul>"},{"location":"developer_guide/ci_api_coverage/#delete_instance","title":"delete_instance","text":"<p>Whilst being implied by every test tearDown(), this call is explicitly used in:</p> <ul> <li>TestCirros.test_cirros_boot_no_network</li> <li>TestCirros.test_cirros_boot_network</li> <li>TestPlacement.test_local_placement_works</li> <li>TestPlacement.test_remote_placement_works</li> <li>TestSnapshots.test_single_disk_snapshots</li> <li>TestSnapshots.test_multiple_disk_snapshots</li> <li>TestSystemNamespace.test_system_namespace</li> <li>TestUbuntu.test_ubuntu_pings</li> </ul>"},{"location":"developer_guide/ci_api_coverage/#get_instance_events","title":"get_instance_events","text":"<p>All callers of await_instance_event call get_instance(). However, more testing of this method is required.</p>"},{"location":"developer_guide/ci_api_coverage/#cache_image","title":"cache_image","text":"<ul> <li>TestImages.test_cache_image</li> </ul>"},{"location":"developer_guide/ci_api_coverage/#get_images","title":"get_images","text":"<p>(Formerly get_image_meta, old name to be removed in 0.5).</p> <ul> <li>TestImages.test_cache_image</li> </ul>"},{"location":"developer_guide/ci_api_coverage/#get_image_events","title":"get_image_events","text":"<p>Not tested.</p>"},{"location":"developer_guide/ci_api_coverage/#get_networks","title":"get_networks","text":"<p>Whilst being implied by every test tearDown(), this call is explicitly used in:</p> <ul> <li>TestSystemNamespace.test_system_namespace</li> </ul>"},{"location":"developer_guide/ci_api_coverage/#get_network","title":"get_network","text":"<p>Not tested.</p>"},{"location":"developer_guide/ci_api_coverage/#delete_network","title":"delete_network","text":"<p>Whilst being implied by every test tearDown(), this call is explicitly used in:</p> <ul> <li>TestSystemNamespace.test_system_namespace</li> </ul>"},{"location":"developer_guide/ci_api_coverage/#delete_all_networks","title":"delete_all_networks","text":"<p>Not tested.</p>"},{"location":"developer_guide/ci_api_coverage/#get_network_events","title":"get_network_events","text":"<p>Not tested.</p>"},{"location":"developer_guide/ci_api_coverage/#allocate_network","title":"allocate_network","text":"<p>Tested extensively in most other tests, so tests are not listed here.</p>"},{"location":"developer_guide/ci_api_coverage/#get_network_interfaces","title":"get_network_interfaces","text":"<p>Not tested.</p>"},{"location":"developer_guide/ci_api_coverage/#get_network_metadata","title":"get_network_metadata","text":"<p>Not tested.</p>"},{"location":"developer_guide/ci_api_coverage/#set_network_metadata_item","title":"set_network_metadata_item","text":"<p>Not tested.</p>"},{"location":"developer_guide/ci_api_coverage/#delete_network_metadata_item","title":"delete_network_metadata_item","text":"<p>Not tested.</p>"},{"location":"developer_guide/ci_api_coverage/#get_nodes","title":"get_nodes","text":"<p>Not tested.</p>"},{"location":"developer_guide/ci_api_coverage/#get_interface","title":"get_interface","text":"<p>Not tested.</p>"},{"location":"developer_guide/ci_api_coverage/#float_interface","title":"float_interface","text":"<p>Not tested.</p>"},{"location":"developer_guide/ci_api_coverage/#defloat_interface","title":"defloat_interface","text":"<p>Not tested.</p>"},{"location":"developer_guide/ci_api_coverage/#get_console_data","title":"get_console_data","text":"<ul> <li>TestConsoleLog.test_console_log</li> </ul>"},{"location":"developer_guide/ci_api_coverage/#get_namespaces","title":"get_namespaces","text":"<p>As well as being tested as a side effect of most other tests, there is the following explicit test:</p> <ul> <li>TestAuth.test_namespaces</li> </ul>"},{"location":"developer_guide/ci_api_coverage/#create_namespace","title":"create_namespace","text":"<p>As well as being tested as a side effect of most other tests, there is the following explicit test:</p> <ul> <li>TestAuth.test_namespaces</li> </ul>"},{"location":"developer_guide/ci_api_coverage/#delete_namespace","title":"delete_namespace","text":"<p>As well as being tested as a side effect of most other tests, there is the following explicit test:</p> <ul> <li>TestAuth.test_namespaces</li> </ul>"},{"location":"developer_guide/ci_api_coverage/#get_namespace_keynames","title":"get_namespace_keynames","text":"<p>Not tested.</p>"},{"location":"developer_guide/ci_api_coverage/#add_namespace_key","title":"add_namespace_key","text":"<ul> <li>TestAuth.test_namespaces</li> </ul>"},{"location":"developer_guide/ci_api_coverage/#delete_namespace_key","title":"delete_namespace_key","text":"<ul> <li>TestAuth.test_namespaces</li> </ul>"},{"location":"developer_guide/ci_api_coverage/#get_namespace_metadata","title":"get_namespace_metadata","text":"<p>Not tested.</p>"},{"location":"developer_guide/ci_api_coverage/#set_namespace_metadata_item","title":"set_namespace_metadata_item","text":"<p>Not tested.</p>"},{"location":"developer_guide/ci_api_coverage/#delete_namespace_metadata_item","title":"delete_namespace_metadata_item","text":"<p>Not tested.</p>"},{"location":"developer_guide/ci_api_coverage/#get_existing_locks","title":"get_existing_locks","text":"<p>Not tested.</p>"},{"location":"developer_guide/ci_api_coverage/#ping","title":"ping","text":"<p>Tested as a side effect of many other tests, but no explicit test.</p>"},{"location":"developer_guide/io_performance_tuning/","title":"IO performance tuning","text":"<p>This page documents experiments in tuning the IO performance of Shaken Fist. It explains how we've ended up with the options we use, and what other options we considered along the way. qemu has quite a helpful guide to performance options for IO tuning at https://git.qemu.org/?p=qemu.git;a=blob;f=docs/qcow2-cache.txt , but it does not provide concrete recommendations.</p>"},{"location":"developer_guide/io_performance_tuning/#before-tuning","title":"Before tuning","text":"<p>First off, here are some base line performance numbers before we did any tuning. All performance tests were on a Samsung Pro 980 with libvirt / kvm / qemu. All disks were a 100GB copy on write layer on top of a 30 GB virtual backing file, on an otherwise idle machine. The virtual machine had 16 vCPU and 32 GB RAM.</p> <p>In the interests of the comparisons below, the untuned cluster uses writethrough caching and a cluster size of 64K:</p> <pre><code>dd if=/dev/zero of=test1.img bs=1G count=50 oflag=dsync\n</code></pre> <p>All numbers are the first run (incurs new cluster allocation cost, see later in this document), and then the average of the fastest three of five subsequent runs.</p> <ul> <li>Raw NVMe disk: 1,229 MB/s</li> <li>Before tuning: 611 MB/s, 655 MB/s (689, 589, 524, 572, 689)</li> </ul> <pre><code>hdparm -Tt /dev/vda1\n</code></pre> <p>I have only recorded the buffered disk read value, as the other value is based on caching. I've used the same average of the fastest three from a run of five that I did above:</p> <ul> <li>Raw NVMe disk: 2,572 MB/s</li> <li>Before tuning: 1,283 MB/s (695.13, 967.22, 1142.13, 1310.75, 1396.96)</li> </ul> <p>Note that all experiments below are based on a single change compared to the starting state. So for example the cluster size change experiment used the default caching of writethrough.</p>"},{"location":"developer_guide/io_performance_tuning/#disk-cache-mode","title":"Disk cache mode","text":"<p>qemu supports a variety of disk caching modes for disks. https://documentation.suse.com/sles/11-SP4/html/SLES-kvm4zseries/cha-qemu-cachemodes.html is a good summary of the options, which are all exposed by libvirt. Modern libvirts default to writeback, which is equivalent to using a battery backed RAID controller in a physical machine. It therefore does assume a similar level of reliability from your hypervisor nodes.</p> <p>Within libvirt, the caching is specified using the cache attribute to the driver element. The libvirt documentation states:</p> <p>The optional cache attribute controls the cache mechanism, possible values are \"default\", \"none\", \"writethrough\", \"writeback\", \"directsync\" (like \"writethrough\", but it bypasses the host page cache) and \"unsafe\" (host may cache all disk io, and sync requests from guest are ignored). Since 0.6.0, \"directsync\" since 0.9.5, \"unsafe\" since 0.9.7.</p> <p>So for the libvirt.tmpl domain XML template within Shaken Fist, specifying a writethrough as a caching mode would look like this:</p> <pre><code>{%- for disk in disks %}\n{%- if disk.bus != 'nvme' %}\n&lt;disk type='{{disk.source_type}}' device='{{disk.present_as}}'&gt;\n  &lt;driver name='qemu' type='{{disk.type}}' cache='writethrough'/&gt;\n  {{disk.source}}\n  {{disk.backing}}\n  &lt;target dev='{{disk.device}}' bus='{{disk.bus}}'/&gt;\n&lt;/disk&gt;\n{%- endif %}\n{%- endfor %}\n</code></pre> <p>Some performance numbers:</p> <pre><code>dd if=/dev/zero of=test1.img bs=1G count=50 oflag=dsync\n</code></pre> <p>All numbers are the first run (incurs new cluster allocation cost, see later in this document), and then the average of the fastest three of five subsequent runs.</p> <ul> <li>Raw NVMe disk: 1,229 MB/s</li> <li>Cache none: 958 MB/s, 987 MB/s (948, 991, 1024, 866, 837)</li> <li>Cache writethrough: 499 MB/s, 656 MB/s (577, 735, 637, 596, 574)</li> <li>Cache writeback: 606 MB/s, 677 MB/s (686, 721, 589, 568, 625)</li> <li>Cache directsync: 626 MB/s, 823 MB/s (676, 938, 760, 771, 727)</li> <li>Cache unsafe: 857 MB/s, 1,012 MB/s (963, 1126, 948, 859, 840)</li> </ul> <pre><code>hdparm -Tt /dev/vda1\n</code></pre> <p>I have only recorded the buffered disk read value, as the other value is based on caching. I've used the same average of the fastest three from a run of five that I did above:</p> <ul> <li>Raw NVMe disk: 2,572 MB/s</li> <li>Cache none: 849 MB/s (535.09, 712.36, 791.02, 859.13, 899.20)</li> <li>Cache writethrough: 1,352 MB/s (598.37, 927.03, 1237.42, 1300.84, 1519.23)</li> <li>Cache writeback: 1,589.12 MB/s (756.97, 1244.58, 1433.67, 1639.21, 1694.48)</li> <li>Cache directsync: 1,038.69 MB/s (914.48, 1031.09, 1065.92, 755.77, 1019.06)</li> <li>Cache unsafe: 1,272 MB/s (656.32, 944.18, 1122.15, 1270.44, 1424.00)</li> </ul> <p>What cache modes a safe in terms of data integrity? This is what https://documentation.suse.com/sles/11-SP4/html/SLES-kvm4zseries/cha-qemu-cachemodes.html has to say:</p> <p>cache = writethrough, cache = none, cache=directsync: These are the safest modes, and considered equally safe, given that the guest operating system is \u201cmodern and well behaved\u201d, which means that it uses flushes as needed. If you have a suspect guest, use writethough, or directsync. Note that some file systems are not compatible with cache=none or cache=directsync, as they do not support O_DIRECT, which these cache modes relies on.</p> <p>Specifically, I don't think that Shaken Fist should use any unsafe caching mode, which eliminates the aptly named unsafe as an option.</p> <p>Recommendation: we should convert to using cache mode \"none\" for instances. It provides slower read performance, but much better write performance.</p>"},{"location":"developer_guide/io_performance_tuning/#cluster-size","title":"Cluster size","text":"<p>qcow2 defaults to a cluster size of 64KB, and the maximum is 2MB. The value must be a power of two. The balance here is that the cluster size is the unit of allocation of disk when the disk needs to grow -- so a large cluster size will cause an image to grow larger than it might otherwise, but 2MB doesn't seem like a large overhead. However, if you are using a copy on write layer and change one byte of a fully allocated cluster, a 2MB cluster size means that 2MB must be read from the backing file, the byte changed, and then that 2MB written to the copy on write layer. That IO cost can add up depending on your workload.</p> <p>https://www.ibm.com/cloud/blog/how-to-tune-qemu-l2-cache-size-and-qcow2-cluster-size has a good description of how the cluster size affects cache behaviour with qcow2, as a larger cluster size also implies that you're more likely to have in-memory cache hits and avoid extra IO operations looking up caches from disk. In the worst case, a single IO can incur the actual IO operations if the cache entries required are not currently in memory.</p> <p>Pleasingly, cluster size is an attribute of the qcow2 file, not the hypervisor configuration. This makes it easy for us to run benchmarks against without having to tweak the hypervisor too much.</p> <p>You tune cluster size like this:</p> <pre><code>qemu-img create -f qcow2 -o cluster_size=2M foo.qcow2 100G\n</code></pre> <p>First off, the backing image size changes as I change the cluster size. Remember that in a hypervisor environment where the backing image is shared between VMs, the cost of increased size here is reduced by the multiple users of th backing image.</p> <p>It should be noted that you can have a different cluster size in the copy on write layer compared to the backing image, but I have not tested that as I want to keep the number of permutations here manageable.</p> <p>Some performance numbers, noting that performance will vary based on the size of the disk -- that is, very large disks would benefit from higher cluster sizes. I have selected what I think is a representative size for a Shaken Fist instance in these test runs:</p> <pre><code>qemu-img convert -p -O qcow2 -o cluster_size=256K old.qcow2 new.qcow2\n</code></pre> <ul> <li>Cluster size 64 K: 672 MB</li> <li>Cluster size 128 K: 1.7 GB</li> <li>Cluster size 256 K: 1.7 GB</li> <li>Cluster size 512 K: 1.7 GB</li> <li>Cluster size 1,024 K: 1.7 GB</li> <li>Cluster size 2,048 K: 1.8 GB</li> </ul> <pre><code>dd if=/dev/zero of=test1.img bs=1G count=50 oflag=dsync\n</code></pre> <p>All numbers are the first run (incurs new cluster allocation cost), and then the average of the fastest three of five subsequent runs.</p> <ul> <li>Raw NVMe disk: 1,229 MB/s</li> <li>Cluster size 64 K: 611 MB/s, 655 MB/s (689, 589, 524, 572, 689)</li> <li>Cluster size 128 K: 631 MB/s, 654 MB/s (465, 701, 594, 531, 666)</li> <li>Cluster size 256 K: 630 MB/s, 651 MB/s (708, 667, 580, 539, 574)</li> <li>Cluster size 512 K: 630 MB/s, 643 MB/s (666, 680, 531, 584, 560)</li> <li>Cluster size 1,024 K: 632 MB/s, 631 MB/s (734, 605, 520, 555, 541)</li> <li>Cluster size 2,048 K: 648 MB/s, 704 MB/s (732, 731, 650, 559, 558)</li> </ul> <pre><code>hdparm -Tt /dev/vda1\n</code></pre> <p>I have only recorded the buffered disk read value, as the other value is based on caching. I've used the same average of the fastest three from a run of five that I did above:</p> <ul> <li>Raw NVMe disk: 2,572 MB/s</li> <li>Cluster size 64 K: 1,283 MB/s (695.13, 967.22, 1142.13, 1310.75, 1396.96)</li> <li>Cluster size 128 K: 2,742 MB/s (2618.60, 3080.81, 2500.19, 2526.23, 1740.01)</li> <li>Cluster size 256 K: 3,378 MB/s (1286.86, 2167.27, 2903.52, 3399.29, 3830.55)</li> <li>Cluster size 512 K: 2,575 MB/s (1011.34, 1543.60, 2126.33, 2605.66, 2992.87)</li> <li>Cluster size 1,024 K: 2,631 MB/s (2279.93, 2329.68, 2229.67, 2622.82, 2940.58)</li> <li>Cluster size 2,048 K: 2,402 MB/s (899.56, 1517.90, 1992.42, 2447.05, 2767.72)</li> </ul> <p>Recommendation: a cluster size of 2,048K will use marginally more RAM to store the caches, but improves disk performance significantly, especially for reads.</p>"},{"location":"developer_guide/io_performance_tuning/#final-performance","title":"Final performance","text":"<p>In the interests of gloating, here are our original performance numbers, compared to after tuning:</p> <pre><code>dd if=/dev/zero of=test1.img bs=1G count=50 oflag=dsync\n</code></pre> <p>All numbers are the first run (incurs new cluster allocation cost, see later in this document), and then the average of the fastest three of five subsequent runs.</p> <ul> <li>Raw NVMe disk: 1,229 MB/s</li> <li>Before tuning: 611 MB/s, 655 MB/s (689, 589, 524, 572, 689)</li> <li>After tuning: 992 MB/s, 991 MB/s (958, 1024, 906, 869, 838)</li> </ul> <pre><code>hdparm -Tt /dev/vda1\n</code></pre> <p>I've used the same average of the fastest three from a run of five that I did above:</p> <ul> <li>Raw NVMe disk: 2,572 MB/s</li> <li>Before tuning: 1,283 MB/s (695.13, 967.22, 1142.13, 1310.75, 1396.96)</li> <li>After tuning: 1,560 MB/s (717.71, 1120.44, 1394.56, 1516.47, 1770.01)</li> </ul>"},{"location":"developer_guide/release_process/","title":"Shaken Fist's release process","text":"<p>Shaken Fist is now split across a number of repositories to simplify development and usage. Unfortunately, that complicated the release process. This page documents the current release process although the reality is that only Michael can do a release right now because of the requirement to sign releases with his GPG key.</p>"},{"location":"developer_guide/release_process/#testing","title":"Testing","text":"<p>We only release things which have passed CI testing, and preferably have had a period running as the underlying cloud for the CI cluster as well. Sometimes in an emergency we will bend the rules for a hotfix, but we should try and avoid doing that.</p>"},{"location":"developer_guide/release_process/#for-reach-repository-to-be-released","title":"For reach repository to be released","text":"<p>Checkout the repository and ensure you're in the right branch. Then just run <code>release.sh</code> and follow the bounching ball.</p>"},{"location":"developer_guide/standards/","title":"Concepts and Standards","text":""},{"location":"developer_guide/standards/#ensuring-a-common-language-within-the-code-base","title":"Ensuring a Common Language within the code base","text":"<p>This document records the standards and common language used within the Shaken Fist software system.</p> <p>It should also record why the choice was made.</p> <p>(This is actually just notes to save our future selves from tripping over the same problems.)</p>"},{"location":"developer_guide/standards/#etcd-keys","title":"etcd keys","text":"<p>Key names in <code>etcd</code> should be in the singular, for example <code>/sf/namespace/</code> not <code>/sf/namespaces/</code> note that this is different than the REST API.</p>"},{"location":"developer_guide/standards/#memory","title":"Memory","text":"<p>Memory is measured in MiB in Shaken Fist. All references to memory size are stored and transmitted in MiB: Gigabytes can be too big if you want a lot of small machines. Kilobytes is just too many numbers to type. The <code>libvirt</code> API measures memory in KiB. Therefore, interactions with the library need to be careful to convert from MiB to KiB.</p>"},{"location":"developer_guide/state_machine/","title":"Shaken Fist's State Machine","text":"<p>Shaken Fist implements a state machine for each object type. This page documents the possible states for each object, and which transitions between states are valid.</p>"},{"location":"developer_guide/state_machine/#instances","title":"Instances","text":"<ul> <li><code>Initial</code>: this is the first state for an instance. A UUID has been allocated, a placeholder database entry created, and a request to create the instance has been queued.</li> <li><code>Preflight</code>: the instance creation request has been dequeued and is being validated against the current state of the cluster by the scheduler.</li> <li><code>Creating</code>: the instance is being created.</li> <li><code>Created</code>: the instance is now running.</li> <li><code>Deleted</code>: the instance is now deleted.</li> <li> <p><code>Error</code>: the instance is unable to be used.</p> </li> <li> <p>Instances marked as Deleted are deleted from the DB after sitting deleted for   some period of time.</p> </li> <li> <p>Any instance may enter the Error state, which happens when something bad has happened. That process involves the instance being moved to a transition state named for the instance's previous state, so for example an instance which was Created that went into Error would transition through Created-Error. This is done because the Error transition is a queue job and happens sometime later. Instances in the Error state are not removed like those in the deleted state, as we assume a caller must acknowledge an error occured. To remove them, delete the instance in Error state.</p> </li> </ul>"},{"location":"developer_guide/state_machine/#networks","title":"Networks","text":"<ul> <li><code>Initial</code>: first state for a network. A UUID has been allocated, database entry created, and a request to create the network on the <code>networknode</code> has been queued.</li> <li><code>Created</code>: the network has been created on the <code>networknode</code>.</li> <li><code>Delete_Wait</code>: the network has been scheduled for deletion. Waiting for   instances on the network to be deleted.</li> <li><code>Deleted</code>: the network is now deleted.</li> <li> <p><code>Error</code>: the network has encountered an error and cannot be used.</p> </li> <li> <p>Networks marked as Deleted are deleted from the DB after sitting deleted for   some period of time.</p> </li> <li> <p>A network is regarded as <code>Dead</code> when it is in state <code>Deleted</code>, <code>Delete_Wait</code> or <code>Error</code>.</p> </li> </ul>"},{"location":"developer_guide/state_machine/#nodes","title":"Nodes","text":"<ul> <li><code>Created</code>: on first check in, a node is created in the \"created\" state.</li> <li><code>Stopping</code>: the node is gracefully shutting down.</li> <li><code>Stopped</code>: the node has gracefully shut down.</li> <li><code>Deleted</code>: the node was manually evacuated and removed.</li> <li><code>Missing</code>: the node has not checked in within the NODE_CHECKIN_MAXIMUM deadline.</li> <li><code>Error</code>: the node has not check in for ten times NODE_CHECKIN_MAXIMUM, and all instances on this node have been declared to be in an error state.</li> </ul>"},{"location":"developer_guide/updating_docs/","title":"Updating These Docs","text":"<p>Built using MkDocs: https://www.mkdocs.org/ Theme: https://squidfunk.github.io/mkdocs-material/customization/ </p>"},{"location":"developer_guide/updating_docs/#setup","title":"Setup","text":"<p>Install mkdocs and the material theme  <pre><code>pip install mkdocs-material\n</code></pre></p>"},{"location":"developer_guide/updating_docs/#viewing-locally","title":"Viewing Locally","text":"<p>Start the live web-server with <pre><code>mkdocs serve\n</code></pre> View at http://localhost:8000</p>"},{"location":"developer_guide/updating_docs/#deploying-to-github-pages","title":"Deploying to GitHub Pages","text":"<p>Build and deploy with <pre><code>mkdocs gh-deploy\n</code></pre> This will push to the <code>gh-pages</code> branch of the current git remote.</p>"},{"location":"developer_guide/updating_docs/#navigation-bar","title":"Navigation Bar","text":"<p>The navigation bar is configured via the <code>mkdocs.yml</code> file in the repository root.</p>"},{"location":"developer_guide/workflow/","title":"Development Workflow","text":""},{"location":"developer_guide/workflow/#short-lesson","title":"Short Lesson","text":"<p>The majority of teams using git have a work flow that looks similar to the four well known work flows:</p> <ul> <li>Git Flow</li> <li>GitHub Flow</li> <li>GitLab Flow</li> <li>Trunk Based Development</li> </ul>"},{"location":"developer_guide/workflow/#git-development-the-shaken-fist-way","title":"Git Development - the Shaken Fist Way","text":"<p>The Shaken Fist developers have chosen Trunk Based Development with some minor tweaks.</p>"},{"location":"developer_guide/workflow/#branch-types","title":"Branch Types","text":"<ol> <li> <p>Branch <code>develop</code></p> <ul> <li>This is the development trunk and has largely replaced <code>master</code> in most of our respositories.</li> <li>All <code>feature</code> branches are branched from <code>develop</code> and merged to <code>develop</code>.</li> <li>New releases are cut from the <code>develop</code> branch when we decide its time to bump the major release number.</li> <li>The <code>develop</code> branch has automated nightly CI tests, and failures create GitHub issues which must be regularly triaged. That is, CI failures on <code>develop</code> are exceptional and should not be accepted as flakey tests or \"situation normal\". CI failures are labelled as <code>ci-failure</code> in GitHub issues.</li> </ul> </li> <li> <p>Feature branches</p> <ul> <li>Short-lived, generally a few days although sometimes much longer for complicated things.</li> <li>Normally only one developer.</li> <li>When presented to the team, it is expected to pass the linter, unit tests, and CI tests.</li> <li>It is normal that other team members suggest changes / improvements before merging.</li> </ul> </li> <li> <p>Branches <code>vX.X-release</code></p> <ul> <li>Created from <code>develop</code> when a new major release is first cut. Patches and minor releases for that major version are then cut from this branch.</li> <li>Commits to this branch are cherry-picks from <code>develop</code> except in exceptional circumstances (for example the code to be changed no longer existing on <code>develop</code>).</li> <li>It is not expected that many commits are made to this branch.</li> <li>If many commits are required to a release branch then this indicates the need for another release.</li> <li>\"Recent\" release branches has automated nightly CI tests, and failures create GitHub issues which must be regularly triaged. That is, CI failures on recent releases are exceptional and should not be accepted as flakey tests or \"situation normal\". CI failures are labelled as <code>ci-failure</code> in GitHub issues. For now, this is treated as all releases from v0.6 onwards, although that will likely change at some point.</li> </ul> </li> </ol>"},{"location":"developer_guide/workflow/#process","title":"Process","text":""},{"location":"developer_guide/workflow/#bug-fix-branches","title":"Bug fix branches","text":"<ul> <li>Bug fix branches have a prefix consisting of the GitHub issue number and the word \"bug\", for example \"bug-XXX\".</li> <li>You commit should include the text <code>Fixes #XXX</code> where XXX is the GitHub issue number for the bug. It is possible to fix more than one GitHub issue in a single commit.</li> </ul>"},{"location":"developer_guide/workflow/#feature-branches","title":"Feature branches","text":"<ul> <li>Feature branches should be named \"feature-branch-XXX\" where XXX is a short description of the feature.</li> <li>The feature branch developers should squash commits to remove WIP commits before creating a Pull Request, but it is acceptable to have a series of incremental changes building up to a complete feature in the feature branch at merge time.</li> <li>It is preferable that each remaining commit passes unit testing and CI, but the final state that is merged must pass unit tests and CI.</li> </ul>"},{"location":"developer_guide/workflow/#merging","title":"Merging","text":"<ul> <li>Commits are not squashed when merged to <code>develop</code>.</li> <li>Not squashing commits maintains history of multiple issues being solved.</li> <li>Pull Request related commits remain grouped and can be understood as a single merge</li> </ul>"},{"location":"developer_guide/workflow/#minimal-backports","title":"Minimal backports","text":"<p>Only necessary bug fixes are cherry-picked from <code>master</code> to an existing release branch.</p>"},{"location":"developer_guide/api_reference/admin/","title":"Admin (/admin/)","text":""},{"location":"developer_guide/api_reference/admin/#locks","title":"Locks","text":"<p>As discussed in the operator guide, you can query what locks exist in a Shaken Fist cluster, as well as who is currently holding those locks (machine and process id).</p> REST API calls <ul> <li>GET /admin/locks: List locks currently held in the cluster.</li> </ul> Python API client: list cluster locks <pre><code>from shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nlocks = sf_client.get_existing_locks()\n\nprint('lock,pid,node,operation')\nfor ref, meta in locks.items():\n    print('%s,%s,%s,%s' % (ref, meta['pid'], meta['node'], meta.get('operation')))\n</code></pre> <pre><code>$ python3 example.py\nlock,pid,node,operation\n/sflocks/sf/network/d2950d74-50c7-4790-a985-c43d9eb9bad9,2834066,sf-3,Network ensure mesh\n</code></pre>"},{"location":"developer_guide/api_reference/artifacts/","title":"Artifacts (/artifacts/)","text":"<p>The general usage of artifacts is documented in the user guide. This page documents the API flow interacting with artifacts, as well as the multi-step process involved with uploading or downloading an artifact.</p>"},{"location":"developer_guide/api_reference/artifacts/#fetching-a-remote-url-as-an-image-artifact","title":"Fetching a remote URL as an image artifact","text":"<p>As discussed in the user guide, remote URLs can be stored within a Shaken Fist cluster as artifacts of type image. These artifacts are often used as the template for disks attached to instances and are the equivalent to AWS AMIs or OpenStack images in Glance.</p> REST API calls <ul> <li>POST /artifacts: Fetch an image artifact into the cluster.</li> </ul> Python API client: cache an artifact <p>Note this API call is asynchronous and therefore returns immediately. Use artifact version information and events to determine if a new version was fetched and if that fetch is complete.</p> <pre><code>from shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nsf_client.cache_artifact('https://images.shakenfist.com/debian:11/latest.qcow2')\n</code></pre>"},{"location":"developer_guide/api_reference/artifacts/#fetching-information-about-an-artifact","title":"Fetching information about an artifact","text":"<p>As expected, you can use a GET REST API call to fetch information about all artifacts in a namespace, or a specific artifact for more detailed information. Artifacts also track \"events\" (see the user guide for a general introduction to the Shaken Fist event system).</p> REST API calls <ul> <li>GET /artifacts: List artifacts for a namespace.</li> <li>GET /artifacts/{artifact_ref}: Get information about a specific artifact.</li> <li>GET /artifacts/{artifact_ref}/events: Fetch events for a specific artifact.</li> </ul> Python API client: list artifacts <p>Note this API call is asynchronous and therefore returns immediately. Use artifact version information and events to determine if a new version was fetched and if that fetch is complete.</p> <pre><code>from shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nartifacts = sf_client.get_artifacts()\n\nprint('uuid,namespace,type,source_url,versions,state,shared')\nfor meta in artifacts:\n    versions = '%d of %d' % (len(meta.get('blobs', [])),\n                             meta.get('index', 'unknown'))\n    print('%s,%s,%s,%s,%s,%s,%s' % (\n          meta.get('uuid', ''), meta.get('namespace', ''),\n          meta.get('artifact_type', ''),\n          meta.get('source_url', ''), versions,\n          meta.get('state', ''), meta.get('shared', False)))\n</code></pre> <pre><code>$ python3 example.py\nuuid,namespace,type,source_url,versions,state,shared\n05e841a7-7e13-4df6-8c04-8932b98885bd,system,image,sf://upload/system/centos-9-stream,1 of 1,created,False\n1646bc22-674b-4a46-97e5-f767a6e82d1c,system,image,debian:11,3 of 9,created,False\n...\n</code></pre> Python API client: get information about a specific artifact <pre><code>import json\nfrom shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nartifact = sf_client.get_artifact('05e841a7-7e13-4df6-8c04-8932b98885bd')\nprint(json.dumps(artifact, indent=4, sort_keys=True))\n</code></pre> <pre><code>$ python3 example.py\n{\n    \"artifact_type\": \"image\",\n    \"blob_uuid\": \"8fa321aa-1e05-43c9-ade1-36d45940d6bd\",\n    \"blobs\": {\n        \"1\": {\n            \"depends_on\": null,\n            \"instances\": [],\n            \"reference_count\": 2,\n            \"size\": 960546304,\n            \"uuid\": \"8fa321aa-1e05-43c9-ade1-36d45940d6bd\"\n        }\n    },\n    \"index\": 1,\n    \"max_versions\": 3,\n    \"metadata\": {},\n    \"namespace\": \"system\",\n    \"shared\": false,\n    \"source_url\": \"sf://upload/system/centos-9-stream\",\n    \"state\": \"created\",\n    \"uuid\": \"05e841a7-7e13-4df6-8c04-8932b98885bd\",\n    \"version\": 6\n}\n</code></pre> Python API client: list events for an artifact <pre><code>import json\nfrom shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nevents = sf_client.get_artifact_events('05e841a7-7e13-4df6-8c04-8932b98885bd')\nprint(json.dumps(events, indent=4, sort_keys=True))\n</code></pre> <p>Note that events are returned in reverse chronological order and are limited to the 100 most recent events.</p> <pre><code>$ python3 example.py\n[\n    ...\n    {\n        \"duration\": null,\n        \"extra\": {},\n        \"fqdn\": \"sf-3\",\n        \"message\": \"artifact fetch complete\",\n        \"timestamp\": 1684718452.2673004,\n        \"type\": \"audit\"\n    },\n    ...\n]\n</code></pre>"},{"location":"developer_guide/api_reference/artifacts/#deleting-artifacts","title":"Deleting artifacts","text":"<p>Artifacts may be deleted individually, or an entire namespace at a time.</p> REST API calls <ul> <li>DELETE /artifacts: Delete all artifacts within a specific namespace.</li> <li>DELETE /artifacts/{artifact_ref}: Delete a specific artifact.</li> </ul> Python API client: delete a single artifact <pre><code>from shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nsf_client.delete_artifact('05e841a7-7e13-4df6-8c04-8932b98885bd')\n</code></pre> Python API client: delete all artifacts in a namespace <pre><code>from shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nsf_client.delete_all_artifacts('mynamespace')\n</code></pre>"},{"location":"developer_guide/api_reference/artifacts/#uploads","title":"Uploads","text":"<p>Artifact uploads normally require multiple HTTP requests in order to complete. This is because artifacts are often very large, and the REST API wants to allow you to continue an upload even if a single HTTP session fails or times out. This is implemented by creating an upload object, POSTing data to that object repeatedly, and then converting that upload object to an artifact.</p> <p>Upload objects which have not have data posted to them in a long time (currently 24 hours) are automatically removed.</p> <p>You create an upload by POST'ing to <code>/upload</code>. This will create a new upload object and return you a JSON representation of that object. The JSON includes the UUID, node the upload is stored on, and when it was created.</p> <p>Then repeatedly POST binary data to <code>/upload/...uuid...</code>. This binary data is blindly appended to your upload object. Do not encode the data with base64 or similar. Each call will return the new size of the object.</p> <p>If necessary, you can also truncate an upload object to a specified size, for example if you are unsure that a POST operation completed correctly. You do this by sending a POST to <code>/upload/...uuid.../truncate/...desired.length...</code>.</p> <p>Once your upload is complete, you convert it to an artifact by calling <code>/artifacts/upload/...name...</code> to convert it to an artifact.</p> <p>There is one final optimization to uploads, which is implemented in the python API and command line clients. If before upload you calculate a sha512 of the object to be uploaded, you can then search for that checksum with the <code>/blob_checksums/sha512/...hash...</code> endpoint. If a blob is returned then you don't need to actually upload and can instead pass that blob uuid (with a POST argument named <code>blob_uuid</code>) instead of an upload uuid to the <code>/artifacts/upload/...name...</code> endpoint. See the swagger documentation for more details.</p> REST API calls <ul> <li>POST /upload: Create a new upload.</li> <li>POST /upload/{upload_uuid}: Append a new chunk to an already existing upload.</li> <li>POST /upload/{upload_uuid}/truncate: Truncate an upload to a specific index. This can be useful as a retry operation in the case of a transmission error.</li> <li>GET /artifacts: List artifacts.</li> <li>POST /artifacts/upload/{artifact_name}: Convert a completed upload into an artifact.</li> </ul> Python API client: create an upload, transfer data, and convert to an artifact <pre><code>from shakenfist_client import apiclient\nimport time\n\nsf_client = apiclient.Client()\nupload = sf_client.create_upload()\n\nbuffer_size = 4096\ntotal = 0\nretries = 0\nwith open('/tmp/input', 'rb') as f:\n    d = f.read(buffer_size)\n    while d:\n        start_time = time.time()\n        try:\n            remote_total = sf_client.send_upload(upload['uuid'], d)\n            retries = 0\n        except apiclient.APIException as e:\n            retries += 1\n\n            if retries &gt; 5:\n                print('Repeated failures, aborting')\n                raise e\n\n            print('Upload error, retrying...')\n            sf_client.truncate_upload(upload['uuid'], total)\n            f.seek(total)\n            buffer_size = 4096\n            d = f.read(buffer_size)\n            continue\n\n        # We aim for each chunk to take three seconds to transfer. This is\n        # partially because of the API timeout on the other end, but also\n        # so that uploads don't appear to stall over very slow networks.\n        # However, the buffer size must also always be between 4kb and 4mb.\n        elapsed = time.time() - start_time\n        buffer_size = int(buffer_size * 3.0 / elapsed)\n        buffer_size = max(4 * 1024, buffer_size)\n        buffer_size = min(2 * 1024 * 1024, buffer_size)\n\n        sent = len(d)\n        total += sent\n\n        if total != remote_total:\n            print('Remote side has %d, we have sent %d!'\n                  % (remote_total, total))\n            sys.exit(1)\n\n        d = f.read(buffer_size)\n\n    print('Creating artifact')\n    artifact = sf_client.upload_artifact('example', upload['uuid'])\n    print('Created artifact %s' % artifact['uuid'])\n</code></pre> <pre><code>$ python3 example.py\nCreating artifact\nCreated artifact 2d9c1d4c-3436-4ea8-9b60-833fe791eece\n$ sf-client artifact show 2d9c1d4c-3436-4ea8-9b60-833fe791eece\nuuid                     : 2d9c1d4c-3436-4ea8-9b60-833fe791eece\nnamespace                : system\ntype                     : image\nstate                    : created\nsource url               : sf://upload/system/example\ncurrent version blob uuid: 36e846f6-ae20-46e9-8377-1c123f22b610\nnumber of versions       : 1\nmaximum versions         : 3\nshared                   : False\n\nVersions:\n    1  : blob 36e846f6-ae20-46e9-8377-1c123f22b610 is 1.3MB\n$ sf-client artifact delete 2d9c1d4c-3436-4ea8-9b60-833fe791eece\n</code></pre>"},{"location":"developer_guide/api_reference/artifacts/#using-an-already-existing-blob-as-a-new-version-of-an-artifact","title":"Using an already existing blob as a new version of an artifact","text":"<p>Label artifacts are effectively a sequence of already existing blobs which have been categorized in some manner. For example, you might have a CI system producing golden images for a system, but then use a label artifact to indicate the most recent version of the golden image which has passed acceptance testing. You therefore can apply an existing blob (the version of the golden image you tested in our example), to an artifact as a new version.</p>"},{"location":"developer_guide/api_reference/artifacts/#removing-a-specific-version-from-an-artifact","title":"Removing a specific version from an artifact","text":"<p>It is also possible that a bad version of an artifact exists -- possibly because the system that creates the new versions experienced an error. You can therefore remove a specific version of an artifact as well.</p> REST API calls <ul> <li>DELETE /artifacts/{artifact_ref}/versions/{version_id}: Remove a specified version from an artifact.</li> </ul> Python API client: delete a specific version of an artifact <pre><code>from shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nsf_client.delete_artifact_version('2d9c1d4c-3436-4ea8-9b60-833fe791eece', 1)\n</code></pre>"},{"location":"developer_guide/api_reference/artifacts/#setting-the-maximum-number-of-versions-of-an-artifact","title":"Setting the maximum number of versions of an artifact","text":"<p>You can configure the number of versions a given artifact will store. The default value is the ARTIFACT_MAX_VERSIONS_DEFAULT configuration variable, but that may be overridden on a per-artifact basis.</p> REST API calls <ul> <li>POST /artifacts/{artifact_ref}/versions: Set the maximum number of versions of an artifact to store.</li> </ul> Python API client: delete a specific version of an artifact <pre><code>from shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nsf_client.set_artifact_max_versions('2d9c1d4c-3436-4ea8-9b60-833fe791eece', 7)\n</code></pre>"},{"location":"developer_guide/api_reference/artifacts/#downloads","title":"Downloads","text":"<p>Artifact downloads are implemented as fetching the data for the desired blob. You therefore must first lookup the versions for a given artifact and select a version that you wish to download. You can then fetch the data for the relevant blob by calling <code>/blobs/...uuid.../data</code> this call takes an optional query parameter of <code>offset</code>, which specifies how many bytes into the blob to start returning data from. This allows recommencing failed downloads.</p> REST API calls <ul> <li>GET /artifacts/{artifact_ref}/versions: List version blobs for a given artifact.</li> </ul> Python API client: list versions of an artifact <pre><code>import json\nfrom shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nvers = sf_client.get_artifact_versions('2d9c1d4c-3436-4ea8-9b60-833fe791eece')\nprint(json.dumps(vers, indent=4, sort_keys=True))\n</code></pre>"},{"location":"developer_guide/api_reference/artifacts/#sharing-and-unsharing","title":"Sharing and unsharing","text":"<p>As described in the operator guide, artifacts in the system namespace can be shared with all other namespaces. This is desirable for commonly used \"official\" images which many users will want to use.</p> REST API calls <ul> <li>POST /artifacts/{artifact_ref}/share: Share an artifact.</li> <li>POST /artifacts/{artifact_ref}/unshare: Unshare an artifact.</li> </ul> Python API client: share an artifact <pre><code>from shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nsf_client.share_artifact('2d9c1d4c-3436-4ea8-9b60-833fe791eece')\n</code></pre> Python API client: unshare an artifact <pre><code>from shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nsf_client.unshare_artifact('2d9c1d4c-3436-4ea8-9b60-833fe791eece')\n</code></pre>"},{"location":"developer_guide/api_reference/artifacts/#metadata","title":"Metadata","text":"<p>All objects exposed by the REST API may have metadata associated with them. This metadata is for storing values that are of interest to the owner of the resources, not Shaken Fist. Shaken Fist does not attempt to interpret these values at all, with the exception of the instance affinity metadata values. The metadata store is in the form of a key value store, and a general introduction is available in the user guide.</p> REST API calls <ul> <li>GET \u200b/artifacts\u200b/{artifact_ref}\u200b/metadata: Get metadata for an artifact.</li> <li>POST /artifacts/{artifact_ref}/metadata: Create a new metadata key for an artifact.</li> <li>DELETE /artifacts/{artifact_ref}/metadata/{key}: Delete a specific metadata key for an artifact.</li> <li>PUT /artifacts/{artifact_ref}/metadata/{key}: Update an existing metadata key for an artifact.</li> </ul> Python API client: set metadata on an artifact <pre><code>from shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nsf_client.set_artifact_metadata_item(img_uuid, 'foo', 'bar')\n</code></pre> Python API client: get metadata for an artifact <pre><code>import json\nfrom shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nmd = sf_client.get_artifact_metadata(img_uuid)\nprint(json.dumps(md, indent=4, sort_keys=True))\n</code></pre> Python API client: delete metadata for an artifact <pre><code>import json\nfrom shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nsf_client.delete_artifact_metadata_item(img_uuid, 'foo')\n</code></pre>"},{"location":"developer_guide/api_reference/authentication/","title":"Authentication (/auth/)","text":""},{"location":"developer_guide/api_reference/authentication/#create-an-api-access-token","title":"Create an API access token","text":"<p>Access to the REST API is granted via an access token. These tokens expire, so you may also have to request new tokens for long lived applications from time to time. You will receive a HTTP 401 status code if an access token has expired.</p> <p>For further details of the authentication scheme, see the developer guide.</p> REST API calls <ul> <li>POST /auth: Create an access token.</li> </ul> Python API client: creating an access token <p>The Python API client handles creating access tokens and refreshing them for you, so not specific action is required for this API call. The following code implies creation of an access token:</p> <pre><code>from shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\n</code></pre> curl: creating an access token <pre><code>curl -X POST https://shakenfist/api/auth -d '{\"namespace\": \"system\", \"key\": \"oisoSe7T\"}'\n{\n    \"access_token\": \"eyJhbG...IkpXVCJ9.eyJmc...wwQ\",\n    \"token_type\": \"Bearer\",\n    \"expires_in\": 900\n}\n</code></pre> <p>This token is then used by passing it as a HTTP Authorization header with \"Bearer \" prepended:</p> <pre><code>curl -X GET https://shakenfist/api/auth/namespaces \\\n    -H 'Authorization: Bearer eyJhbG...IkpXVCJ9.eyJmc...wwQ' \\\n    -H 'Content-Type: application/json'\n[\n    {\n        \"name\": \"adhoc\",\n        \"state\": \"created\",\n        \"trust\": {\"full\": [\"system\"]}\n    }, {\n        \"name\": \"ci\",\n        \"state\": \"created\",\n        \"trust\": {\"full\": [\"system\"]}\n    }, {\n        \"name\": \"system\",\n        \"state\": \"created\",\n        \"trust\": {\"full\": [\"system\"]}\n    }\n]\n</code></pre>"},{"location":"developer_guide/api_reference/authentication/#namespaces","title":"Namespaces","text":"<p>Resources in a Shaken Fist cluster are divided up into logical groupings called namespaces. All namespaces have equal permissions, except for the <code>system</code> namespace, which is used for administrative tasks.</p> REST API calls <ul> <li>GET /auth/namespaces: List all namespaces visible to your currently authenticated namespace.</li> <li>POST /auth/namespaces: Create a namespace, if you have permissions to do so.</li> <li>DELETE /auth/namespaces/{namespace}: Delete a namespace.</li> <li>GET /auth/namespaces/{namespace}: Get details of a single namespace.</li> </ul> Python API client: list namespaces <p>This example lists all namespaces visible to the caller:</p> <pre><code>import json\nfrom shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nns = sf_client.get_namespaces()\nprint(json.dumps(ns, indent=4, sort_keys=True))\n</code></pre> <p>Which returns something like:</p> <pre><code>$ python3 example.py\n[\n    {\n        \"keys\": [\n            \"jenkins\"\n        ],\n        \"metadata\": {},\n        \"name\": \"ci\",\n        \"state\": \"created\",\n        \"trust\": {\n            \"full\": [\n                \"system\"\n            ]\n        },\n        \"version\": 5\n    },\n    ...\n]\n</code></pre> Python API client: create a namespace <p>This example creates a new namespace, which is only possible if you are currently authenticated as the <code>system</code> namespace:</p> <pre><code>import json\nfrom shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nns = sf_client.create_namespace('demo')\nprint(json.dumps(ns, indent=4, sort_keys=True))\n</code></pre> <p>Which returns something like:</p> <pre><code>$ python3 example.py\n{\n    \"keys\": [],\n    \"metadata\": {},\n    \"name\": \"demo\",\n    \"state\": \"created\",\n    \"trust\": {\n        \"full\": [\n            \"system\"\n        ]\n    },\n    \"version\": 5\n}\n</code></pre> Python API client: delete a namespace <p>This example deletes a namespace, which is only possible if you are currently authenticated as the <code>system</code> namespace:</p> <pre><code>import json\nfrom shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nns = sf_client.delete_namespace('demo')\nprint(json.dumps(ns, indent=4, sort_keys=True))\n</code></pre> <p>The call does not return anything.</p> Python API client: get details of a single namespace <pre><code>import json\nfrom shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nns = sf_client.get_namespace('demo')\nprint(json.dumps(ns, indent=4, sort_keys=True))\n</code></pre> <p>Which returns something like:</p> <pre><code>$ python3 example.py\n{\n    \"keys\": [],\n    \"metadata\": {},\n    \"name\": \"demo\",\n    \"state\": \"created\",\n    \"trust\": {\n        \"full\": [\n            \"system\"\n        ]\n    },\n    \"version\": 5\n}\n</code></pre>"},{"location":"developer_guide/api_reference/authentication/#namespace-keys","title":"Namespace keys","text":"<p>Callers authenticate to a namespace by providing a key to a call to <code>/auth/</code> as discussed above. The calls discussed in this section relate to the management of the keys used to authenticate to a namespace.</p> REST API calls <ul> <li>GET /auth/namespaces/{namespace}/keys: List all authentication keys for a given namespace.</li> <li>POST /auth/namespaces/{namespace}/keys: Create a new key for a namespace.</li> <li>DELETE /auth/namespaces/{namespace}/keys/{key_name}: Delete a specific key for a namespace.</li> <li>PUT /auth/namespaces/{namespace}/keys/{key_name}: Update a key for a namespace.</li> </ul> Python API client: list all keys for a namespace <p>This example lists all the keys in a namespace:</p> <pre><code>from shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nkeys = sf_client.get_namespace_keynames('ci')\nprint(keys)\n</code></pre> <p>Which returns something like:</p> <pre><code>$ python3 example.py\n['jenkins']\n</code></pre> Python API client: create a new key for a namespace <p>This example adds a key to a namespace and then lists all keys:</p> <pre><code>from shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nsf_client.add_namespace_key('ci', 'newkey', 'thesecretvalue')\n\n# Fetch the list of keys to make sure the new one exists\nkeys = sf_client.get_namespace_keynames('ci')\nprint(keys)\n</code></pre> <p>Which returns something like:</p> <pre><code>$ python3 example.py\n['jenkins', 'newkey']\n</code></pre> Python API client: remove a specific key from a namespace <p>This example deletes a key from the namespace and then lists all keys:</p> <pre><code>from shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nsf_client.delete_namespace_key('ci', 'newkey')\n\n# Fetch the list of keys to make sure the new one exists\nkeys = sf_client.get_namespace_keynames('ci')\nprint(keys)\n</code></pre> <p>Which returns something like:</p> <pre><code>$ python3 example.py\n['jenkins']\n</code></pre> Python API client: update the secret portion of an existing namespace key <p>This example updates the secret portion of an existing namespace key to a new value:</p> <pre><code>from shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nsf_client.update_namespace_key('ci', 'newkey', 'newsecret')\n</code></pre>"},{"location":"developer_guide/api_reference/authentication/#metadata","title":"Metadata","text":"<p>All objects exposed by the REST API may have metadata associated with them. This metadata is for storing values that are of interest to the owner of the resources, not Shaken Fist. Shaken Fist does not attempt to interpret these values at all, with the exception of the instance affinity metadata values. The metadata store is in the form of a key value store, and a general introduction is available in the user guide.</p> REST API calls <ul> <li>GET \u200b/namespaces/{namespace}\u200b/metadata: Get metadata for a namespace.</li> <li>POST /namespaces/{namespace}/metadata: Create a new metadata key for a namespace.</li> <li>DELETE /namespaces/{namespace}/metadata/{key}: Delete a specific metadata key for a namespace.</li> <li>PUT /namespaces/{namespace}/metadata/{key}: Update an existing metadata key for a namespace.</li> </ul> Python API client: set metadata on a namespace <pre><code>from shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nsf_client.set_artifact_metadata_item(img_uuid, 'foo', 'bar')\n</code></pre> Python API client: get metadata for a namespace <pre><code>import json\nfrom shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nmd = sf_client.get_artifact_metadata(img_uuid)\nprint(json.dumps(md, indent=4, sort_keys=True))\n</code></pre> Python API client: delete metadata for a namespace <pre><code>import json\nfrom shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nsf_client.delete_artifact_metadata_item(img_uuid, 'foo')\n</code></pre>"},{"location":"developer_guide/api_reference/blob_checksums/","title":"Blob Checksums (/blob_checksums/)","text":"<p>Blob checkums are documented as part of blobs.</p>"},{"location":"developer_guide/api_reference/blobs/","title":"Blobs (/blobs/)","text":"<p>In general you interact with blobs as attributes of other objects -- blobs being the most obvious example. However, there is limited support in the REST API for interacting directly with blobs as well. Blobs are also considered a special case in that they are not namespaced like most other objects. That is, possession of the UUID of a blob is considered evidence that you should have access to it. This is because blobs can be shared between objects if the data for those objects is currently the identical. This is also why only administrators can list all blobs in a given Shaken Fist cluster.</p>"},{"location":"developer_guide/api_reference/blobs/#fetching-information-about-a-blob","title":"Fetching information about a blob","text":"<p>If you know the UUID of a blob, then you can GET information about that blob from the REST API, as well as fetching the actual data the blob is storing as well.</p> REST API calls <ul> <li>GET /blobs: List all blobs in a cluster. You must be an administrator to make this call.</li> <li>GET /blobs/{blob_uuid}: Get information about a specific blob.</li> <li>GET /blobs/{blob_uuid}/data: Get the stored data for a specific blob.</li> <li>GET /blob_checksums/sha512/{hash}: Find a blob with this hash.</li> </ul> Python API client: get a specific blob <pre><code>import json\nfrom shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nb = sf_client.get_blob('578da8b6-eb98-4e10-bb36-e4d4d763d312')\nprint(json.dumps(b, indent=4, sort_keys=True))\n</code></pre> Python API client: download the data for a specific blob <p>This example requires retry logic to handle the HTTP connection dropping while transferring large files.</p> <pre><code>import http\nfrom shakenfist_client import apiclient\nimport requests\nimport sys\nimport urllib3\n\nsf_client = apiclient.Client()\n\ntotal = 0\nconnection_failures = 0\ndone = False\n\nwith open('output', 'wb') as f:\n    while not done:\n        bytes_in_attempt = 0\n\n        try:\n            for chunk in sf_client.get_blob_data(\n                    '578da8b6-eb98-4e10-bb36-e4d4d763d312', offset=total):\n                received = len(chunk)\n                f.write(chunk)\n                bytes_in_attempt += received\n                total += received\n\n            done = True\n\n        except urllib3.exceptions.NewConnectionError as e:\n            connection_failures += 1\n            if connection_failures &gt; 2:\n                print('HTTP connection repeatedly failed: %s' % e)\n                sys.exit(1)\n\n        except (ConnectionResetError, http.client.IncompleteRead,\n                urllib3.exceptions.ProtocolError,\n                requests.exceptions.ChunkedEncodingError) as e:\n            # An API error (or timeout) occurred. Retry unless we got nothing.\n            if bytes_in_attempt == 0:\n                print('HTTP connection dropped without transferring data: %s' % e)\n                sys.exit(1)\n</code></pre> Python API client: search for a blob by sha512 hash <p>Note that this call is not supported by older versions of the Shaken Fist REST API.</p> <pre><code>import hashlib\nimport json\nfrom shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nif not sf_client.check_capability('blob-search-by-hash'):\n    print('Searching by hash is not supported')\nelse:\n    sha512_hash = hashlib.sha512()\n    with open('input', 'rb') as f:\n        d = f.read(4096)\n        while d:\n            sha512_hash.update(d)\n            d = f.read(4096)\n\n    print('Searching for a pre-existing blob with this hash...')\n    b = sf_client.get_blob_by_sha512(sha512_hash.hexdigest())\n    if not b:\n        print('No matching blob found')\n    else:\n        print('Blob %s is a match' % b['uuid'])\n</code></pre>"},{"location":"developer_guide/api_reference/blobs/#metadata","title":"Metadata","text":"<p>All objects exposed by the REST API may have metadata associated with them. This metadata is for storing values that are of interest to the owner of the resources, not Shaken Fist. Shaken Fist does not attempt to interpret these values at all, with the exception of the instance affinity metadata values. The metadata store is in the form of a key value store, and a general introduction is available in the user guide.</p> REST API calls <ul> <li>GET \u200b/blobs\u200b/{blob_uuid}\u200b/metadata: Get metadata for a blob.</li> <li>POST /blobs/{blob_uuid}/metadata: Create a new metadata key for a blob.</li> <li>DELETE /blobs/{blob_uuid}/metadata/{key}: Delete a specific metadata key for a blob.</li> <li>PUT /blobs/{blob_uuid}/metadata/{key}: Update an existing metadata key for a blob.</li> </ul> Python API client: set metadata on a blob <pre><code>from shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nsf_client.set_blob_metadata_item(blob_uuid, 'foo', 'bar')\n</code></pre> Python API client: get metadata for a blob <pre><code>import json\nfrom shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nmd = sf_client.get_blob_metadata(blob_uuid)\nprint(json.dumps(md, indent=4, sort_keys=True))\n</code></pre> Python API client: delete metadata for a blob <pre><code>import json\nfrom shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nsf_client.delete_blob_metadata_item(blob_uuid, 'foo')\n</code></pre>"},{"location":"developer_guide/api_reference/instances/","title":"Instances (/instances/)","text":"<p>Instances sit at the core of Shaken Fist's functionality, and are the component which ties most of the other concepts in the API together. Therefore, they are also the most complicated part of Shaken Fist to explain. This description is broken into basic functionality -- showing information about instances -- and then moves onto more advanced topics like creation, deletion, and other lifecycle events.</p>"},{"location":"developer_guide/api_reference/instances/#fetching-information-about-an-instance","title":"Fetching information about an instance","text":"<p>There are two main ways to fetch information about instances -- you can list all instances visible to your authenticated namespace, or you can collect information about a specific instance by providing its UUID or name.</p> Info <p>Note that the amount of information visible in an instance response will change over the lifecycle of the instance -- for example when you first request the instance be created versus when the instance has had its disk specification calculated.</p> REST API calls <ul> <li>GET /instances: List all instances visible to your authenticated namespace.</li> <li>GET /instances/{instance_ref}: Get information about a specific instance.</li> </ul> Python API client: get all visible instances <pre><code>import json\nfrom shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\ninstances = sf_client.get_instances()\nprint(json.dumps(instances, indent=4, sort_keys=True))\n</code></pre> Python API client: get information about a specific instance <pre><code>import json\nfrom shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\ni = sf_client.get_instance('317e9b70-8e26-46af-a1c4-76931c0da5a9')\nprint(json.dumps(i, indent=4, sort_keys=True))\n</code></pre>"},{"location":"developer_guide/api_reference/instances/#instance-creation","title":"Instance creation","text":"<p>Instance creation is by far the most complicated call in Shaken Fist in terms of the arguments that it takes. The code in the Python command line client is helpful if you need a fully worked example of every possible permutation. The OpenAPI documentation at https://sfcbr.shakenfist.com/api/apidocs/#/instances/post_instances provides comprehensive and up to date documentation on all the arguments to the creation call.</p> <p>The instance creation API call also takes three data structures: the <code>diskspec</code>; the <code>networkspec</code>; and the <code>videospec</code>. These structures are not well documented in the OpenAPI interface, so are documented here instead.</p>"},{"location":"developer_guide/api_reference/instances/#diskspec","title":"diskspec","text":"<p>A <code>diskspec</code> consists of the following fields as a JSON dictionary:</p> <ul> <li>size (integer): the size of the disk in gigabytes.</li> <li>base (string): the base image for the disk. This can be a variety of URL-like strings,   as documented on the artifacts page in the user guide.   For a blank disk, omit this value.</li> <li>bus (enum): the hardware bus the disk device should be attached to on the instance.   In general you shouldn't care about this and can omit this value. However, in   some cases, such as unmodified Microsoft Windows images it is required. The options   available here are: ide; sata; scsi; usb; virtio (the default); and nvme.</li> <li>type (enum): the type of device. The default is \"disk\", but in some cases you might   want \"cdrom\".</li> </ul> <p>A full example of a <code>diskspec</code> is therefore:</p> <pre><code>{\n    'size': 20,\n    'base': 'debian:11',\n    'bus': None,\n    'type': None\n}\n</code></pre>"},{"location":"developer_guide/api_reference/instances/#networkspec","title":"networkspec","text":"<p>Similarly, a <code>networkspec</code> consists of the following fields in a JSON dictionary:</p> <ul> <li>network_uuid (uuid): the UUID of the network the interface should exist on.</li> <li>macaddress (string): the MAC address of the interface. Omit this value to be allocated   a MAC address automatically.</li> <li>model (enum): the model of the network interface card. In general you should not have   to set this, although it can matter in some cases, such as unmodified Microsoft   Windows images. The options include: i82551; i82557b; i82559er; ne2k_pci; pcnet;   rtl8139; e1000; and virtio (the default).</li> <li>float (boolean): whether to associate a floating IP with this interface to enable external   accessibility to the instance. Note that you can float and unfloat an interface   after instance creation if desired.</li> </ul>"},{"location":"developer_guide/api_reference/instances/#videospec","title":"videospec","text":"<p>A <code>videospec</code> differs from a <code>diskspec</code> and a <code>networkspec</code> in that it is not passed as a list. You only have one <code>videospec</code> per instance. Once again, a <code>videospec</code> is a JSON dictionary with the following fields:</p> <ul> <li>model (enum): the model of the video card to attach to the instance. Possible   options include: vga; cirrus (the default); and qxl.</li> <li>memory (integer): the amount of video RAM the video card should have, in   kibibytes (blocks of 1024 bytes).</li> </ul> REST API calls <ul> <li>POST /instances/: Create an instance.</li> </ul> Python API client: create and then delete a simple instance <pre><code>from shakenfist_client import apiclient\nimport time\n\nsf_client = apiclient.Client()\ni = sf_client.create_instance(\n    'example', 1, 1024, None,\n    [{\n        'size': 20,\n        'base': 'debian:11',\n        'bus': None,\n        'type': 'disk'\n    }],\n    None, None)\n\ntime.sleep(30)\n\ni = sf_client.delete_instance(i['uuid'])\n</code></pre>"},{"location":"developer_guide/api_reference/instances/#other-instance-lifecycle-operations","title":"Other instance lifecycle operations","text":"<p>A variety of other lifecycle operations are available on instances, including deletion, and power management.</p> <p>The power management actions available are:</p> <ul> <li>soft reboot: gracefully request a reboot from the instance operating system   via ACPI. This is not guaranteed to actually work, but if it does is much less   likely to cause disk corruption on the instance.</li> <li>hard reboot: the equivalent of holding the reset switch down on a physical machine   until it reboots without operating system involvement.</li> <li>power on: turn the instance on, as if the power switch was pressed.</li> <li>power off: turn the instance immediately off, as if the power switch was held   down on a physical machine.</li> <li>pause: suspend execution of the instance, but leave it hot in RAM ready to   restart.</li> <li>unpause: unsuspend execution of the instance.</li> </ul> REST API calls <ul> <li>DELETE /instances/{instance_ref}: Delete an instance.</li> <li>DELETE /instances/: Delete all instances in a namespace.</li> <li>POST \u200b/instances\u200b/{instance_ref}\u200b/rebootsoft: Soft (ACPI) reboot the instance.</li> <li>POST \u200b/instances\u200b/{instance_ref}\u200b/reboothard: Hard (reset switch) reboot the instance.</li> <li>POST /instances/{instance_ref}/poweron: Power the instance on.</li> <li>POST /instances/{instance_ref}/poweroff: Power the instance off, as if holding the power switch down.</li> <li>POST /instances/{instance_ref}/pause: Pause an instance.</li> <li>POST /instances/{instance_ref}/unpause: Unpause an instance.</li> </ul> Python API client: create and then delete a simple instance <pre><code>from shakenfist_client import apiclient\nimport time\n\nsf_client = apiclient.Client()\ni = sf_client.create_instance(\n    'example', 1, 1024, None,\n    [{\n        'size': 20,\n        'base': 'debian:11',\n        'bus': None,\n        'type': 'disk'\n    }],\n    None, None)\n\ntime.sleep(30)\n\ni = sf_client.delete_instance(i['uuid'])\n</code></pre> Python API client: attempt a soft reboot, and hard reboot if required <p>Note that this example assumes the instance is running an image with the Shaken Fist in guest agent installed.</p> <pre><code>import time\nfrom shakenfist_client import apiclient\nimport sys\n\nsf_client = apiclient.Client()\ni = sf_client.create_instance(\n    'example', 1, 1024, None,\n    [{\n        'size': 20,\n        'base': 'debian:11',\n        'bus': None,\n        'type': 'disk'\n    }],\n    None, None, side_channels=['sf-agent'])\n\n# Wait for the instance to be created, or error out. Use instance events to\n# provide status updates during boot.\nwhile i['state'] not in ['created', 'error']:\n    events = sf_client.get_instance_events(i['uuid'])\n    print('Waiting for the instance to start: %s' % events[0]['message'])\n    time.sleep(5)\n    i = sf_client.get_instance(i['uuid'])\n\n# Check the instance is created correctly\nif i['state'] != 'created':\n    print('Instance is not in a created state!')\n    sys.exit(1)\nprint('Instance is created')\n\n# Wait for the agent to report the reboot time\nwhile not i['agent_system_boot_time']:\n    print('Waiting for agent to start: %s' % i['agent_state'])\n    time.sleep(20)\n    i = sf_client.get_instance(i['uuid'])\n\ninitial_boot = i['agent_system_boot_time']\nprint('Instance booted at %d' % initial_boot)\n\n# Now try to soft reboot the instance, wait up to 60 seconds for a reboot to\n# be detected\nsf_client.reboot_instance(i['uuid'], hard=False)\nprint('Soft rebooting instance')\ntime.sleep(60)\ni = sf_client.get_instance(i['uuid'])\n\n# Wait for the agent to report the reboot time again\nwhile not i['agent_system_boot_time']:\n    print('Waiting for agent to start: %s' % i['agent_state'])\n    time.sleep(20)\n    i = sf_client.get_instance(i['uuid'])\n\nif i['agent_system_boot_time'] != initial_boot:\n    print('Boot time changed from %d to %s'\n        % (initial_boot, i['agent_system_boot_time']))\n\nelse:\n    # We failed to soft reboot, let's hard reboot instead\n    sf_client.reboot_instance(i['uuid'], hard=True)\n    print('Instance did not reboot, hard rebooting')\n</code></pre> <p>Sample output:</p> <pre><code>$ python3 example.py\nWaiting for the instance to start: schedule complete\nInstance is created\nWaiting for agent to start: not ready (no contact)\nWaiting for agent to start: not ready (no contact)\nWaiting for agent to start: not ready (no contact)\nInstance booted at 1684404969\nSoft rebooting instance\nBoot time changed from 1684404969 to 1684405036.0\n</code></pre> Python API client: power off and then on an instance <pre><code>import time\nfrom shakenfist_client import apiclient\nimport sys\n\nsf_client = apiclient.Client()\ni = sf_client.create_instance(\n        'example', 1, 1024, None,\n        [{\n            'size': 20,\n            'base': 'debian:11',\n            'bus': None,\n            'type': 'disk'\n        }],\n        None, None)\n\n# Wait for the instance to be created, or error out. Use instance events to\n# provide status updates during boot.\nwhile i['state'] not in ['created', 'error']:\n    events = sf_client.get_instance_events(i['uuid'])\n    print('Waiting for the instance to start: %s' % events[0]['message'])\n    time.sleep(5)\n    i = sf_client.get_instance(i['uuid'])\n\n# Check the instance is created correctly\nif i['state'] != 'created':\n    print('Instance is not in a created state!')\n    sys.exit(1)\nprint('Instance is created')\n\n# Check the instance is created correctly\nif i['power_state'] != 'on':\n    print('Instance is not in powered on state!')\n    sys.exit(1)\n\n# Power the instance off\nsf_client.power_off_instance(i['uuid'])\nwhile i['power_state'] != 'off':\n    print('Waiting for the instance to power off')\n    time.sleep(5)\n    i = sf_client.get_instance(i['uuid'])\n\ntime.sleep(30)\n\n# Power the instance on\nsf_client.power_on_instance(i['uuid'])\nwhile i['power_state'] != 'on':\n    print('Waiting for the instance to power on')\n    time.sleep(5)\n    i = sf_client.get_instance(i['uuid'])\n\nprint('Done')\n</code></pre> <pre><code>Waiting for the instance to start: set attribute\nInstance is created\nWaiting for the instance to power off\nWaiting for the instance to power on\nDone\n</code></pre> Python API client: pause and unpause an instance <pre><code>import time\nfrom shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nsf_client.pause_instance('foo')\n\ntime.sleep(30)\n\nsf_client.unpause_instance('foo')\n</code></pre>"},{"location":"developer_guide/api_reference/instances/#other-instance-information","title":"Other instance information","text":"<p>We can also request other information for an instance. For example, we can list the instance's network interfaces, or the events for the instance. See the user guide for a general introduction to the Shaken Fist event system.</p> REST API calls <ul> <li>GET /instances/{instance_ref}/interfaces: Request information on the instance's network interfaces, if any.</li> <li>GET /instances/{instance_ref}/events: Fetch events for a specific instance.</li> </ul> Python API client: list network interfaces for an instance <p>Note that the interface details for an instance wont be populated until the instance has started being created on the hypervisor node. Specifically, this can be some time later if an image needs to be fetched from the Internet and transcoded. Therefore in this example we wait for the instance to be created before displaying interface details.</p> <pre><code>import json\nfrom shakenfist_client import apiclient\nimport time\n\nsf_client = apiclient.Client()\ni = sf_client.create_instance(\n        'example', 1, 1024, None,\n        [{\n            'size': 20,\n            'base': 'debian:11',\n            'bus': None,\n            'type': 'disk'\n        }],\n        None, None)\n\n# Wait for the instance to be created, or error out. Use instance events to\n# provide status updates during boot.\nwhile i['state'] not in ['created', 'error']:\n    events = sf_client.get_instance_events(i['uuid'])\n    print('Waiting for the instance to start: %s' % events[0]['message'])\n    time.sleep(5)\n    i = sf_client.get_instance(i['uuid'])\n\n# Check the instance is created correctly\nif i['state'] != 'created':\n    print('Instance is not in a created state!')\n    sys.exit(1)\nprint('Instance is created')\n\n# Fetch and display interface details\nifaces = sf_client.get_instance_interfaces(i['uuid'])[0]\nprint(json.dumps(ifaces, indent=4, sort_keys=True))\n</code></pre> <pre><code>$ python3 example.py\nWaiting for the instance to start: Fetching required blob ffdfce7f-728e-4b76-83c2-304e252f98b1, 30% complete\nInstance is created\n[\n    {\n        \"floating\": null,\n        \"instance_uuid\": \"d512e9f5-98d6-4c36-8520-33b6fc6de15f\",\n        \"ipv4\": \"10.0.0.6\",\n        \"macaddr\": \"02:00:00:73:18:66\",\n        \"metadata\": {},\n        \"model\": \"virtio\",\n        \"network_uuid\": \"6aaaf243-0406-41a1-aa13-5d79a0b8672d\",\n        \"order\": 0,\n        \"state\": \"created\",\n        \"uuid\": \"b1981e81-b37a-4176-ba37-b61bc7208012\",\n        \"version\": 3\n    }\n]\n</code></pre> Python API client: list events for an instance <pre><code>import json\nfrom shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\ninterfaces = sf_client.get_instance_events('c0d52a77-0f8a-4f19-bec7-0c05efb03cb4')\nprint(json.dumps(interfaces, indent=4, sort_keys=True))\n</code></pre> <p>Note that events are returned in reverse chronological order and are limited to the 100 most recent events.</p> <pre><code>$python3 example.py\n[\n    ...\n    {\n        \"duration\": null,\n        \"extra\": {\n            \"cpu usage\": {\n                \"cpu time ns\": 357485828000,\n                \"system time ns\": 66297716000,\n                \"user time ns\": 291188112000\n            },\n            \"disk usage\": {\n                \"vda\": {\n                    \"actual bytes on disk\": 956301312,\n                    \"errors\": -1,\n                    \"read bytes\": 406776320,\n                    \"read requests\": 12225,\n                    \"write bytes\": 2105954304,\n                    \"write requests\": 3657\n                },\n                \"vdb\": {\n                    \"actual bytes on disk\": 102400,\n                    \"errors\": -1,\n                    \"read bytes\": 279552,\n                    \"read requests\": 74,\n                    \"write bytes\": 0,\n                    \"write requests\": 0\n                }\n            },\n            \"network usage\": {\n                \"02:00:00:1d:24:ae\": {\n                    \"read bytes\": 147084732,\n                    \"read drops\": 0,\n                    \"read errors\": 0,\n                    \"read packets\": 16484,\n                    \"write bytes\": 2166754,\n                    \"write drops\": 0,\n                    \"write errors\": 0,\n                    \"write packets\": 13144\n                }\n            }\n        },\n        \"fqdn\": \"sf-2\",\n        \"message\": \"usage\",\n        \"timestamp\": 1685229509.9592097,\n        \"type\": \"usage\"\n    },\n    ...\n]\n</code></pre>"},{"location":"developer_guide/api_reference/instances/#out-of-band-interactions-with-instances","title":"Out-of-band interactions with instances","text":"<p>Shaken Fist supports three types of instance consoles, which provide out-of-band management of instances -- that is, the instance does not need to have functioning networking for these consoles to work. You can read a general introduction of Shaken Fist's console functionality in the user guide. This page focuses on the API calls which are used to implement the console functionality in the Shaken Fist client.</p> <ul> <li>Read only console: to download the most recent portion of the read only text   serial console, or clear the console, use the   <code>/instances/{instance_ref}/consoledata</code> API calls below.</li> <li>Interactive serial console: lookup the console port from the instance details   fetch (as described above), and then connect to that port on the hypervisor   node with a TCP client such as telnet.</li> <li>Interactive VDI console: lookup the VDI console port from the instance details   fetch (as described above), and then connect to that port on the hypervisor   with the correct client (currently one of VNC or SPICE). Alternatively, use   the <code>/instances/{instance_ref}/vdiconsolehelper</code> API call described below to   download a <code>virt-viewer</code> configuration file and then connect with <code>virt-viewer</code>.   See the example below for more details.</li> </ul> REST API calls <ul> <li>GET /instances/{instance_ref}/consoledata: Fetch read only serial console data for an instance</li> <li>DELETE /instances/{instance_ref}/consoledata: Clear the read only serial console for an instance.</li> <li>GET /instances/{instance_ref}/vdiconsolehelper: Generate and return a <code>virt-viewer</code> configuration file for connecting to the interactive VDI console for the instance (if configured).</li> </ul> Python API client: connect seamlessly to a VDI console using virt-viewer <pre><code>import os\nfrom shakenfist_client import apiclient\nimport subprocess\nimport tempfile\nimport time\n\nsf_client = apiclient.Client()\ni = sf_client.create_instance(\n        'example', 1, 1024, None,\n        [{\n            'size': 20,\n            'base': 'debian:11',\n            'bus': None,\n            'type': 'disk'\n        }],\n        None, None)\n\n# Wait for the instance to be created, or error out. Use instance events to\n# provide status updates during boot.\nwhile i['state'] not in ['created', 'error']:\n    events = sf_client.get_instance_events(i['uuid'])\n    print('Waiting for the instance to start: %s' % events[0]['message'])\n    time.sleep(5)\n    i = sf_client.get_instance(i['uuid'])\n\n# Check the instance is created correctly\nif i['state'] != 'created':\n    print('Instance is not in a created state!')\n    sys.exit(1)\nprint('Instance is created')\n\n# We don't use NamedTemporaryFile as a context manager as the .vv file\n# will also attempt to clean up the file.\n(temp_handle, temp_name) = tempfile.mkstemp()\nos.close(temp_handle)\ntry:\n    with open(temp_name, 'w') as f:\n        f.write(sf_client.get_vdi_console_helper(i['uuid']))\n\n    p = subprocess.run('remote-viewer %s' % temp_name, shell=True)\n    print('Remote viewer process exited with %d return code' % p.returncode)\nfinally:\n    if os.path.exists(temp_name):\n        os.unlink(temp_name)\n</code></pre>"},{"location":"developer_guide/api_reference/instances/#metadata","title":"Metadata","text":"<p>All objects exposed by the REST API may have metadata associated with them. This metadata is for storing values that are of interest to the owner of the resources, not Shaken Fist. Shaken Fist does not attempt to interpret these values at all, with the exception of the instance affinity metadata values. The metadata store is in the form of a key value store, and a general introduction is available in the user guide.</p> Info <p>Note that for affinity metadata to be processed by the scheduler, it must be present in the instance create API call, which is why that call takes a metadata argument. Adding affinity metadata after instance creation will not affect the placement of that instance, but would affect the placement of future instances.</p> REST API calls <ul> <li>GET \u200b/instances\u200b/{instance_ref}\u200b/metadata: Get metadata for an instance.</li> <li>POST /instances/{instance_ref}/metadata: Create a new metadata key for an instance.</li> <li>DELETE /instances/{instance_ref}/metadata/{key}: Delete a specific metadata key for an instance.</li> <li>PUT /instances/{instance_ref}/metadata/{key}: Update an existing metadata key for an instance.</li> </ul> Python API client: set metadata on an instance <pre><code>from shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nsf_client.set_instance_metadata_item(instance_uuid, 'foo', 'bar')\n</code></pre> Python API client: get metadata for an instance <pre><code>import json\nfrom shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nmd = sf_client.get_instance_metadata(instance_uuid)\nprint(json.dumps(md, indent=4, sort_keys=True))\n</code></pre> Python API client: delete metadata for an instance <pre><code>import json\nfrom shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nsf_client.delete_instance_metadata_item(instance_uuid, 'foo')\n</code></pre>"},{"location":"developer_guide/api_reference/interfaces/","title":"Network Interfaces (/interfaces/)","text":"<p>Network Interfaces (known as just \"interfaces\" in the REST API), are the object which ties an instance to the networks it is present on. There is a 1:1 mapping between network interface objects and NICs inside an instance, such that an instance with multiple interfaces on the same network would have two network interface objects associated with it.</p> <p>To lookup the network interfaces for an instance, use the GET /instances/{instance_ref}/interfaces API call as documented in the instance documentation.</p>"},{"location":"developer_guide/api_reference/interfaces/#fetching-information-about-a-network-interface","title":"Fetching information about a network interface","text":"<p>As with other objects in the Shaken Fist REST API, you can fetch the details for a network interface from the REST API.</p> REST API calls <ul> <li>GET /interfaces/{interface_uuid}: Get information about a specific network interface.</li> </ul> Python API client: fetch interface details <pre><code>import json\nfrom shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\niface = sf_client.get_interface('b1981e81-b37a-4176-ba37-b61bc7208012')\nprint(json.dumps(iface, indent=4, sort_keys=True))\n</code></pre> Python API client: fetch details for a network interface associated with an instance <p>Note that the interface details for an instance wont be populated until the instance has started being created on the hypervisor node. Specifically, this can be some time later if an image needs to be fetched from the Internet and transcoded. Therefore in this example we wait for the instance to be created before displaying interface details.</p> <pre><code>import json\nfrom shakenfist_client import apiclient\nimport time\n\nsf_client = apiclient.Client()\ni = sf_client.create_instance(\n        'example', 1, 1024, None,\n        [{\n            'size': 20,\n            'base': 'debian:11',\n            'bus': None,\n            'type': 'disk'\n        }],\n        None, None)\n\n# Wait for the instance to be created, or error out. Use instance events to\n# provide status updates during boot.\nwhile i['state'] not in ['created', 'error']:\n    events = sf_client.get_instance_events(i['uuid'])\n    print('Waiting for the instance to start: %s' % events[0]['message'])\n    time.sleep(5)\n    i = sf_client.get_instance(i['uuid'])\n\n# Check the instance is created correctly\nif i['state'] != 'created':\n    print('Instance is not in a created state!')\n    sys.exit(1)\nprint('Instance is created')\n\n# Fetch and display interface details\nifaces = sf_client.get_instance_interfaces(i['uuid'])[0]\nprint(json.dumps(ifaces, indent=4, sort_keys=True))\n</code></pre> <pre><code>$ python3 example.py\nWaiting for the instance to start: Fetching required blob ffdfce7f-728e-4b76-83c2-304e252f98b1, 30% complete\nInstance is created\n[\n    {\n        \"floating\": null,\n        \"instance_uuid\": \"d512e9f5-98d6-4c36-8520-33b6fc6de15f\",\n        \"ipv4\": \"10.0.0.6\",\n        \"macaddr\": \"02:00:00:73:18:66\",\n        \"metadata\": {},\n        \"model\": \"virtio\",\n        \"network_uuid\": \"6aaaf243-0406-41a1-aa13-5d79a0b8672d\",\n        \"order\": 0,\n        \"state\": \"created\",\n        \"uuid\": \"b1981e81-b37a-4176-ba37-b61bc7208012\",\n        \"version\": 3\n    }\n]\n</code></pre>"},{"location":"developer_guide/api_reference/interfaces/#floating-network-interfaces","title":"Floating network interfaces","text":"<p>Network interfaces by default have an address on the private IP range of the network they belong to. This is sufficient to access resources outside the Shaken Fist cluster, as long as the network has <code>provide_nat</code> enabled when created. However, a network interface is not accessible from outside the Shaken Fist cluster in this state.</p> <p>To make a network interface accessible to clients outside the Shaken Fist cluster, you \"float\" the interface. This assigns an address from the cluster's <code>floating</code> network, which is then DNAT'ed to the private IP address of the interface. As an instance it is not possible to see your floating address from inside the instance, as the network address translation has already occurred when the packets reach the instance.</p> REST API calls <ul> <li>POST /interfaces/{interface_uuid}/float: Add a floating address to a network interface to make it externally accessible.</li> <li>POST /interfaces/{interface_uuid}/defloat: Remove a floating address from a network interface, thus making the interface not externally accessible.</li> </ul> Python API client: float a network interface <p>A request to float an interface is an asynchronous operation, so we must make the request and then poll to learn our external address.</p> <pre><code>import json\nfrom shakenfist_client import apiclient\nimport time\n\nsf_client = apiclient.Client()\nsf_client.float_interface('b1981e81-b37a-4176-ba37-b61bc7208012')\n\niface = sf_client.get_interface('b1981e81-b37a-4176-ba37-b61bc7208012')\nwhile not iface.get('floating'):\n    print('Waiting...')\n    time.sleep(5)\n    iface = sf_client.get_interface('b1981e81-b37a-4176-ba37-b61bc7208012')\n\nprint('The interface is externally accessible at %s' % iface['floating'])\n</code></pre> <pre><code>$ python3 example.py\nThe interface is externally accessible at 192.168.10.5\n</code></pre> Python API client: defloat a network interface <pre><code>import json\nfrom shakenfist_client import apiclient\nimport time\n\nsf_client = apiclient.Client()\nsf_client.defloat_interface('b1981e81-b37a-4176-ba37-b61bc7208012')\n</code></pre>"},{"location":"developer_guide/api_reference/interfaces/#metadata","title":"Metadata","text":"<p>All objects exposed by the REST API may have metadata associated with them. This metadata is for storing values that are of interest to the owner of the resources, not Shaken Fist. Shaken Fist does not attempt to interpret these values at all, with the exception of the instance affinity metadata values. The metadata store is in the form of a key value store, and a general introduction is available in the user guide.</p> REST API calls <ul> <li>GET \u200b/interfaces\u200b/{interface_uuid}\u200b/metadata: Get metadata for an interface.</li> <li>POST /interfaces/{interface_uuid}/metadata: Create a new metadata key for an interface.</li> <li>DELETE /interfaces/{interface_uuid}/metadata/{key}: Delete a specific metadata key for an interface.</li> <li>PUT /interfaces/{interface_uuid}/metadata/{key}: Update an existing metadata key for an interface.</li> </ul> Python API client: set metadata on an interface <pre><code>from shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nsf_client.set_interface_metadata_item(img_uuid, 'foo', 'bar')\n</code></pre> Python API client: get metadata for an interface <pre><code>import json\nfrom shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nmd = sf_client.get_interface_metadata(img_uuid)\nprint(json.dumps(md, indent=4, sort_keys=True))\n</code></pre> Python API client: delete metadata for an interface <pre><code>import json\nfrom shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nsf_client.delete_interface_metadata_item(img_uuid, 'foo')\n</code></pre>"},{"location":"developer_guide/api_reference/label/","title":"Label (/label/)","text":"<p>Most interactions with labels will be to treat them as artifacts, which are documented elsewhere. However, there are a small number of label specific calls which are documented here. For a general introduction to labels, see the artifacts section of the user guide.</p> REST API calls <ul> <li>GET /label/{label_name}: Search for a label by name.</li> <li>POST /label/{label_name}: Update the current blob for a label.</li> <li>DELETE /label/{label_name}: Delete a label by name.</li> </ul> Python API client: update a label <p>A common pattern is to use generic upstream Shaken Fist images as source image, which you then customize and test. Once testing has passed you add the tested version of a label which tracks \"blessed\" production images.</p> <pre><code>import json\nfrom shakenfist_client import apiclient\nimport time\n\nsf_client = apiclient.Client()\n\n# Download a copy of Debian 11 and wait for the download to complete\nsf_client.cache_artifact('debian:11')\na = sf_client.get_artifact('debian:11')\n\nwhile not a.get('blobs'):\n    print('Waiting for first blob...')\n    time.sleep(30)\n    a = sf_client.get_artifact('debian:11')\n\nblob_index = sorted(a['blobs'].keys())[-1]\nblob_uuid = a['blobs'][blob_index]['uuid']\n\nprint('The most recent blob UUID is %s' % blob_uuid)\n\n# Let's assume we've now tested this version and want to \"bless\" it as the\n# version we trust for production workloads. We would then add that blob as the\n# new version of our production label like this:\nprod = sf_client.update_label('debian-11-production', blob_uuid)\n\nprint()\nprint('The label artifact is now:')\nprint(json.dumps(prod, indent=4, sort_keys=True))\n</code></pre> <pre><code>$ python3 example.py\nThe most recent blob UUID is ffdfce7f-728e-4b76-83c2-304e252f98b1\n\nThe label artifact is now:\n{\n    \"artifact_type\": \"label\",\n    \"blob_uuid\": \"ffdfce7f-728e-4b76-83c2-304e252f98b1\",\n    \"blobs\": {\n        \"1\": {\n            \"depends_on\": null,\n            \"instances\": [\n                \"d512e9f5-98d6-4c36-8520-33b6fc6de15f\"\n            ],\n            \"reference_count\": 2,\n            \"size\": 403007488,\n            \"uuid\": \"ffdfce7f-728e-4b76-83c2-304e252f98b1\"\n        }\n    },\n    \"index\": 1,\n    \"max_versions\": 3,\n    \"metadata\": {},\n    \"namespace\": \"system\",\n    \"shared\": false,\n    \"source_url\": \"sf://label/system/debian-11-production\",\n    \"state\": \"created\",\n    \"uuid\": \"c9428ea2-a3fa-40cf-9668-61be99bb370a\",\n    \"version\": 6\n}\n</code></pre>"},{"location":"developer_guide/api_reference/networks/","title":"Networks (/networks/)","text":"<p>Not yet documented.</p> Python API client: create a network <pre><code>import json\nfrom shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nn = sf_client.allocate_network('10.0.0.0/24', True, True, 'example')\nprint(json.dumps(n, indent=4, sort_keys=True))\n</code></pre> <pre><code>$ python3 example.py\n{\n    \"floating_gateway\": \"192.168.10.16\",\n    \"metadata\": {},\n    \"name\": \"example\",\n    \"namespace\": \"system\",\n    \"netblock\": \"10.0.0.0/24\",\n    \"provide_dhcp\": true,\n    \"provide_nat\": true,\n    \"state\": \"created\",\n    \"uuid\": \"1e9222c5-2d11-4ada-b258-ed1838bd774b\",\n    \"version\": 4,\n    \"vxid\": 4882442\n}\n</code></pre> Python API client: delete a network <pre><code>import json\nfrom shakenfist_client import apiclient\nimport time\n\nsf_client = apiclient.Client()\nn = sf_client.allocate_network('10.0.0.0/24', True, True, 'example')\n\nn = sf_client.delete_network(n['uuid'])\nwhile n['state'] != 'deleted':\n    print('Waiting...')\n    time.sleep(1)\n    n = sf_client.get_network(n['uuid'])\n\nprint(json.dumps(n, indent=4, sort_keys=True))\n</code></pre> <pre><code>$ python3 example.py\nWaiting...\n{\n    \"floating_gateway\": null,\n    \"metadata\": {},\n    \"name\": \"example\",\n    \"namespace\": \"system\",\n    \"netblock\": \"10.0.0.0/24\",\n    \"provide_dhcp\": true,\n    \"provide_nat\": true,\n    \"state\": \"deleted\",\n    \"uuid\": \"d56ae6e4-2592-43cd-b614-2dc7ca04970a\",\n    \"version\": 4,\n    \"vxid\": 15408371\n}\n</code></pre> Python API client: get a single network <pre><code>from shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nn = sf_client.get_network('...uuid...')\n</code></pre> Python API client: list networks <pre><code>import json\nfrom shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nnets = sf_client.get_networks()\nprint(json.dumps(nets, indent=4, sort_keys=True))\n</code></pre> <p>``` $ python3 example.py [     {         \"name\": \"sfcbr-7YWeQo4BoqLjASDd\",         \"namespace\": \"sfcbr-7YWeQo4BoqLjASDd\",         \"netblock\": \"10.0.0.0/24\",         \"provide_dhcp\": true,         \"provide_nat\": true,         \"state\": \"created\",         \"uuid\": \"759b742d-6140-475e-9553-ac120b56c1ef\",         \"vxlan_id\": 0     } ] ````</p> Python API client: list events for a network <pre><code>import json\nfrom shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nevents = sf_client.get_network_events('e0c2ee96-2b61-4d58-abd4-2cdef522b7a6')\nprint(json.dumps(events, indent=4, sort_keys=True))\n</code></pre> <p>Note that events are returned in reverse chronological order and are limited to the 100 most recent events.</p> <pre><code>$ python3 example.py\n[\n    ...\n    {\n        \"duration\": null,\n        \"extra\": {\n            \"rx\": {\n                \"bytes\": 2146364,\n                \"dropped\": 0,\n                \"errors\": 0,\n                \"multicast\": 0,\n                \"over_errors\": 0,\n                \"packets\": 13127\n            },\n            \"tx\": {\n                \"bytes\": 152367092,\n                \"carrier_errors\": 0,\n                \"collisions\": 0,\n                \"dropped\": 0,\n                \"errors\": 0,\n                \"packets\": 96644\n            }\n        },\n        \"fqdn\": \"sf-1\",\n        \"message\": \"usage\",\n        \"timestamp\": 1685229103.9690208,\n        \"type\": \"usage\"\n    },\n    ...\n]\n</code></pre> Python API client: list interfaces on a network <pre><code>import json\nfrom shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nevents = sf_client.get_network_interfaces('91b88200-ab4c-4ac4-9709-459504d1da0a')\nprint(json.dumps(events, indent=4, sort_keys=True))\n</code></pre> <pre><code>$ python3 example.py\n[\n    {\n        \"floating\": \"192.168.10.84\",\n        \"instance_uuid\": \"fffaa23b-c38b-484b-b58e-22eedc6ba94f\",\n        \"ipv4\": \"10.0.0.20\",\n        \"macaddr\": \"02:00:00:19:e4:b4\",\n        \"metadata\": {},\n        \"model\": \"virtio\",\n        \"network_uuid\": \"91b88200-ab4c-4ac4-9709-459504d1da0a\",\n        \"order\": 0,\n        \"state\": \"created\",\n        \"uuid\": \"24e636b4-b60c-4fcc-89d3-e717667a8c83\",\n        \"version\": 3\n    },\n    {\n        \"floating\": null,\n        \"instance_uuid\": \"1762820a-1e44-41b3-9174-44412481d873\",\n        \"ipv4\": \"10.0.0.57\",\n        \"macaddr\": \"02:00:00:4b:dc:5f\",\n        \"metadata\": {},\n        \"model\": \"virtio\",\n        \"network_uuid\": \"91b88200-ab4c-4ac4-9709-459504d1da0a\",\n        \"order\": 0,\n        \"state\": \"created\",\n        \"uuid\": \"0c790a6e-a4de-4518-84e7-11d1421cd4df\",\n        \"version\": 3\n    }\n]\n</code></pre> Python API client: ping on a network. <pre><code>import json\nfrom shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nevents = sf_client.ping('55ea5f3b-d671-4d7f-9b8c-1e8f217a74f4', '10.0.0.187')\nprint(json.dumps(events, indent=4, sort_keys=True))\n</code></pre> <pre><code>$ python3 example.py\n{\n    \"stderr\": [\n        \"\"\n    ],\n    \"stdout\": [\n        \"PING 10.0.0.187 (10.0.0.187) 56(84) bytes of data.\",\n        \"64 bytes from 10.0.0.187: icmp_seq=1 ttl=64 time=0.393 ms\",\n        \"64 bytes from 10.0.0.187: icmp_seq=2 ttl=64 time=0.273 ms\",\n        \"64 bytes from 10.0.0.187: icmp_seq=3 ttl=64 time=0.227 ms\",\n        \"64 bytes from 10.0.0.187: icmp_seq=4 ttl=64 time=0.252 ms\",\n        \"64 bytes from 10.0.0.187: icmp_seq=5 ttl=64 time=0.269 ms\",\n        \"64 bytes from 10.0.0.187: icmp_seq=6 ttl=64 time=0.252 ms\",\n        \"64 bytes from 10.0.0.187: icmp_seq=7 ttl=64 time=0.228 ms\",\n        \"64 bytes from 10.0.0.187: icmp_seq=8 ttl=64 time=0.265 ms\",\n        \"64 bytes from 10.0.0.187: icmp_seq=9 ttl=64 time=0.246 ms\",\n        \"64 bytes from 10.0.0.187: icmp_seq=10 ttl=64 time=0.257 ms\",\n        \"\",\n        \"--- 10.0.0.187 ping statistics ---\",\n        \"10 packets transmitted, 10 received, 0% packet loss, time 9213ms\",\n        \"rtt min/avg/max/mdev = 0.227/0.266/0.393/0.044 ms\",\n        \"\"\n    ]\n}\n</code></pre>"},{"location":"developer_guide/api_reference/nodes/","title":"Nodes (/nodes/)","text":"<p>Not yet documented.</p>"},{"location":"developer_guide/api_reference/upload/","title":"Upload (/upload)","text":"<p>Uploads are documented as part of the artifacts API reference documentation.</p>"},{"location":"operator_guide/artifacts/","title":"Artifacts","text":""},{"location":"operator_guide/artifacts/#checksums","title":"Checksums","text":"<p>As of Shaken Fist v0.7, blob replicas are regularly checksummed to verify that data loss has not occurred. The following events imply a checksum operation:</p> <ul> <li>snapshotting an NVRAM template.</li> <li>creation of a new blob replica by transfer of a blob from another machine in   the cluster (the destination is checksummed to verify the transfer).</li> <li>transcode of a blob into a new format (the new format is stored as a   separate blob).</li> <li>conversion of an upload to an artifact.</li> </ul> <p>The following events should imply an artifact checksum, but we found that performance suffered too much for very large blobs:</p> <ul> <li>download of a new blob from an external source (artifact fetch for example).</li> <li>snapshotting a disk.</li> </ul> <p>Additionally, all blob replicas are regularly checksummed and compared with what the record in etcd believes the correct value should be. These comparisons are rate limited, but should happen with a maximum frequency of CHECKSUM_VERIFICATION_FREQUENCY seconds, which defaults to every 24 hours. It is possible if you have a large number of blob replicas on a given node that the node will be unable to keep up with checksum operations.</p> <p>If a blob replica fails the checksum verification, CHECKSUM_ENFORCEMENT is set to True and is not in use on that node, then the replica is deleted and the cluster will re-replicate the blob as required. If the blob replica is in use, there isn't much Shaken Fist can do without disturbing running instances, so the error is logged and then ignored for now.</p> <p>Checksums are also used when a new version of an artifact is created. If the checksum of the previous version is the same as the checksum for the proposed new version, the proposed new version is skipped. Artifact uploads from v0.7 can also skip actual upload of the contents of the artifact if there is already a blob in the cluster with a matching checksum.</p>"},{"location":"operator_guide/artifacts/#sharing-artifacts","title":"Sharing artifacts","text":"<p>Artifacts in the system namespace can be shared with all other namespaces. Artifacts shared like this appear to the other namespaces as if they are local to the other namespace, although non-system namespaces should not be able to update such an artifact. This is useful if you have official or commonly used images which you want to provide all users of a cluster -- for example an official CentOS image that many users will want.</p> Info <p>Another option for sharing artifacts is the \"trusts\" relationship between two namespaces, which is discussed in the authentication section of the operator guide.</p> <p>To share an artifact, use the command line client like this:</p> <p><code>sf-client artifact share ...uuid...</code></p> <p>To unshare an artifact, do this:</p> <p><code>sf-client artifact unshare ...uuid...</code></p>"},{"location":"operator_guide/authentication/","title":"Authentication","text":"Info <p>For a detailed discussion of how Shaken Fist authentication works, please see the discussion in the developer guide.</p>"},{"location":"operator_guide/authentication/#trusts","title":"Trusts","text":"Info <p>Trusts are a newer way of sharing between namespaces with granular control. If you instead are interested in making artifacts available to all users of a Shaken Fist cluster, then you should also consider artifact sharing, which is discussed in the artifacts section of the operators guide.</p> <p>The system namespace is special in a Shaken Fist cluster in that it can see objects in all other namespaces. That is, if you are authenticated as the system namespace and list instances, you get not only the instances in the system namespace, but also all those in other namespaces. The same is true for other namespaced objects such as networks and artifacts.</p> <p>In older versions of Shaken Fist this behavior was hard coded, but as of Shaken Fist v0.7 this is now implemented more flexibly. The system namespace must still be able to see every other namespace, but you can also create a \"trust\" relationship between two arbitrary namespaces to achieve the same result on a smaller scale. In fact, the system namespace is now simply a default trust that all other namespaces have a relationship with.</p> <p>The Shaken Fist CI system uses these trusts for base images for CI runs. Each night we rebuild a series of base test images -- Debian 10, Debian 11, Ubuntu 20.04 and so on. Each Shaken Fist CI job is run in its own namespace, so we needed a place to store these base images, as well as a mechanism for other CI jobs to be able to see them.</p> <p>What we implemented was:</p> <ul> <li>a namespace to store the base images (we called it <code>ci-images</code>).</li> <li>when our CI conductor creates a new CI runner and associated namespace, it   creates a trust between that ephemeral namespace and the <code>ci-images</code> namespace.</li> <li>jobs to create new images build them in their local namespace, and then \"gift\"   them to the <code>ci-images</code> namespace via a label.</li> <li>jobs which need to boot a test image can now see the images from the <code>ci-images</code>   namespace by virtue of this trust relationship.</li> </ul>"},{"location":"operator_guide/installation/","title":"Installing Shaken Fist","text":"<p>The purpose of this guide is to walk you through a Shaken Fist installation. Shaken Fist will work just fine on a single machine, although its also happy to run on clusters of machines. We'll discuss the general guidance for install options as we go.</p> <p>Shaken Fist only supports Ubuntu 20.04, Debian 10, and Debian 11, so if you're running on localhost that implies that you must be running a recent Ubuntu or Debian on your development machine. Note as well that the deployer installs software and changes the configuration of your networking, so be careful when running it on machines you are fond of. This documentation was most recently tested against Debian 11, in November 2021. Bug reports are welcome if you have any issues, and may be filed at https://github.com/shakenfist/shakenfist/issues</p> <p>Each machine in the cluster should match this description:</p> <ul> <li>Have virtualization extensions enabled in the BIOS.</li> <li>Have jumbo frames enabled on the switch for the \"mesh interface\" for installations of more than one machine. Shaken Fist can optionally run internal traffic such as etcd and virtual network meshes on a separate interface to traffic egressing the cluster. Whichever interface you specify as being used for virtual network mesh traffic must have jumbo frames enabled for the virtual networks to function correctly.</li> <li>Have at least 1 gigabit connectivity on the \"mesh interface\". This is a requirement of etcd.</li> <li>Have a cloudadmin account setup with passwordless sudo, and a ssh key in its authorized_keys file. This is an ansible requirement, although the exact username is configurable in the SSH_USER variable.</li> </ul> <p>We now have a fancy helper to help you install your first localhost cluster, so let's give that a go:</p> <pre><code>curl https://raw.githubusercontent.com/shakenfist/shakenfist/develop/deploy/getsf -o getsf\nchmod ugo+rx getsf\nsudo ./getsf\n</code></pre> <p>This script will then walk you through the installation steps, asking questions as you go. The script leaves you with an installer configuration at <code>/root/sf-deploy</code>, which is the basis for later upgrades and cluster expansions.</p> <p>You can script the answers to <code>getsf</code> by setting environment variables. For example:</p> <pre><code>export GETSF_FLOATING_BLOCK=192.168.10.0/24\nexport GETSF_DEPLOY_NAME=bonkerslab\nexport GETSF_RELEASE=pre-release\nexport GETSF_NODES=localhost\nexport GETSF_WARNING=yes\nsudo --preserve-env ./getsf\n</code></pre>"},{"location":"operator_guide/installation/#sample-configuration-for-a-multi-node-deploy","title":"Sample configuration for a multi-node deploy","text":"<p>However, if you're performing a multinode deploy, the process is currently much more manual. The intent is to expand <code>getsf</code> to handle multiple nodes, but that work is not yet complete.</p> <p>For now, you'll need to write a configuration file a bit like this on the primary node:</p> <pre><code>export ADMIN_PASSWORD=engeeF1o\nexport FLOATING_IP_BLOCK=\"192.168.10.0/24\"\nexport DEPLOY_NAME=\"bonkerslab\"\nexport SSH_USER=\"cloudadmin\"\nexport SSH_KEY_FILENAME=\"/root/.ssh/id_rsa\"\n\nexport KSM_ENABLED=1\n\n# Topology is in JSON\nread -r -d '' TOPOLOGY &lt;&lt;'EOF'\n[\n  {\n    \"name\": \"sf-primary\",\n    \"node_egress_ip\": \"192.168.1.50\",\n    \"node_egress_nic\": \"enp0s31f6\",\n    \"node_mesh_ip\": \"192.168.21.50\",\n    \"node_mesh_nic\": \"enp0s31f6:1\",\n    \"primary_node\": true,\n    \"api_url\": \"https://...your...install...here.com/api\"\n  },\n  {\n    \"name\": \"sf-1\",\n    \"node_egress_ip\": \"192.168.1.51\",\n    \"node_egress_nic\": \"enp5s0\",\n    \"node_mesh_ip\": \"192.168.21.51\",\n    \"node_mesh_nic\": \"eno1\",\n    \"etcd_master\": true,\n    \"network_node\": true,\n    \"hypervisor\": true\n  },\n  {\n    \"name\": \"sf-2\",\n    \"node_egress_ip\": \"192.168.1.52\",\n    \"node_egress_nic\": \"enp5s0\",\n    \"node_mesh_ip\": \"192.168.21.52\",\n    \"node_mesh_nic\": \"eno1\",\n    \"etcd_master\": true,\n    \"hypervisor\": true\n  },\n  {\n    \"name\": \"sf-3\",\n    \"node_egress_ip\": \"192.168.1.53\",\n    \"node_egress_nic\": \"enp5s0\",\n    \"node_mesh_ip\": \"192.168.21.53\",\n    \"node_mesh_nic\": \"eno1\",\n    \"etcd_master\": true,\n    \"hypervisor\": true\n  },\n]\nEOF\nexport TOPOLOGY\n\n/srv/shakenfist/venv/share/shakenfist/installer/install\n</code></pre>"},{"location":"operator_guide/installation/#notes-for-multi-node-installations","title":"Notes for multi-node installations","text":"<p>Not every node needs to be an etcd_master. I'd select three in most situations. One node must be marked as the primary node, and one must be marked as the network node. It is not currently supported having more than one of each of those node types.</p> <ul> <li>The primary node runs an apache load balancer across the API servers in the cluster, and therefore needs to be accessable to your users on HTTP and HTTPS.</li> <li>The network node is the ingress and egress point for all virtual networks, and is where floating IPs live, so it needs to be setup as the gateway fro your floating IP block.</li> </ul> <p>Some of the considerations here can be subtle. Please reach out if you need a hand.</p> <p>For a node complicated installation, <code>sf-deploy</code> might like this:</p> <pre><code>#!/bin/bash\n\nexport ADMIN_PASSWORD=engeeF1o\nexport FLOATING_IP_BLOCK=\"192.168.10.0/24\"\nexport DEPLOY_NAME=\"bonkerslab\"\nexport SSH_USER=\"cloudadmin\"\nexport SSH_KEY_FILENAME=\"/root/.ssh/id_rsa\"\n\nexport KSM_ENABLED=1\n\n# Topology is in JSON\nread -r -d '' TOPOLOGY &lt;&lt;'EOF'\n[\n  {\n    \"name\": \"sf-primary\",\n    \"node_egress_ip\": \"192.168.1.50\",\n    \"node_egress_nic\": \"enp0s31f6\",\n    \"node_mesh_ip\": \"192.168.21.50\",\n    \"node_mesh_nic\": \"enp0s31f6:1\",\n    \"primary_node\": true,\n    \"api_url\": \"https://...your...install...here.com/api\"\n  },\n  {\n    \"name\": \"sf-1\",\n    \"node_egress_ip\": \"192.168.1.51\",\n    \"node_egress_nic\": \"enp5s0\",\n    \"node_mesh_ip\": \"192.168.21.51\",\n    \"node_mesh_nic\": \"eno1\",\n    \"etcd_master\": true,\n    \"network_node\": true,\n    \"hypervisor\": true\n  },\n  {\n    \"name\": \"sf-2\",\n    \"node_egress_ip\": \"192.168.1.52\",\n    \"node_egress_nic\": \"enp5s0\",\n    \"node_mesh_ip\": \"192.168.21.52\",\n    \"node_mesh_nic\": \"eno1\",\n    \"etcd_master\": true,\n    \"hypervisor\": true\n  },\n  {\n    \"name\": \"sf-3\",\n    \"node_egress_ip\": \"192.168.1.53\",\n    \"node_egress_nic\": \"enp5s0\",\n    \"node_mesh_ip\": \"192.168.21.53\",\n    \"node_mesh_nic\": \"eno1\",\n    \"etcd_master\": true,\n    \"hypervisor\": true\n  },\n]\nEOF\nexport TOPOLOGY\n\n/srv/shakenfist/venv/share/shakenfist/installer/install\n</code></pre>"},{"location":"operator_guide/installation/#your-first-instance","title":"Your first instance","text":"<p>Before you can start your first instance you'll need to authenticate to Shaken Fist, and create a network. Shaken Fist's python api client (as used by the command line client) looks for authentication details in the following locations:</p> <ul> <li>Command line flags</li> <li>Environment variables (prefixed with SHAKENFIST_)</li> <li>~/.shakenfist, a JSON formatted configuration file</li> <li>/etc/sf/shakenfist.json, the same file as above, but global</li> </ul> <p>By default the installer creates /etc/sf/sfrc, which sets the required environment variables to authenticate. It is customized per installation, setting the following variables:</p> <ul> <li>SHAKENFIST_NAMESPACE, the namespace to create resources in</li> <li>SHAKENFIST_KEY, an authentication key for that namespace</li> <li>SHAKENFIST_API_URL, a URL to the Shaken Fist API server</li> </ul> <p>Before interacting with Shaken Fist, we need to source the rc file.</p> <pre><code>. /etc/sf/sfrc\n</code></pre> <p>Instances must be launched attached to a network.</p> <p>Create your first network: <pre><code>sf-client network create mynet 192.168.42.0/24\n</code></pre></p> <p>You can get help for the command line client by running <code>`sf-client --help</code>. The above command creates a new network called \"mynet\", with the IP block 192.168.42.0/24. You will receive some descriptive output back:</p> <pre><code>$ sf-client network create mynet 192.168.42.0/24\nuuid            : 16baa325-5adf-473f-8e7a-75710a822d45\nname            : mynet\nvxlan id        : 2\nnetblock        : 192.168.42.0/24\nprovide dhcp    : True\nprovide nat     : True\nfloating gateway: None\nnamespace       : system\nstate           : initial\n\nMetadata:\n</code></pre> <p>The UUID is important, as that is how we will refer to the network elsewhere. Let's now create a simple first instance (you'll need to change this to use your actual network UUID):</p> <pre><code>$ sf-client instance create myvm 1 1024 -d 8@cirros -n 16baa325-5adf-473f-8e7a-75710a822d45\nuuid        : c6c4ba94-ed34-497d-8964-c223489dee3e\nname        : myvm\nnamespace   : system\ncpus        : 1\nmemory      : 1024\ndisk spec   : type=disk   bus=None  size=8   base=cirros\nvideo       : model=cirrus  memory=16384\nnode        : marvin\npower state : on\nstate       : created\nconsole port: 31839\nvdi port    : 34442\n\nssh key     : None\nuser data   : None\n\nMetadata:\n\nInterfaces:\n\n    uuid    : e56b3c7b-8056-4645-b5b5-1779721ff21d\n    network : 16baa325-5adf-473f-8e7a-75710a822d45\n    macaddr : ae:15:4d:9c:d8:c0\n    order   : 0\nipv4    : 192.168.42.76\n    floating: None\n    model   : virtio\n</code></pre> <p>Probably the easiest way to interact with this instance is to connect to its console port, which is the serial console of the instance over telnet. In the case above, that is available on port 31829 on localhost (my laptop is called marvin).</p>"},{"location":"operator_guide/installation/#other-caveats","title":"Other caveats","text":"<p>The installer will also enforce the following sanity checks:</p> <ul> <li>That KVM will operate on your machines. This is generally fine unless you're using virtual machines at which point nested virtualization needs to be enabled.</li> <li>That your network interface MTU is greater than 2,000 bytes. This is required because the VXLAN mesh our virtual networks use add overhead to packets and a standard MTU of 1500 bytes for the physical network will result in packets being fragmented too frequently on the virtual networks. You can set a higher MTU if you desire, I generally select 9,000 bytes.</li> </ul>"},{"location":"operator_guide/installation/#deployment-variables","title":"Deployment variables","text":"Option Description ADMIN_PASSWORD The admin password for the cloud once installed DNS_SERVER The DNS server to configure instances with via DHCP. Defaults to 8.8.8.8 HTTP_PROXY A URL for a HTTP proxy to use for image downloads. For example http://localhost:3128 INCLUDE_TRACEBACKS Whether to include tracebacks in server 500 errors. Never set this to true in production! FLOATING_IP_BLOCK The IP range to use for the floating network KSM_ENABLED Set to 1 to enable KSM, 0 to disable DEPLOY_NAME The name of the deployment to use as an external label for prometheus TOPOLOGY The topology of the cluster, as described above SSH_KEY_FILENAME The path to a ssh private key file to use for authentication. It is assumed that the public key is at <code>${SSH_KEY_FILENAME}.pub</code>. SSH_USER The username to ssh as."},{"location":"operator_guide/locks/","title":"Locks","text":"<p>Shaken Fist uses etcd for distributed locking. All locks are written into etcd with the <code>/sflocks</code> key prefix. Locks are effectively leases on a key within etcd, where the key contains metadata about the lock being held. This means its easy to determine who else is holding a lock if you see contention issues within your cluster.</p> <p>The easiest way to do this is with the <code>sf-client admin lock list</code> command, which will list all locks currently held in the cluster. For example, here's a relatively idle cluster:</p> <pre><code>$ sf-client admin lock list\n+----------------------+-------+------+---------------------+\n|         lock         |  pid  | node |      operation      |\n+----------------------+-------+------+---------------------+\n| /sflocks/sf/cluster/ | 26407 | sf-7 | Cluster maintenance |\n+----------------------+-------+------+---------------------+\n</code></pre>"},{"location":"operator_guide/power_states/","title":"Instance power states","text":"<p>Shaken Fist version 0.2.1 introduced power states for instances. Before this, you could power on or off an instance, or pause it, but you couldn't tell what power state the instance was actually in. That was pretty confusing and was therefore treated as a bug.</p> <p>The following power states are implemented:</p> <ul> <li>on: the instance is running</li> <li>off: the instance is not running</li> <li>paused: the instance is paused</li> <li>crashed: the instance is crashed according to the hypervisor. Instances in this power state will also be in an instance state of \"error\".</li> </ul> <p>There are additionally a set of \"transition states\" which are used to indicate that you have requested a change of state that might not yet have completed. These are:</p> <ul> <li>transition-to-on</li> <li>transition-to-off</li> <li>transition-to-paused</li> </ul> <p>We're hoping to not have to implement a transition-to-crashed state, but you never know.</p>"},{"location":"operator_guide/upgrades/","title":"Upgrades","text":"<p>Shaken Fist supports online upgrades natively -- when an object is read from etcd that is an old version, the object is upgraded silently to the newest version. If all nodes in your cluster are running a version of Shaken Fist which supports this newest version, the upgraded object is then written back to etcd. If not all nodes in the cluster support the new version, the new version is simply used in memory by the node which did the upgrade. This means it is safe to perform a rollout across a cluster without downtime, although you might see small transient failures such as single API requests failing as processes restart.</p> <p>You should note however that \"all nodes\" includes nodes in non-running states such as ERROR and MISSING. The only state which is excluded from the check is DELETED. Therefore, in order for online upgrades to work correctly, it is important that you delete nodes in an ERROR or MISSING state that you are confident will not return to the cluster. This is because nodes can return from ERROR or MISSING at the end of planned maintenance, and might be running and older version of Shaken Fist upon their return than other members of the cluster.</p>"},{"location":"operator_guide/upgrades/#upgrade-process","title":"Upgrade process","text":"<p>First off, upgrade the python packages in each node's virtualenv manually. This is explicitly a non-goal of our installer tooling as we believe different deployments will have different strategies for performing this step. Naively, a good first approach is simple to run this command on each node:</p> <pre><code>sudo /srv/shakenfist/venv/bin/pip install --upgrade shakenfist\n</code></pre> <p>Which will pull in all the relevant other python packages it requires.</p> <p>Then simply re-run <code>getsf</code> as you did when you first installed and the cluster will upgrade.</p>"},{"location":"operator_guide/networking/overview/","title":"Networking Overview","text":"<p>Shaken Fist networking is complicated. Its actually less complicated that OpenStack Neutron networking, and its about as simple as we can get away with, but in order to allow virtual networks to use overlapping network ranges we are forced to do some vaguely complicated things with network namespaces. This document attempts to incrementally describe how Shaken Fist networking works, so that I can remember later.</p>"},{"location":"operator_guide/networking/overview/#vxlan","title":"VXLAN","text":"<p>Shaken Fist networking is based on a VXLAN mesh. VXLAN is like a successor to VLANs, except that you can have 1.6 million virtual networks, it doesn't use an IP header field to divide the networks up, and it is transported inside UDP packets between the members of the mesh.</p> <p>Normally VXLAN meshes are implemented using multicast UDP, but that doesn't work in public clouds where Shaken Fist was born, so we instead use unicast meshes that we lovingly hand maintain.</p> <p>Note</p> <p>The virtual mesh manages itself and changes state over time. If your mesh entries do not look like mine, it does not nessesarily indicate that your networking is broken. This is a dynamic environment!</p>"},{"location":"operator_guide/networking/overview/#our-worked-examples","title":"Our worked examples","text":"<p>For this document, we will assume there are three Shaken Fist nodes, named sf-1, sf-2, and sf-3. Its a total coincidence that this is the default size for the installer ansible at the time of writing and the exact size of all of the production clusters we are aware of. sf-1 is configured as the \"network node\", which is just a hypervisor like every other node, except that it is also where packets to and from the virtual networks route in and out of the mesh.</p> <ul> <li>First, off let's start with a simple network with one instance and no DHCP or NAT.</li> </ul>"},{"location":"operator_guide/networking/single_instance/","title":"Networking Explained - Single Node","text":"<p>This page is part of a series explaining how Shaken Fist networking works. You might want to check out the other pages as well.</p>"},{"location":"operator_guide/networking/single_instance/#the-simplest-case-a-virtual-network-with-no-dhcp-and-no-nat-and-a-single-remote-instance","title":"The simplest case: a virtual network with no DHCP and no NAT, and a single remote instance","text":"<p>Let's assume you want a new virtual network with no network services. Its just two instances talking to each other.</p> <p>The basic flow is like this -- you create a virtual network. We allocate you a VXLAN network id (called the vxid in various places in the code):</p> <pre><code>sf-1 # sf-client network create demonet 192.168.0.0/24 --no-dhcp --no-nat\nuuid            : b41b067a-44b7-40c5-9ab8-7abdcf5fdc61\nname            : demonet\nvxlan id        : 2\nnetblock        : 192.168.0.0/24\nprovide dhcp    : False\nprovide nat     : False\nfloating gateway: None\nnamespace       : system\nstate           : initial\n\nMetadata:\n</code></pre> <p>So in this case we were allocated VXLAN id 2, and have a network UUID of b41b067a-44b7-40c5-9ab8-7abdcf5fdc61. The state of the network is \"initial\" as it has not been created anywhere yet. If you wait a few seconds, you'll see it transition to a \"created\" state. You can see the new state with a show command:</p> <pre><code>sf-1 # sf-client network show b41b067a-44b7-40c5-9ab8-7abdcf5fdc61\nuuid            : b41b067a-44b7-40c5-9ab8-7abdcf5fdc61\nname            : demonet\nvxlan id        : 2\nnetblock        : 192.168.0.0/24\nprovide dhcp    : False\nprovide nat     : False\nfloating gateway: None\nnamespace       : system\nstate           : created\n\nMetadata:\n</code></pre> <p>And you can see the steps we went through to create the network in the events listing:</p> <pre><code>sf-1 # sf-client network events b41b067a-44b7-40c5-9ab8-7abdcf5fdc61\n+----------------------------+------+------------------------+------------+----------------------+-----------+\n|         timestamp          | node |       operation        |   phase    |       duration       |  message  |\n+----------------------------+------+------------------------+------------+----------------------+-----------+\n| 2020-08-01 06:49:07.753351 | sf-1 |          api           |   create   |         None         |    None   |\n| 2020-08-01 06:49:07.792583 | sf-1 | create vxlan interface |   start    |         None         |    None   |\n| 2020-08-01 06:49:07.819312 | sf-1 | create vxlan interface |   finish   | 0.025562286376953125 |    None   |\n| 2020-08-01 06:49:07.840636 | sf-1 |  create vxlan bridge   |   start    |         None         |    None   |\n| 2020-08-01 06:49:07.905165 | sf-1 |  create vxlan bridge   |   finish   |  0.0644679069519043  |    None   |\n| 2020-08-01 06:49:07.910409 | sf-1 |      create netns      |   start    |         None         |    None   |\n| 2020-08-01 06:49:07.997595 | sf-1 |      create netns      |   finish   |  0.0850062370300293  |    None   |\n| 2020-08-01 06:49:08.016509 | sf-1 |   create router veth   |   start    |         None         |    None   |\n| 2020-08-01 06:49:08.237167 | sf-1 |   create router veth   |   finish   |  0.2197411060333252  |    None   |\n| 2020-08-01 06:49:08.254165 | sf-1 |  create physical veth  |   start    |         None         |    None   |\n| 2020-08-01 06:49:08.342684 | sf-1 |  create physical veth  |   finish   | 0.08613038063049316  |    None   |\n| 2020-08-01 06:49:08.371490 | sf-1 |   add mesh elements    |    None    |         None         | 10.2.1.11 |\n| 2020-08-01 06:49:08.375682 | sf-1 |          api           |  created   |         None         |    None   |\n| 2020-08-01 06:49:40.664204 | sf-1 |          api           |    get     |         None         |    None   |\n| 2020-08-01 06:50:07.554738 | sf-1 |          api           | get events |         None         |    None   |\n+----------------------------+------+------------------------+------------+----------------------+-----------+\n</code></pre> <p>You can see here that the network node (sf-1) has created some network elements, and an IP (10.2.1.11) has been added to the mesh. That IP is sf-1, and its part of the network node being joined to the mesh. If we look on sf-1, we should now have a VXLAN interface, a bridge, and one end of a veth.</p> <pre><code>sf-1 # ip addr show vxlan-2\n287: vxlan-2: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 8950 qdisc noqueue master br-vxlan-2 state UNKNOWN group default qlen 1000\n    link/ether de:c4:ab:3d:79:fb brd ff:ff:ff:ff:ff:ff\n    inet6 fe80::dcc4:abff:fe3d:79fb/64 scope link\n       valid_lft forever preferred_lft forever\n\nsf-1 # ip addr show br-vxlan-2\n288: br-vxlan-2: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 1000\n    link/ether be:c1:1b:20:b8:f7 brd ff:ff:ff:ff:ff:ff\n    inet6 fe80::bcc1:1bff:fe20:b8f7/64 scope link\n       valid_lft forever preferred_lft forever\n\nsf-1 # ip addr show veth-2-o\n290: veth-2-o@if289: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master br-vxlan-2 state UP group default qlen 1000\n    link/ether be:c1:1b:20:b8:f7 brd ff:ff:ff:ff:ff:ff link-netnsid 0\n    inet6 fe80::bcc1:1bff:fe20:b8f7/64 scope link\n       valid_lft forever preferred_lft forever\n</code></pre> <p>The vxlan-2 interface is the VXLAN mesh, and the br-vxlan-2 bridge is how VMs and veths will connect to the mesh on this local machine. Its important to note that MTU matters here. The MTU for the mesh network is 1500 bytes, and most client VMs will default to that as well. Therefore the underlying network needs to have a MTU greater than that. We default to an MTU of 9000 bytes in our installs, but 1550 would in fact be sufficient in this case. You can see this in the MTU for vxlan-2, which is our 9000 byte underlying MTU, with 50 bytes deducted for the VXLAN encapsulation.</p> <p>We can also ask the mesh for its current state:</p> <pre><code>sf-1 # bridge fdb show brport vxlan-2\nde:c4:ab:3d:79:fb master br-vxlan-2 permanent\nde:c4:ab:3d:79:fb vlan 1 master br-vxlan-2 permanent\n00:00:00:00:00:00 dst 10.2.1.11 self permanent\nde:c4:ab:3d:79:fb dst 127.0.0.1 self\nbe:c1:1b:20:b8:f7 dst 127.0.0.1 self\ne2:2d:32:6d:95:70 dst 127.0.0.1 self\n</code></pre> <p>The current members of the mesh are:</p> <ul> <li>de:c4:ab:3d:79:fb: this is the mac address for vxlan-2.</li> <li>00:00:00:00:00:00 dst 10.2.1.11: this is a mesh entry for the node with IP 10.2.1.11 (sf-1)</li> <li>be:c1:1b:20:b8:f7: this is the outside mac address of a veth between br-vxlan-2 and a network namespace on sf-1</li> <li>e2:2d:32:6d:95:70: is the inside mac address of the veth between br-vxlan-2 and the network namespace</li> </ul> <p>What is this network namespace? Well, Shaken Fist needs to create a network namespace to contain routing, NAT, and DHCP for the virtual network. It's actually not strictly required in this simplest case, but we always create it. It is named for the UUID of the virtual network:</p> <pre><code>sf-1 # ip netns exec b41b067a-44b7-40c5-9ab8-7abdcf5fdc61 ip addr list\n1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN group default qlen 1000\n    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n289: veth-2-i@if290: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 1000\n    link/ether e2:2d:32:6d:95:70 brd ff:ff:ff:ff:ff:ff link-netnsid 0\n    inet 192.168.0.1/24 scope global veth-2-i\n       valid_lft forever preferred_lft forever\n    inet6 fe80::e02d:32ff:fe6d:9570/64 scope link\n       valid_lft forever preferred_lft forever\n291: phy-2-i@if292: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN group default qlen 1000\n    link/ether fe:18:8e:f8:d1:5c brd ff:ff:ff:ff:ff:ff link-netnsid 0\n</code></pre> <p>The veth between the VXLAN mesh and this namespace is named veth-2-i (the interface inside the network namespace) and veth-2-o (the interface outside the network namespace). There is another veth named phy-2-i and phy-2-o, which is a link between the namespace and the outside world, but we'll talk about that more when we enable NAT. For those who are new to veths, think of them like patch cables -- so what we have here is a VXLAN mesh, which is patched into a network namespace, which is in turn patched into the outside world.</p> <p>We also do some things with iptables, especially around NAT. Here's the current state of iptables in the network namespace:</p> <pre><code>sf-1 # ip netns exec b41b067a-44b7-40c5-9ab8-7abdcf5fdc61 iptables -L -t nat\nChain PREROUTING (policy ACCEPT)\ntarget     prot opt source               destination\n\nChain INPUT (policy ACCEPT)\ntarget     prot opt source               destination\n\nChain OUTPUT (policy ACCEPT)\ntarget     prot opt source               destination\n\nChain POSTROUTING (policy ACCEPT)\ntarget     prot opt source               destination\n</code></pre> <p>That's empty for now because we're not doing any NAT yet, but watch this space. Next let's now start an instance on sf-2. This instance can't use DHCP to get an address because we have that disabled for this network.</p> <pre><code>sf-1 # sf-client instance create inst-on-sf-2 1 1024 -d 20@ubuntu:18.04 -n b41b067a-44b7-40c5-9ab8-7abdcf5fdc61 -p sf-2\nuuid        : d53b345f-9d5d-493c-a1a3-7e7d6513cfa2\nname        : inst-on-sf-2\nnamespace   : system\ncpus        : 1\nmemory      : 1024\ndisk spec   : type=disk   bus=None  size=20  base=ubuntu:18.04\nvideo       : model=cirrus  memory=16384\nnode        : sf-2\npower state : on\nstate       : created\nconsole port: 48420\nvdi port    : 32122\n\nssh key     : None\nuser data   : None\n\nMetadata:\n\nInterfaces:\n\n    uuid    : db372968-1c74-4033-8423-8a698e9d4900\n    network : b41b067a-44b7-40c5-9ab8-7abdcf5fdc61\n    macaddr : 00:00:00:34:8d:90\n    order   : 0\n    ipv4    : 192.168.0.3\n    floating: None\n    model   : virtio\n</code></pre> <p>You can see that our instance (inst-on-sf-2) has been placed on sf-2 because we asked nicely (the -p is a placement option to the command), and has been allocated an IP (192.168.0.3). The virtual network still allocates IPs, even if DHCP is disabled. It has also been allocated a MAC address (00:00:00:34:8d:90). What is the state of the mesh on the network node now?</p> <pre><code>sf-1 # bridge fdb show brport vxlan-2\nde:c4:ab:3d:79:fb master br-vxlan-2 permanent\nde:c4:ab:3d:79:fb vlan 1 master br-vxlan-2 permanent\n00:00:00:00:00:00 dst 10.2.1.11 self permanent\n0a:ce:c4:f7:cb:dc dst 10.2.1.12 self\nde:c4:ab:3d:79:fb dst 127.0.0.1 self\nbe:c1:1b:20:b8:f7 dst 127.0.0.1 self\n00:00:00:34:8d:90 dst 10.2.1.12 self\ne2:2d:32:6d:95:70 dst 127.0.0.1 self\n</code></pre> <p>The following entries there are new:</p> <pre><code>0a:ce:c4:f7:cb:dc dst 10.2.1.12 self\n00:00:00:34:8d:90 dst 10.2.1.12 self\n</code></pre> <p>These new entries:</p> <ul> <li>Add our new instance to the mesh (00:00:00:34:8d:90)</li> <li>And add vxlan-2 on sf-2 to the mesh (0a:ce:c4:f7:cb:dc)</li> </ul> <p>To repeat some commands from above but on sf-2, we now have two new network interfaces over there:</p> <pre><code>sf-2 # ip addr list vxlan-2\n127: vxlan-2: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 8950 qdisc noqueue master br-vxlan-2 state UNKNOWN group default qlen 1000\n    link/ether 0a:ce:c4:f7:cb:dc brd ff:ff:ff:ff:ff:ff\n    inet6 fe80::8ce:c4ff:fef7:cbdc/64 scope link\n       valid_lft forever preferred_lft forever\n\nsf-2 # ip addr show br-vxlan-2\n128: br-vxlan-2: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 8950 qdisc noqueue state UP group default qlen 1000\n    link/ether 0a:ce:c4:f7:cb:dc brd ff:ff:ff:ff:ff:ff\n    inet6 fe80::8ce:c4ff:fef7:cbdc/64 scope link\n       valid_lft forever preferred_lft forever\n</code></pre> <p>And the mesh looks like this:</p> <pre><code>sf-2 # bridge fdb show brport vxlan-2\n0a:ce:c4:f7:cb:dc master br-vxlan-2 permanent\n0a:ce:c4:f7:cb:dc vlan 1 master br-vxlan-2 permanent\n00:00:00:00:00:00 dst 10.2.1.11 self permanent\n00:00:00:00:00:00 dst 10.2.1.12 self permanent\n0a:ce:c4:f7:cb:dc dst 127.0.0.1 self\n00:00:00:34:8d:90 dst 127.0.0.1 self\ne2:2d:32:6d:95:70 dst 10.2.1.11 self\n</code></pre> <p>There is no network namespace on sf-2:</p> <pre><code>sf-2 # ls /var/run/netns\nls: cannot access '/var/run/netns': No such file or directory\n</code></pre> <p>If we grep the console log of the instance on sf-2, we can see what cloud-init thought about the networking:</p> <pre><code>sf-1 # grep ci-info /srv/shakenfist/instances/d53b345f-9d5d-493c-a1a3-7e7d6513cfa2/console.log\n[    9.851378] cloud-init[643]: ci-info: +++++++++++++++++++++++++++++++++++++Net device info++++++++++++++++++++++++++++++++++++++\n[    9.856401] cloud-init[643]: ci-info: +--------+------+---------------------------+---------------+--------+-------------------+\n[    9.858628] cloud-init[643]: ci-info: | Device |  Up  |          Address          |      Mask     | Scope  |     Hw-Address    |\n[    9.862566] cloud-init[643]: ci-info: +--------+------+---------------------------+---------------+--------+-------------------+\n[    9.873611] cloud-init[643]: ci-info: |  eth0  | True |        192.168.0.3        | 255.255.255.0 | global | 00:00:00:34:8d:90 |\n[    9.884575] cloud-init[643]: ci-info: |  eth0  | True | fe80::200:ff:fe34:8d90/64 |       .       |  link  | 00:00:00:34:8d:90 |\n[    9.896315] cloud-init[643]: ci-info: |   lo   | True |         127.0.0.1         |   255.0.0.0   |  host  |         .         |\n[    9.899272] cloud-init[643]: ci-info: |   lo   | True |          ::1/128          |       .       |  host  |         .         |\n[    9.904106] cloud-init[643]: ci-info: +--------+------+---------------------------+---------------+--------+-------------------+\n[    9.907816] cloud-init[643]: ci-info: +++++++++++++++++++++++++++++Route IPv4 info+++++++++++++++++++++++++++++\n[    9.912118] cloud-init[643]: ci-info: +-------+-------------+-------------+---------------+-----------+-------+\n[    9.913889] cloud-init[643]: ci-info: | Route | Destination |   Gateway   |    Genmask    | Interface | Flags |\n[    9.917853] cloud-init[643]: ci-info: +-------+-------------+-------------+---------------+-----------+-------+\n[    9.920102] cloud-init[643]: ci-info: |   0   |   0.0.0.0   | 192.168.0.1 |    0.0.0.0    |    eth0   |   UG  |\n[    9.926243] cloud-init[643]: ci-info: |   1   | 192.168.0.0 |   0.0.0.0   | 255.255.255.0 |    eth0   |   U   |\n[    9.929182] cloud-init[643]: ci-info: +-------+-------------+-------------+---------------+-----------+-------+\n[    9.935249] cloud-init[643]: ci-info: +++++++++++++++++++Route IPv6 info+++++++++++++++++++\n[    9.942774] cloud-init[643]: ci-info: +-------+-------------+---------+-----------+-------+\n[    9.956377] cloud-init[643]: ci-info: | Route | Destination | Gateway | Interface | Flags |\n[    9.959651] cloud-init[643]: ci-info: +-------+-------------+---------+-----------+-------+\n[    9.965082] cloud-init[643]: ci-info: |   1   |  fe80::/64  |    ::   |    eth0   |   U   |\n[    9.968116] cloud-init[643]: ci-info: |   3   |    local    |    ::   |    eth0   |   U   |\n[    9.970423] cloud-init[643]: ci-info: |   4   |   ff00::/8  |    ::   |    eth0   |   U   |\n[    9.974926] cloud-init[643]: ci-info: +-------+-------------+---------+-----------+-------+\nci-info: no authorized SSH keys fingerprints found for user ubuntu.\n[   69.743452] cloud-init[970]: ci-info: no authorized SSH keys fingerprints found for user ubuntu.\n</code></pre> <p>Here you can see that instance has an interface named eth0, which has the IP address that Shaken Fist allocated earlier. How did it get an IP address without DHCP? Well, Shaken Fist always attaches a config drive to the instance, and this contains a JSON file with the IP address in it. cloud-init running on boot of Ubuntu has used this to configure the interface. Before we poke more at this instance, let's start another instance on sf-3 so we can do some more testing...</p>"},{"location":"user_guide/affinity/","title":"Affinity","text":"<p>There are times when you want to express a preference (or anti-preference) for two instances sharing a hypervisor. For example, you might have two IO intensive instances and want to keep them apart, or you might have two instances which talk a lot over the network to each other and want to keep them together.</p> <p>Shaken Fist supports a simple affinity system for this use case. The system is built on top of an instance metadata entry called <code>tags</code>, where you specify the attributes of the instance. This metadata entry must be formatted as a valid JSON list. So for example we might set the following simple tag on an instance:</p> <pre><code>[\"webserver\"]\n</code></pre> <p>Or on the command line:</p> <p><code>sf-client instance set-metadata ...uuid... tags '[\"webserver\"]'</code></p> <p>Affinity is then set via the <code>affinity</code> metadata entry, and consists of a JSON dictionary specifying the weight to give to a given tag in scheduling decisions. In our current example, let's say we want to try quite hard to not have more than one of our web servers on a given hypervisor. We might therefore write an affinity metadata entry like this:</p> <pre><code>{\n    \"webserver\": -10\n}\n</code></pre> <p>Or on the command line:</p> <p><code>sf-client instance set-metadata ...uuid... affinity '{\"webserver\": -10}'</code></p> <p>There are no fixed rules for what the maximum and minimum numbers for this preference value are, although generally we recommend they range from -100 to 100, where 100 means you'd really really love to be on the same hypervisor, and -100 means you'd be very unhappy to be on the same hypervisor.</p> Info <p>Under the hood, Shaken Fist filters possible candidate hypervisors based on the affinity coefficients specified. Only tags from within your namespace are considered for this filtration. This decision is only made on the original start up of an instance, and does not apply later. That is, if you change the tags or affinity of an instance after instance creation it will not affect that instance in any way, although it might affect scheduling decisions for future instances.</p> <p>You can of course have more than one tag and affinity preference set at a time. So to extend our example, let's say that web servers do not prefer sharing with other web servers, but do like sharing with a cache server. You might write that like this:</p> <pre><code>{\n    \"webserver\": -10,\n    \"cache\": 10\n}\n</code></pre> <p>Or on the command line:</p> <p><code>sf-client instance set-metadata ...uuid... affinity '{\"webserver\": -10, \"cache\": 10}'</code></p> <p>Shaken Fist emits a series of events while making a scheduling decision for an instance, and those events are useful for debugging affinity operations. You can see the events for an instance with this command:</p> <p><code>sf-client instance events ...uuid...</code></p> <p>You can of course see the currently set metadata for an instance with the <code>sf-client instance show</code> command.</p>"},{"location":"user_guide/artifacts/","title":"Artifacts","text":"<p>Shaken Fist uses artifacts as disk templates for new instances. You therefore need to have a least one artifact before you can create your first instance, although there is a shorthand notation to create that artifact during instance creation.</p> <p>The following artifact types exist:</p> <ul> <li>images: these are generally downloaded from the Internet, although they can   also be created via an upload mechanism (see the artifact uploads section below   for a detailed introduction to uploading images to the cluster).</li> <li>snapshots: these are created by taking a copy of the disk(s) of a running   instance.</li> <li>labels: labels are a bit like symbolic links, although they still have   versioning like other forms of artifact.</li> <li>other: a catch all for artifacts which don't fall into any of the other   categories. For example captured instance console output archived after an   instance was deleted.</li> </ul> <p>Behind the scenes, artifacts are references to blobs. You can think of them as symlinks if you'd like. All types of artifact support versioning. This is implemented by having each artifact have a list of blobs. You can see this in the output of a <code>sf-client artifact show ...</code> command:</p> <pre><code>$ sf-client artifact show 3420f4ac-529a-4b34-b8d8-c05a838b9e0c\nuuid                     : 3420f4ac-529a-4b34-b8d8-c05a838b9e0c\nnamespace                : ci-images\ntype                     : label\nstate                    : created\nsource url               : sf://label/ci-images/debian-11\ncurrent version blob uuid: cc6a6a96-8182-474a-ab31-45f1f9310b44\nnumber of versions       : 3\nmaximum versions         : 3\nshared                   : False\n\nVersions:\n    4  : blob f6090574-321c-4dec-b381-0caf001eeba5 is 2964.1MB\n    5  : blob 77b9032a-0d3e-4cc2-bb73-1730ad3c3cb0 is 2960.1MB\n    6  : blob cc6a6a96-8182-474a-ab31-45f1f9310b44 is 2950.4MB in use by\n         instances 78d566f1-c664-46d9-aa46-cf717aa63743\n</code></pre> <p>Here we can see a few things:</p> <ul> <li>The artifact is a label in the ci-images namespace.</li> <li>There is a source URL, which is how you would reference this artifact when   starting an instance.</li> <li>There are three versions of the artifact currently stored (<code>number of versions</code>),   which is the maximum (<code>maximum versions</code>). However, there have been six versions   of this artifact ever (as shown by the indices of the versions being 4, 5, and   6).</li> <li>The most recent version is currently in use by an instance.</li> </ul>"},{"location":"user_guide/artifacts/#creating-an-image-artifact","title":"Creating an image artifact","text":"<p>Image artifacts are created by specifying the URL of an image to download. This can be either in the form of an explicit request to cache a URL with a <code>sf-client artifact cache</code> command, or implied by specifying the URL of the image in the specification for an instance.</p> <p>There is also a shorthand form of image URLs where you are using an image from https://images.shakenfist.com -- in that case you can use urls like <code>debian:11</code> so specify the latest version of a Debian 11 base image. The valid shorthands are those listed in the top level directory listing of that site. At the time of writing this is:</p> <ul> <li>centos (shorthand for centos:8-stream)</li> <li>centos:7</li> <li>centos:8-stream</li> <li>debian (shorthand for debian:11)</li> <li>debian:10</li> <li>debian:11</li> <li>ubuntu (shorthand for ubuntu:20.04)</li> <li>ubuntu:18.04</li> <li>ubuntu:20.04</li> </ul> <p>These images are updated nightly by an automated job from https://github.com/shakenfist/images.</p> <p>Whenever you specify a URL for an image (either a new <code>cache</code> command or at instance start), the URL is checked. If the image has changed a new version is downloaded, otherwise the already cached version is used.</p> <p>You can also create an image artifact by uploading it, but that's complicated enough that its covered separately in the developer guide section on artifacts.</p>"},{"location":"user_guide/artifacts/#creating-a-snapshot-artifact","title":"Creating a snapshot artifact","text":"<p>These are created by the <code>sf-client instance snapshot</code> command. You can specify which disk to snapshot on a multi-disk instance with the <code>--device</code> flag. Repeated snapshots of the same instance will result in multiple versions of the one artifact being created. Note that there is an artifact per device snapshotted, so a single snapshot of a multi-disk instance will create multiple artifacts.</p>"},{"location":"user_guide/artifacts/#creating-label-artifacts","title":"Creating label artifacts","text":"<p>So what's a label? Well downloading new versions of images automatically is great, but what if I want to ensure the version from two weeks ago that I tested is the one I use? Or what if I want to refer to my favourite instance snapshot by something more convenient than a snapshot URL like <code>sf://instance/78d566f1-c664-46d9-aa46-cf717aa63743/vda</code>? Well, labels are the answer to those questions.</p> <p>Labels are artifacts where you specify what the new version should be. So in the download example you'd test an image version and when you decide that its right, you'd add that version's blob UUID to your label of known tested versions.</p> <p>Blobs are reference counted, so even if the image artifact ages out a version, having that version referred to in a label artifact protects it from deletion.</p> <p>An example of labelling a known good version of an artifact would be something like this:</p> <pre><code>$ sf-client artifact show 3420f4ac-529a-4b34-b8d8-c05a838b9e0c\nuuid                     : 3420f4ac-529a-4b34-b8d8-c05a838b9e0c\nnamespace                : ci-images\ntype                     : label\nstate                    : created\nsource url               : sf://label/ci-images/debian-11\ncurrent version blob uuid: cc6a6a96-8182-474a-ab31-45f1f9310b44\nnumber of versions       : 3\nmaximum versions         : 3\nshared                   : False\n\nVersions:\n    4  : blob f6090574-321c-4dec-b381-0caf001eeba5 is 2964.1MB\n    5  : blob 77b9032a-0d3e-4cc2-bb73-1730ad3c3cb0 is 2960.1MB\n    6  : blob cc6a6a96-8182-474a-ab31-45f1f9310b44 is 2950.4MB in use by\n         instances 78d566f1-c664-46d9-aa46-cf717aa63743\n\n...test version 6 with blob UUID cc6a6a96-8182-474a-ab31-45f1f9310b44...\n\n$ sf-client label update my-tested-thing cc6a6a96-8182-474a-ab31-45f1f9310b44\n</code></pre> <p>If the label <code>my-tested-thing</code> does not exist, it will be created the first time you update it.</p>"},{"location":"user_guide/artifacts/#listing-and-deleting-artifacts","title":"Listing and deleting artifacts","text":"<p>Artifacts follow the same user interface patterns as other objects. That is, you can list artifacts with this command:</p> <p><code>sf-client artifact list</code></p> <p>And you can delete artifacts with a command like this:</p> <p><code>sf-client artifact delete ...name.or.uuid...</code></p> <p>Note that deleting an artifact does not necessarily imply deleting the associated blobs. If those blobs are in use by other objects (artifacts, instances, and so on) then they remain stored by the cluster until there are no remaining references.</p> <p>Additionally, you can also delete all artifacts in a given namespace by making a HTTP DELETE request to /artifacts REST API endpoint, which is also provided by the <code>delete_all_artifacts()</code> method in the Python API client. This functionality is not currently exposed in the command line client.</p> <p>Finally, deleting a namespace implies deleting all artifacts within that namespace, so show care when deleting namespaces to ensure they no longer contain any data you are fond of.</p>"},{"location":"user_guide/artifacts/#controlling-the-number-of-versions","title":"Controlling the number of versions","text":"<p>You can also control the number of versions stored by an artifact with the <code>sf-client artifact max-versions</code> command.</p>"},{"location":"user_guide/artifacts/#blob-replication","title":"Blob replication","text":"<p>You can control the number of copies of a given blob are stored in the cluster as well. This protects against machine or disk failures causing data loss. The default number of replicas is 2, but this is not configurable per-blob. It is configured with the <code>BLOB_REPLICATION_FACTOR</code> configuration variable.</p>"},{"location":"user_guide/artifacts/#artifact-uploads-and-downloads","title":"Artifact uploads and downloads","text":"<p>Artifacts may also be uploaded and downloaded. This means you can extract a snapshot from your cluster for offline backup (or movement to another cloud), or upload an image built with a tool like Hashicorp Packer.</p> <p>To upload an artifact, use the <code>sf-client artifact upload</code> command. To download an artifact, use the <code>sf-client artifact download</code> command.</p> <p>Shaken Fist will calculate a checksum for the new blob created by an upload, and if it already has a blob matching that checksum it will only store the data once. This makes uploading a given artifact more than once effectively free apart from a small amount of etcd storage.</p>"},{"location":"user_guide/authentication/","title":"Authentication","text":"<p>While there is a detailed discussion of the Shaken Fist authentication system in the developer guide, that is likely more detail than a day to day user of Shaken Fist is interested in. This page therefore provides the details in a simpler and more direct form.</p> <p>As a user of Shaken Fist, the administrator of the cluster you are using will have created a namespace to contain the resources you create in Shaken Fist. This namespace can have several authentication keys associated with it, which are simply strings you pass to Shaken Fist to prove your identity, much like API keys for GitHub or other web services. Normally your administrator will create a key per user, but its also possible to create a key per system -- there are not real rules imposed by Shaken Fist on when you should create a key not reuse an existing one.</p> <p>For most users, this key will be provided in the form of a file you should place at <code>.shakenfist</code> in your home direct. An example file might be:</p> <pre><code>{\n    \"namespace\": \"mynamespace\",\n    \"key\": \"oisoSe7T\",\n    \"apiurl\": \"https://shakenfist/api\"\n}\n</code></pre> <p>This file specifies your namespace, the key you will use to authenticate, and the location of the API server for that Shaken Fist cluster.</p> <p>Once you have that file in the correct location, the the Shaken Fist command line client and API client will function correctly with no further configuration required.</p>"},{"location":"user_guide/consoles/","title":"Consoles","text":"<p>Shaken Fist supports three types of instance consoles. This page describes each of those consoles and their functionality.</p>"},{"location":"user_guide/consoles/#read-only-serial-console","title":"Read only serial console","text":"<p>Similarly to OpenStack, we support requesting a read only copy of the content of the serial console via our REST API. This console is based off a log of console activity, so can return events which have already occurred. You can access the console information from the command line like this:</p> <pre><code>sf-client instance consoledata ca8b3e3b-f681-47a2-99c5-6ddea00cc49f 1000\n[530]: |                       Self-hosted runner registration                        |\n[   74.594732] cloud-init[530]: |                                                                              |\n[   74.596442] cloud-init[530]: --------------------------------------------------------------------------------\n[   74.602452] cloud-init[530]: # Authentication\n[   79.099457] cloud-init[530]: \u221a Connected to GitHub\n[   79.184807] cloud-init[530]: # Runner Registration\n[   80.283666] cloud-init[530]: \u221a Runner successfully added\n[   83.608069] cloud-init[530]: \u221a Runner connection is good\n[   83.609389] cloud-init[530]: # Runner settings\n[   83.615351] cloud-init[530]: \u221a Settings Saved.\n[   86.194598] cloud-init[530]: \u221a Connected to GitHub\n[   87.331467] cloud-init[530]: Current runner version: '2.299.1'\n[   87.333703] cloud-init[530]: 2023-01-21 06:54:11Z: Listening for Jobs\n[   91.102179] cloud-init[530]: 2023-01-21 06:54:15Z: Running job: ubuntu-2004-slim-primary\n</code></pre> <p>The final argument is optional. In this example we are requesting the final 1,000 bytes of console output.</p>"},{"location":"user_guide/consoles/#interactive-serial-console","title":"Interactive serial console","text":"<p>There is also interactive access to that same serial console, although it requires direct network access to the hypervisor node at the moment. If you lookup the instance with a show command, you'll see a \"console port\" listed:</p> <pre><code>sf-client instance show c301ad4a-1ad4-49d7-b1e7-cb08ad3bf23d\nuuid          : c301ad4a-1ad4-49d7-b1e7-cb08ad3bf23d\nname          : sfcbr-s2SXNcZGKaJMywSd\n...\nnode          : sf-2\nconsole port  : 30049\nvdi port      : 37804\n...\n</code></pre> <p>If you telnet to the console port on the hypervisor node's IP, you'll land in an interactive console for the instance. So in this example:</p> <pre><code>telnet sf-2 30049\n</code></pre>"},{"location":"user_guide/consoles/#archival-of-the-serial-console","title":"Archival of the serial console","text":"<p>Optionally, the content of the serial console can be archived when an instance is deleted. This is useful for debugging ephemeral instances which might have been deleted by the time you notice a problem -- for example instances used for Continuous Integration environments.</p> <p>The time the serial console is kept for is configured with the ARCHIVE_INSTANCE_CONSOLE_DURATION configuration variable, which specifies how many days to keep the console for. On instance deletion, the console log is converted to an artifact and stored as any other. These artifacts have type 'other', and will have a source URL in the form of sf://instance/...uuid.../console within the same namespace as the instance. Set ARCHIVE_INSTANCE_CONSOLE_DURATION to 0 to disable this behavior.</p>"},{"location":"user_guide/consoles/#interactive-vdi-console","title":"Interactive VDI console","text":"<p>There is also a graphical console. Similarly to the telnet console, it requires direct network access to the hypervisor node, and is accessed at the \"vdi port\" TCP port. By default this console is SPICE since v0.7, although VNC is also available.</p> <p>You can select from 'vnc' or 'spice' by setting the <code>vdi</code> argument in your video specification for the instance. If you set <code>vdi=spice-concurrent</code>, then experimental support for multiple users accessing the same SPICE console at the same time is enabled. For more details about the experimental nature of concurrent SPICE consoles, see https://www.spice-space.org/multiple-clients.html.</p> <p>And example video specification would be:</p> <pre><code>--video model=qxl,memory=65536,vdi=spiceconcurrent\n</code></pre>"},{"location":"user_guide/events/","title":"Events","text":"<p>Events are Shaken Fist's audit log mechanism. Many operations, ranging from creation and subsequent use of an authentication token, to any change in the data for an object, will result in an event being created in the event log for the relevant object. Importantly, regular \"usage events\" are also emitted, which we expect would form the basis for a consumption based billing system.</p> <p>Events may be requested using the <code>sf-client ...object... events</code> command, for example <code>sf-client artifact events ...uuid...</code> will return the events for the relevant artifact.</p> <p>The schema for events is still in flux, so be careful implementing automated systems which consume events. This will remain true until we are more confident that all relevant audit lock events are being collected. At that point we will standardize and stabilize the interface.</p> <p>As of v0.7, each event log entry has a type. The currently implemented types are:</p> <ul> <li>audit: audit log entries such as object creation or deletion, and authentication.</li> <li>mutate: object modifications which are not an audit log entry, such as minor updates.</li> <li>status: status messages useful to a user, such as progress of fetching an image.</li> <li>usage: billing information.</li> <li>resources: cluster resource usage information of interest to an operator.</li> <li>prune: messages relating to pruning of other message types.</li> <li>historic: events from before the type system was introduced.</li> </ul> <p>For each of these types, an operator can configure a retention period. The default periods are:</p> <ul> <li>audit (MAX_AUDIT_EVENT_AGE): 90 days.</li> <li>mutate (MAX_MUTATE_EVENT_AGE): 90 days.</li> <li>status (MAX_STATUS_EVENT_AGE): 7 days.</li> <li>usage (MAX_USAGE_EVENT_AGE): 30 days.</li> <li>resources (MAX_RESOURCES_EVENT_AGE): 7 days.</li> <li>prune (MAX_PRUNE_EVENT_AGE): 30 days.</li> <li>historic (MAX_HISTORIC_EVENT_AGE): 90 days.</li> </ul> <p>To permanently retain a type of event log entry, set the corresponding configuration value to -1.</p>"},{"location":"user_guide/metadata/","title":"Object metadata","text":"<p>All objects in Shaken Fist support a simple metadata system. This system is presented as a series of key, value pairs which are stored against the relevant object. A worked example can be seen in the description of instance affinity which requires specific keys and formats for their values, but you're not limited to that -- other keys can have data of any format that you can express in an API call.</p> Note <p>It is not intended that you store large amounts of data in a metadata key. If you want to store more than a couple of kilobytes in a value, then instead store a reference to an external system or a blob which contains the data.</p> <p>You can set a metadata key's value on the command line like this:</p> <p><code>sf-client instance set-metadata ...uuid... key-name key-value</code></p> <p>Metadata values are show in the <code>show</code> output for the various object types, and there is no separate command to look them up. You can also delete a metadata key like this:</p> <p><code>sf-client instance delete-metadata ...uuid... key-name</code></p>"},{"location":"user_guide/objects/","title":"Objects","text":"<p>Everything that you interact with in Shaken Fist is an object. Objects are almost always referred to by a UUID (specifically a version 4 UUID) as a string. The exceptions are: <code>node</code>s; <code>namespace</code>s; and <code>key</code>s within a namespace.</p> <p>In general an object is referred to in the API or on the command line \"by reference\", which means you can either pass the object's name or its UUID to the command. So for example if we had an instance with the UUID 0a38d51e-2f72-4848-80fb-03031978633b named \"mikal\", then we could run either of the commands below to the same effect:</p> <pre><code>sf-client instance show 0a38d51e-2f72-4848-80fb-03031978633b\nsf-client instance show mikal\n</code></pre> <p>In the case where you refer to an object by name, a lookup occurs of all objects visible to you (those in your namespace, and namespaces that trust your namespace). Additionally, shared artifacts are included if you're using an artifact command.</p> <p>It is possible that the name you're using isn't unique. For example there might be two instances named \"mikal\" with different UUIDs. In that case, you will get an error indicating that there was more than one object which matched, and you'll need to use a UUID to refer to the object.</p>"},{"location":"user_guide/usage/","title":"Clients","text":"<p>There is a command line client called \"sf-client\" deployed by ansible. It talks to Shaken Fist via a REST API. There is also a python API client library at shakenfist.clients.apiclient, which is what the command line client uses to call the API. The apiclient module also serves as useful example code for how to write your own client.</p> <p>The command line client can produce output in three formats: the standard \"pretty\" format, a mostly-csv format called \"simple\" (which is aimed at being easy to parse in shell scripts), and JSON. You select the output format with a flag like this:</p> <pre><code>sf-client --simple instance list\n</code></pre> <p>The default formatter is the \"pretty\" formatter, so you never need to specify that on the command line.</p> <p>You can explore what the command line client is capable of by asking it for help:</p> <pre><code>sf-client --help\n</code></pre>"},{"location":"user_guide/usage/#networking","title":"Networking","text":"<p>Virtual networks / micro segmentation is provided by VXLAN meshes between the instances. Hypervisors are joined to a given mesh when they start their first instance on that network. DHCP services are optionally offered from a \"network services\" node, which is just a hypervisor node with some extra dnsmasq process. NAT is also optionally available from the network services node. If your network provides NAT, it consumes an IP address from the floating IP pool to do so, and performs NAT in a network namespace on the network node.</p> <p>You create a network on the command line like this:</p> <pre><code>sf-client network create mynet 192.168.1.0/24\n</code></pre> <p>Where \"192.168.1.0/24\" is the netblock to use, and \"mynet\" is the name of the network. You'll get back output describing the network, including the UUID of the network, which is used in later calls.</p>"},{"location":"user_guide/usage/#instances","title":"Instances","text":"<p>Every instance gets a config drive. Its always an ISO9660 drive. It's always the second virtual disk attached to the VM (vdb on Linux). There is no metadata server. Additionally, there is no image service -- you specify the image to use by providing a URL. That URL is cached, but can be to any HTTP server anywhere. Even better, there are no flavors. You specify what resources your instance should have at boot time and that's what you get. No more being forced into a t-shirt sized description of your needs.</p> <p>Instances are always cattle. Any feature that made instances feel like pets has not been implemented. That said, you can snapshot an instance. Snapshots aren't reliable backups, just like they're not really reliable backups on OpenStack. There is a small but real chance that a snapshot will contain an inconsistent state if you're snapshotting a busy database or something like that. One minor difference from OpenStack -- when you snapshot your instance you can snapshot all of the virtual disks (except the config drive) if you want to. Snapshots are delivered as files you can download via a mechanism external to Shaken Fist (for example an HTTP server pointed at the snapshot directory).</p> <p>You start an instance like this:</p> <pre><code>sf-client instance create \"myinstance\" 1 2048 -d 8@cirros -n netuuid\n</code></pre> <p>Where \"myinstance\" is the name of the instance, it has 1 vCPU, 2048MB of RAM, a single 8gb disk (more on this in a second) and a single network interface on the network with the UUID \"netuuid\".</p> <p>\"8@cirros\" is a \"short disk specification\". These are in the form size@image, where the @image is optional. You can specify more than one disk, so this is valid:</p> <pre><code>sf-client instance create \"myinstance\" 1 2048 -d 8@cirros -d 8 -d 8 -n netuuid\n</code></pre> <p>In this case we have three disks, all of 8gb. The boot disk is imaged with cirros. The \"cirros\" here is shorthand. By default, you specify a URL for the image you want, so to boot a cirros instance you might use http://download.cirros-cloud.net/0.5.1/cirros-0.5.1-x86_64-disk.img -- that gets old though, so for common cloud images there is a shorthand format, where Shaken Fist knows how to generate the download URL from a short description. In this case \"cirros\" means \"the latest release of cirros\". You can also specify a version like this:</p> <pre><code>sf-client instance create \"myinstance\" 1 2048 -d 8@cirros:0.5.1 -d 8 -d 8 -n netuuid\n</code></pre> <p>\"Common cloud images\" is currently defined as cirros and Ubuntu. You can also use a \"detailed disk specification\", which is what fancy people use. Its syntax is similar:</p> <pre><code>sf-client instance create \"myinstance\" 1 2048 -D size=8,base=cirros,bus=ide,type=cdrom -d 8 -d 8 -n netuuid\n</code></pre> <p>The specification is composed of a series of key-value pairs. Valid keys are: size; base; bus; and type. If you don't specify a key, you'll get a reasonable default. Here's how the keys work:</p> <ul> <li>size as per the shorthand notation.</li> <li>base as per the shorthand notation, including version specification.</li> <li>bus is any valid disk bus for libvirt, which is virtio, ide, scsi, usb. Use virtio unless you have a really good reason otherwise -- the performance of the others are terrible. An example of a good reason is to install virtio drivers into legacy operating systems that lack them natively.</li> <li>type can be one of disk or cdrom. Note that cdroms are excluded from snapshots.</li> </ul> <p>Similarly, networks have a \"short network specification\", where you can specify the UUID of a network, but also optionally the IP address to use for the interface. You can also have more than one network interface, so this is valid:</p> <pre><code>sf-client instance create \"myinstance\" 1 2048 -d 8@cirros -n netuuid1 \\\n-n netuuid2@10.0.0.4\n</code></pre> <p>There is also a shorthand \"short network specification\" which implies immediately floating the interface. The details are the same as -n, except the flag is -f:</p> <pre><code>sf-client instance create \"myinstance\" 1 2048 -d 8@cirros -f netuuid1\n</code></pre> <p>There is a \"detailed network specification\" as well, which is composed of the following keys:</p> <ul> <li>network_uuid is the UUID of the network to use.</li> <li>address is the IPv4 network address to use, if free. If its not free the instance will fail to start. If you don't want an address on this interface, use \"none\" as the value for address. If you do not specify any value for address, an address on the network will be assigned to you.</li> <li>macaddress the mac address to use for the interface.</li> <li>model is the model of the network device, with options being ne2k_isa, i82551, i82557b, i82559er, ne2k_pci, pcnet, rtl8139, e1000, and virtio. The default model is virtio.</li> <li>float if true indicates to immediately float the interface once the instance is created.</li> </ul>"},{"location":"user_guide/usage/#missing-documentation","title":"Missing documentation","text":"<p>I really should document these as well:</p> <ul> <li>nodes</li> <li>networks: delete, list</li> <li>instance: show, delete, list, ssh keys, user data, reboots (hard and soft), poweroff, poweron, pause, unpause, snapshot</li> <li>images: pre-caching</li> <li>metadata</li> <li>authentication</li> </ul> <p>Maybe one day I will.</p>"}]}