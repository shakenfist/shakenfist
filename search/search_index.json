{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Shaken Fist, a minimal cloud aimed at small and edge deployments For at least six months I\u2019ve felt the desire for a simpler cloud orchestration layer \u2014 both for my own personal uses, and also as a test bed for ideas for what a smaller, simpler cloud might look like. My personal use case involves a relatively small environment which echos what we now think of as edge compute \u2014 less than 10 RU of machines with a minimum of orchestration and management overhead. At the time that I was thinking about these things, the Australian bushfires and COVID-19 came along, and presented me with a lot more spare time than I had expected to have. While I\u2019m still blessed to be employed, all of my social activities have been cancelled, so I find myself at home at a loose end on weekends and evenings a lot more than before. Thus Shaken Fist was born \u2014 named for a Simpson\u2019s meme, Shaken Fist is a deliberately small and highly opinionated cloud implementation aimed at working well in small deployments such as homes, labs, edge compute locations, deployed systems, and so forth. I\u2019d taken a bit of trouble with each feature in Shaken Fist to think through what the simplest and highest value way of doing something is. For example, instances always get a config drive and there is no metadata server. There is also only one supported type of virtual networking, and one supported hypervisor. That said, this means Shaken Fist is less than 5,000 lines of code, and small enough that new things can be implemented very quickly by a single middle aged developer. I think Shaken Fist is useful to others. Its apache2 licensed, and available on github if you\u2019re interested. \"I'd like to subscribe to your newsletter\" First off, we don't have a newsletter. That said, updates will be announced here as they happen. What we do have is useful links: The deploy repository is the installer code for Shaken Fist, and probably a good place to start, especially if you just want to use Shaken Fist and not contribute code to it. The Shaken Fist repository is where the code for the server is. There are a series of client repositories as well: The python client repostiory contains the python API client, as well as the command line client that users and shell scripts use to interact with Shaken Fist. The golang client repository contains... wait for it... the golang client library. This is used by the terraform provider. The javascript client repository contains... wait for it... a javascript client library. It should be noted that this client is currently incomplete. The terraform provider repository has a Terraform provider for Shaken Fist which uses the golang client. The ansible modules repository contains a few simple modules for using Shaken Fist in ansible roles and plays. We also have a few \"more internal\" respositories: The loadtest repository contains a simpler load tester we use for validating releases. The reproducables repository contains simple test cases for reproducing strange behaviours we have seen while developing Shaken Fist. New user guides We need more of these. For now, we have the following: An installation guide Release changelogs Version v0.2 was when we started taking releases and upgrades seriously. Thus, its also when we started writing changelogs: v0.2 series v0.3 series API documentation There is some limited API documentation, its definitely a known gap. The power states an instance can be in Documentation for developers of Shaken Fist We have release documentation . We found this mildly surprising too. Everyone is confused by the networking, so we wrote some networking documentation . Hopefully it helps.","title":"Introduction"},{"location":"#shaken-fist-a-minimal-cloud-aimed-at-small-and-edge-deployments","text":"For at least six months I\u2019ve felt the desire for a simpler cloud orchestration layer \u2014 both for my own personal uses, and also as a test bed for ideas for what a smaller, simpler cloud might look like. My personal use case involves a relatively small environment which echos what we now think of as edge compute \u2014 less than 10 RU of machines with a minimum of orchestration and management overhead. At the time that I was thinking about these things, the Australian bushfires and COVID-19 came along, and presented me with a lot more spare time than I had expected to have. While I\u2019m still blessed to be employed, all of my social activities have been cancelled, so I find myself at home at a loose end on weekends and evenings a lot more than before. Thus Shaken Fist was born \u2014 named for a Simpson\u2019s meme, Shaken Fist is a deliberately small and highly opinionated cloud implementation aimed at working well in small deployments such as homes, labs, edge compute locations, deployed systems, and so forth. I\u2019d taken a bit of trouble with each feature in Shaken Fist to think through what the simplest and highest value way of doing something is. For example, instances always get a config drive and there is no metadata server. There is also only one supported type of virtual networking, and one supported hypervisor. That said, this means Shaken Fist is less than 5,000 lines of code, and small enough that new things can be implemented very quickly by a single middle aged developer. I think Shaken Fist is useful to others. Its apache2 licensed, and available on github if you\u2019re interested.","title":"Shaken Fist, a minimal cloud aimed at small and edge deployments"},{"location":"#id-like-to-subscribe-to-your-newsletter","text":"First off, we don't have a newsletter. That said, updates will be announced here as they happen. What we do have is useful links: The deploy repository is the installer code for Shaken Fist, and probably a good place to start, especially if you just want to use Shaken Fist and not contribute code to it. The Shaken Fist repository is where the code for the server is. There are a series of client repositories as well: The python client repostiory contains the python API client, as well as the command line client that users and shell scripts use to interact with Shaken Fist. The golang client repository contains... wait for it... the golang client library. This is used by the terraform provider. The javascript client repository contains... wait for it... a javascript client library. It should be noted that this client is currently incomplete. The terraform provider repository has a Terraform provider for Shaken Fist which uses the golang client. The ansible modules repository contains a few simple modules for using Shaken Fist in ansible roles and plays. We also have a few \"more internal\" respositories: The loadtest repository contains a simpler load tester we use for validating releases. The reproducables repository contains simple test cases for reproducing strange behaviours we have seen while developing Shaken Fist.","title":"\"I'd like to subscribe to your newsletter\""},{"location":"#new-user-guides","text":"We need more of these. For now, we have the following: An installation guide","title":"New user guides"},{"location":"#release-changelogs","text":"Version v0.2 was when we started taking releases and upgrades seriously. Thus, its also when we started writing changelogs: v0.2 series v0.3 series","title":"Release changelogs"},{"location":"#api-documentation","text":"There is some limited API documentation, its definitely a known gap. The power states an instance can be in","title":"API documentation"},{"location":"#documentation-for-developers-of-shaken-fist","text":"We have release documentation . We found this mildly surprising too. Everyone is confused by the networking, so we wrote some networking documentation . Hopefully it helps.","title":"Documentation for developers of Shaken Fist"},{"location":"installation/","text":"Installing Shaken Fist This guide will assume that you want to install Shaken Fist on a single local machine (that is, the one you're going to run ansible on). This is by no means the only installation option, but is the most simple to get people started. There is additional detail in the README.md file of the deploy repository if you need more help. Shaken Fist only supports Ubuntu 18.04 or later, so if you're running on localhost that implies that you must be running a recent Ubuntu on your development machine. Note as well that the deployer installs software and changes the configuration of your networking, so be careful when running it on machines you are fond of. Create a directory for Shaken Fist, and then checkout the deployer git repository there: mkdir shakenfist cd shakenfist git clone https://github.com/shakenfist/deploy cd deploy/ansible And install some dependancies: sudo apt-get update sudo apt-get -y dist-upgrade sudo apt-get -y install ansible tox pwgen build-essential python3-dev python3-wheel curl ansible-galaxy install andrewrothstein.etcd-cluster andrewrothstein.terraform andrewrothstein.go Local Development Warning CI testing is currently destructive (don't run it against production!), and not supported for installs with fewer than three machines. It is skipped for a localhost install. We also make the assumption that developer laptops move around more than servers. In a traditional install we detect the primary NIC of the machine and then use that to build VXLAN meshes. For localhost single node deploys we instead create a bridge called \"brsf\" and then use that as our primary NIC. This means your machine can move around and have different routes to the internet over time, but it also means its fiddly to convert a localhost install into a real production cluster. Please only use localhost installs for development purposes. CLOUD=localhost ./deployandtest.sh The deployer clones a number of git repositories that it needs to build a working Shaken Fist installation. As a developer, you might want to move these out of shakenfist/deploy/gitrepos to somewhere more obvious once the installer has finished running. You can just symlink the repositories to the location that the deployer users and things will work as expected. Note that the deloyer does not clone all repositories, just those it needs, so you might still need to clone other repositories. If you want to install a specific release, you can set the RELEASE environment variable. Possible options are: Any valid pypi release version number. \"git:master\" for the current master branch of each repository. \"git:branch\" for a specific branch. If that branch does not exist in a given repository, master is used instead. Your first instance Before you can start your first instance you'll need to authenticate to Shaken Fist, and create a network. Shaken Fist's python api client (as used by the command line client) looks for authentication details in the following locations: Command line flags Environment variables (prefixed with SHAKENFIST_ ) ~/.shakenfist , a JSON formatted configuration file /etc/sf/shakenfist.json , the same file as above, but global By default the installer creates /etc/sf/sfrc , which sets the required environment variables to authenticate. It is customized per installation, setting the following variables: SHAKENFIST_NAMESPACE , the namespace to create resources in SHAKENFIST_KEY , an authentication key for that namespace SHAKENFIST_API_URL , a URL to the Shaken Fist API server Before interacting with Shaken Fist, we need to source the rc file. . /etc/sf/sfrc Instances must be launched attached to a network. Create your first network: sf-client network create 192.168.42.0/24 mynet You can get help for the command line client by running `sf-client --help . The above command creates a new network called \"mynet\", with the IP block 192.168.42.0/24. You will receive some descriptive output back: $ sf-client network create 192.168.42.0/24 mynet uuid : 16baa325-5adf-473f-8e7a-75710a822d45 name : mynet vxlan id : 2 netblock : 192.168.42.0/24 provide dhcp : True provide nat : True floating gateway: None namespace : system state : initial Metadata: The UUID is important, as that is how we will refer to the network elsewhere. Let's now create a simple first instance (you'll need to change this to use your actual network UUID): $ sf-client instance create myvm 1 1024 -d 8@cirros -n 16baa325-5adf-473f-8e7a-75710a822d45 uuid : c6c4ba94-ed34-497d-8964-c223489dee3e name : myvm namespace : system cpus : 1 memory : 1024 disk spec : type=disk bus=None size=8 base=cirros video : model=cirrus memory=16384 node : marvin power state : on state : created console port: 31839 vdi port : 34442 ssh key : None user data : None Metadata: Interfaces: uuid : e56b3c7b-8056-4645-b5b5-1779721ff21d network : 16baa325-5adf-473f-8e7a-75710a822d45 macaddr : ae:15:4d:9c:d8:c0 order : 0 ipv4 : 192.168.42.76 floating: None model : virtio Probably the easiest way to interact with this instance is to connect to its console port, which is the serial console of the instance over telnet. In the case above, that is available on port 31829 on localhost (my laptop is called marvin).","title":"Installation"},{"location":"installation/#installing-shaken-fist","text":"This guide will assume that you want to install Shaken Fist on a single local machine (that is, the one you're going to run ansible on). This is by no means the only installation option, but is the most simple to get people started. There is additional detail in the README.md file of the deploy repository if you need more help. Shaken Fist only supports Ubuntu 18.04 or later, so if you're running on localhost that implies that you must be running a recent Ubuntu on your development machine. Note as well that the deployer installs software and changes the configuration of your networking, so be careful when running it on machines you are fond of. Create a directory for Shaken Fist, and then checkout the deployer git repository there: mkdir shakenfist cd shakenfist git clone https://github.com/shakenfist/deploy cd deploy/ansible And install some dependancies: sudo apt-get update sudo apt-get -y dist-upgrade sudo apt-get -y install ansible tox pwgen build-essential python3-dev python3-wheel curl ansible-galaxy install andrewrothstein.etcd-cluster andrewrothstein.terraform andrewrothstein.go","title":"Installing Shaken Fist"},{"location":"installation/#local-development","text":"Warning CI testing is currently destructive (don't run it against production!), and not supported for installs with fewer than three machines. It is skipped for a localhost install. We also make the assumption that developer laptops move around more than servers. In a traditional install we detect the primary NIC of the machine and then use that to build VXLAN meshes. For localhost single node deploys we instead create a bridge called \"brsf\" and then use that as our primary NIC. This means your machine can move around and have different routes to the internet over time, but it also means its fiddly to convert a localhost install into a real production cluster. Please only use localhost installs for development purposes. CLOUD=localhost ./deployandtest.sh The deployer clones a number of git repositories that it needs to build a working Shaken Fist installation. As a developer, you might want to move these out of shakenfist/deploy/gitrepos to somewhere more obvious once the installer has finished running. You can just symlink the repositories to the location that the deployer users and things will work as expected. Note that the deloyer does not clone all repositories, just those it needs, so you might still need to clone other repositories. If you want to install a specific release, you can set the RELEASE environment variable. Possible options are: Any valid pypi release version number. \"git:master\" for the current master branch of each repository. \"git:branch\" for a specific branch. If that branch does not exist in a given repository, master is used instead.","title":"Local Development"},{"location":"installation/#your-first-instance","text":"Before you can start your first instance you'll need to authenticate to Shaken Fist, and create a network. Shaken Fist's python api client (as used by the command line client) looks for authentication details in the following locations: Command line flags Environment variables (prefixed with SHAKENFIST_ ) ~/.shakenfist , a JSON formatted configuration file /etc/sf/shakenfist.json , the same file as above, but global By default the installer creates /etc/sf/sfrc , which sets the required environment variables to authenticate. It is customized per installation, setting the following variables: SHAKENFIST_NAMESPACE , the namespace to create resources in SHAKENFIST_KEY , an authentication key for that namespace SHAKENFIST_API_URL , a URL to the Shaken Fist API server Before interacting with Shaken Fist, we need to source the rc file. . /etc/sf/sfrc Instances must be launched attached to a network. Create your first network: sf-client network create 192.168.42.0/24 mynet You can get help for the command line client by running `sf-client --help . The above command creates a new network called \"mynet\", with the IP block 192.168.42.0/24. You will receive some descriptive output back: $ sf-client network create 192.168.42.0/24 mynet uuid : 16baa325-5adf-473f-8e7a-75710a822d45 name : mynet vxlan id : 2 netblock : 192.168.42.0/24 provide dhcp : True provide nat : True floating gateway: None namespace : system state : initial Metadata: The UUID is important, as that is how we will refer to the network elsewhere. Let's now create a simple first instance (you'll need to change this to use your actual network UUID): $ sf-client instance create myvm 1 1024 -d 8@cirros -n 16baa325-5adf-473f-8e7a-75710a822d45 uuid : c6c4ba94-ed34-497d-8964-c223489dee3e name : myvm namespace : system cpus : 1 memory : 1024 disk spec : type=disk bus=None size=8 base=cirros video : model=cirrus memory=16384 node : marvin power state : on state : created console port: 31839 vdi port : 34442 ssh key : None user data : None Metadata: Interfaces: uuid : e56b3c7b-8056-4645-b5b5-1779721ff21d network : 16baa325-5adf-473f-8e7a-75710a822d45 macaddr : ae:15:4d:9c:d8:c0 order : 0 ipv4 : 192.168.42.76 floating: None model : virtio Probably the easiest way to interact with this instance is to connect to its console port, which is the serial console of the instance over telnet. In the case above, that is available on port 31829 on localhost (my laptop is called marvin).","title":"Your first instance"},{"location":"power_states/","text":"Instance power states Shaken Fist version 0.2.1 introduced power states for instances. Before this, you could power on or off an instance, or pause it, but you couldn't tell what power state the instance was actually in. That was pretty confusing and was therefore treated as a bug. The following power states are implemented: on : the instance is running off : the instance is not running paused : the instance is paused crashed : the instance is crashed according to the hypervisor. Instances in this power state will also be in an instance state of \"error\". There are additionally a set of \"transition states\" which are used to indicate that you have requested a change of state that might not yet have completed. These are: transition-to-on transition-to-off transition-to-paused We're hoping to not have to implement a transition-to-crashed state, but you never know.","title":"Power States"},{"location":"power_states/#instance-power-states","text":"Shaken Fist version 0.2.1 introduced power states for instances. Before this, you could power on or off an instance, or pause it, but you couldn't tell what power state the instance was actually in. That was pretty confusing and was therefore treated as a bug. The following power states are implemented: on : the instance is running off : the instance is not running paused : the instance is paused crashed : the instance is crashed according to the hypervisor. Instances in this power state will also be in an instance state of \"error\". There are additionally a set of \"transition states\" which are used to indicate that you have requested a change of state that might not yet have completed. These are: transition-to-on transition-to-off transition-to-paused We're hoping to not have to implement a transition-to-crashed state, but you never know.","title":"Instance power states"},{"location":"changelog/changelog_v02/","text":"Changes between v0.2.7 and v0.2.8 v0.2.8 has not yet been released. Allow the setting of numeric configuration values. shakenfist#324 Backing file information must be provided with modern libvirts. shakenfist#326 Changes between v0.2.6 and v0.2.7 v0.2.7 was released on 26 September 2020. Fix import error in scheduler.py Changes between v0.2.5 and v0.2.6 v0.2.6 was released on 26 September 2020. Fix typo in gunicorn command line. Changes between v0.2.4 and v0.2.5 v0.2.5 was released on 3 August 2020. API requests without a JSON payload fail when made to a non-network node. shakenfist#261 Resolve error during instance start. shakenfist#263 Resolve a crash in the network monitor. shakenfist#264 Changes between v0.2.3 and v0.2.4 v0.2.4 was released on 2 August 2020. Remove stray networks when detected. shakenfist#161 Display video details of an instance in sf-client. shakenfist#216 The login prompt trigger is now more reliable. shakenfist#223 Rapid creates from terraform can crash Shaken Fist with a race condition. shakenfist#225 Instance deletes could leave internal IP addresses allocated to deleted instances. shakenfist#227 sf-client now displays network card model. shakenfist#228 Missing node metrics could cause a scheduler crash. shakenfist#236 A missing import caused a scheduler crash. shakenfist#236 You can now list the instances on a network with sf-client. shakenfist#240 Disabling DHCP for networks did not work correctly. shakenfist#245 Ubuntu 18.04's cloud-init would issue warnings about network interface types. shakenfist#250 Network interfaces were sometimes leaked. shakenfist#252 sf-client would sometimes crash if the disk bus was the default. shakenfist#253 Load balancers were causing annoying log messages which have been demoted to debug level. shakenfist#258 Changes between v0.2.2 and v0.2.3 v0.2.3 was released on 25 July 2020. Run CI tests multiple times to try and shake out timing errors. shakenfist#191 Be more flexible in what VDI video configurations we allow. shakenfist#201 Log power state changes as instance events. shakenfist#203 Handle bad video card choices more gracefully. shakenfist#219 Changes between v0.2.1 and v0.2.2 v0.2.2 was released on 23 July 2020. Support for cascading delete of resources when you delete a namespace. shakenfist#157 Shaken Fist now tracks the power state of instances and exposes that via the REST API and command line client. We also kill stray instances which are left running after deletion. shakenfist#197 The API (and command line client) now display the version of Shaken Fist installed on each node. shakenfist#175 The network event cleanup code handles larger numbers of events needing to be cleaned on upgrade. shakenfist#176 Kernel Shared Memory is now configured by the deployer and used by Shaken Fist to over subscribe memory in cases where pages are successfully being shared. shakenfist#177 , deploy#28 and deploy#33 . Instance nodes are now correctly reported in cases where placement was forced. shakenfist#179 Instance scheduling is retried on a different node in cases where the churn rate is sufficient for the cached resource availability information to be inaccurate. shakenfist#186 A permissions denied error was corrected for shakenfist.json accesses in the comment line client. shakenfist#187 Incorrect database information for instances or network interfaces no longer crashes the start of new instances. shakenfist#194 Instance names must now be DNS safe. shakenfist#200 The deployer now checks that the configured MTU on the VXLAN mesh interface is sane. deploy#30 , and deploy#32 . Changes between v0.2.0 and v0.2.1 v0.2.1 was released on 16 July 2020. Fix crash in cleaner daemon when an etcd compaction fails. shakenfist#152 Fix HTTP 500 errors when malformed authorization headers are passed on API calls. shakenfist#154 Avoid starting instances on the network node if possible. shakenfist#156 Track and expose instance power states. Show instance state and power state in instance listings. shakenfist#159 Correct resource-in-use errors for specific IP requests. shakenfist#162 Network mesh event logging was too verbose. Only log additions and removals from the mesh. Also cleanup old mesh events on upgrade. shakenfist#163 Nodes now report what version of Shaken Fist they are running via etcd. shakenfist#164","title":"v0.2"},{"location":"changelog/changelog_v02/#changes-between-v027-and-v028","text":"v0.2.8 has not yet been released. Allow the setting of numeric configuration values. shakenfist#324 Backing file information must be provided with modern libvirts. shakenfist#326","title":"Changes between v0.2.7 and v0.2.8"},{"location":"changelog/changelog_v02/#changes-between-v026-and-v027","text":"v0.2.7 was released on 26 September 2020. Fix import error in scheduler.py","title":"Changes between v0.2.6 and v0.2.7"},{"location":"changelog/changelog_v02/#changes-between-v025-and-v026","text":"v0.2.6 was released on 26 September 2020. Fix typo in gunicorn command line.","title":"Changes between v0.2.5 and v0.2.6"},{"location":"changelog/changelog_v02/#changes-between-v024-and-v025","text":"v0.2.5 was released on 3 August 2020. API requests without a JSON payload fail when made to a non-network node. shakenfist#261 Resolve error during instance start. shakenfist#263 Resolve a crash in the network monitor. shakenfist#264","title":"Changes between v0.2.4 and v0.2.5"},{"location":"changelog/changelog_v02/#changes-between-v023-and-v024","text":"v0.2.4 was released on 2 August 2020. Remove stray networks when detected. shakenfist#161 Display video details of an instance in sf-client. shakenfist#216 The login prompt trigger is now more reliable. shakenfist#223 Rapid creates from terraform can crash Shaken Fist with a race condition. shakenfist#225 Instance deletes could leave internal IP addresses allocated to deleted instances. shakenfist#227 sf-client now displays network card model. shakenfist#228 Missing node metrics could cause a scheduler crash. shakenfist#236 A missing import caused a scheduler crash. shakenfist#236 You can now list the instances on a network with sf-client. shakenfist#240 Disabling DHCP for networks did not work correctly. shakenfist#245 Ubuntu 18.04's cloud-init would issue warnings about network interface types. shakenfist#250 Network interfaces were sometimes leaked. shakenfist#252 sf-client would sometimes crash if the disk bus was the default. shakenfist#253 Load balancers were causing annoying log messages which have been demoted to debug level. shakenfist#258","title":"Changes between v0.2.3 and v0.2.4"},{"location":"changelog/changelog_v02/#changes-between-v022-and-v023","text":"v0.2.3 was released on 25 July 2020. Run CI tests multiple times to try and shake out timing errors. shakenfist#191 Be more flexible in what VDI video configurations we allow. shakenfist#201 Log power state changes as instance events. shakenfist#203 Handle bad video card choices more gracefully. shakenfist#219","title":"Changes between v0.2.2 and v0.2.3"},{"location":"changelog/changelog_v02/#changes-between-v021-and-v022","text":"v0.2.2 was released on 23 July 2020. Support for cascading delete of resources when you delete a namespace. shakenfist#157 Shaken Fist now tracks the power state of instances and exposes that via the REST API and command line client. We also kill stray instances which are left running after deletion. shakenfist#197 The API (and command line client) now display the version of Shaken Fist installed on each node. shakenfist#175 The network event cleanup code handles larger numbers of events needing to be cleaned on upgrade. shakenfist#176 Kernel Shared Memory is now configured by the deployer and used by Shaken Fist to over subscribe memory in cases where pages are successfully being shared. shakenfist#177 , deploy#28 and deploy#33 . Instance nodes are now correctly reported in cases where placement was forced. shakenfist#179 Instance scheduling is retried on a different node in cases where the churn rate is sufficient for the cached resource availability information to be inaccurate. shakenfist#186 A permissions denied error was corrected for shakenfist.json accesses in the comment line client. shakenfist#187 Incorrect database information for instances or network interfaces no longer crashes the start of new instances. shakenfist#194 Instance names must now be DNS safe. shakenfist#200 The deployer now checks that the configured MTU on the VXLAN mesh interface is sane. deploy#30 , and deploy#32 .","title":"Changes between v0.2.1 and v0.2.2"},{"location":"changelog/changelog_v02/#changes-between-v020-and-v021","text":"v0.2.1 was released on 16 July 2020. Fix crash in cleaner daemon when an etcd compaction fails. shakenfist#152 Fix HTTP 500 errors when malformed authorization headers are passed on API calls. shakenfist#154 Avoid starting instances on the network node if possible. shakenfist#156 Track and expose instance power states. Show instance state and power state in instance listings. shakenfist#159 Correct resource-in-use errors for specific IP requests. shakenfist#162 Network mesh event logging was too verbose. Only log additions and removals from the mesh. Also cleanup old mesh events on upgrade. shakenfist#163 Nodes now report what version of Shaken Fist they are running via etcd. shakenfist#164","title":"Changes between v0.2.0 and v0.2.1"},{"location":"changelog/changelog_v03/","text":"The big ideas of v0.3 v0.3 is a re-write of portions of v0.2 that we felt were holding Shaken Fist back. The two most obvious examples are that slow operations would often timeout because of our HTTP worker model, and locking simply didn't work at all. Some more detail on those: All operations in v0.2 are handled by the REST API HTTP workers (gunicorn). So, if you ask us to launch an instance, we use the HTTP worker to do that thing. That works great, unless the operation is going to take more time than the HTTP worker is allowed to run for. This is pretty easy to achieve if the image you're fetching is large. Instead, we now move to a model where the HTTP worker creates a queued job, and then polls its state for a small period of time before returning. That means if things are quick you get the same API behaviour as before, but for slow operations you'll be told that the job is incomplete but still executing. We also realised somewhere late in v0.2's life that the etcd library we were using was pretty buggy. Locking simply didn't work some of the time. Additionally, our locking code was pretty ad hoc and sometimes we would get the names of the locks wrong because they were just strings. This has now been completely re-written, but that has shaken out a number of bugs that are surfaced by locking actually working now. We have worked through those bugs and sought to resolve them.","title":"v0.3"},{"location":"changelog/changelog_v03/#the-big-ideas-of-v03","text":"v0.3 is a re-write of portions of v0.2 that we felt were holding Shaken Fist back. The two most obvious examples are that slow operations would often timeout because of our HTTP worker model, and locking simply didn't work at all. Some more detail on those: All operations in v0.2 are handled by the REST API HTTP workers (gunicorn). So, if you ask us to launch an instance, we use the HTTP worker to do that thing. That works great, unless the operation is going to take more time than the HTTP worker is allowed to run for. This is pretty easy to achieve if the image you're fetching is large. Instead, we now move to a model where the HTTP worker creates a queued job, and then polls its state for a small period of time before returning. That means if things are quick you get the same API behaviour as before, but for slow operations you'll be told that the job is incomplete but still executing. We also realised somewhere late in v0.2's life that the etcd library we were using was pretty buggy. Locking simply didn't work some of the time. Additionally, our locking code was pretty ad hoc and sometimes we would get the names of the locks wrong because they were just strings. This has now been completely re-written, but that has shaken out a number of bugs that are surfaced by locking actually working now. We have worked through those bugs and sought to resolve them.","title":"The big ideas of v0.3"},{"location":"development/git_usage/","text":"Development Workflow Short Lesson The majority of teams using git have a work flow that looks similar to the four well known work flows: Git Flow GitHub Flow GitLab Flow Trunk Based Development Git Development - the Shaken Fist Way The Shaken Fist developers have chosen Trunk Based Development. Branch Types master branch This is the development trunk. All feature branches are branched from master and merged to master . feature branches Short-lived, generally a few days. Normally only one developer. When presented to the team, it is expected to pass the linter and unit tests. It is normal that other team members suggest changes/improvements before merging. release-vX.X branches Only created when a release requires patches (hot-fixes). Commits to this branch are cherry-picks from master . It is not expected that many commits are made to this branch. If many commits are required to a release branch then this indicates the need for another release. Attention One day the project might desire a develop branch to ensure that master is always production ready. This can be useful when adding and maturing multiple inter-dependant features. At this stage, it is not required and would lead to more complexity. At this of project maturity, that complexity would be extra effort with the possibility of errors without a significant return. Process Feature branches Feature/Bug branches have a prefix consisting of the GitHub issue number - no need for the word bug or issue. The feature branch developer should squash commits to remove WIP commits before creating a Pull Request. It is preferably that each remaining commit passes testing/CI. Merging Commits are not squashed when merged to master Not squashing commits maintains history of multiple issues being solved. Pull Request related commits remain grouped and can be understood as a single merge Release branch Only necessary bug fixes are cherry-picked from master to an existing release-vX.X branch. Too many cherry-picked commits to a Release branch If a large number of commits appear desirable on a release branch, it is probably an indication that another minor release would be a better idea. If another release is not desired because master contains unstable features then either CI needs improving or that feature requires more work and should not be in master .","title":"Workflow"},{"location":"development/git_usage/#development-workflow","text":"","title":"Development Workflow"},{"location":"development/git_usage/#short-lesson","text":"The majority of teams using git have a work flow that looks similar to the four well known work flows: Git Flow GitHub Flow GitLab Flow Trunk Based Development","title":"Short Lesson"},{"location":"development/git_usage/#git-development-the-shaken-fist-way","text":"The Shaken Fist developers have chosen Trunk Based Development.","title":"Git Development - the Shaken Fist Way"},{"location":"development/git_usage/#branch-types","text":"master branch This is the development trunk. All feature branches are branched from master and merged to master . feature branches Short-lived, generally a few days. Normally only one developer. When presented to the team, it is expected to pass the linter and unit tests. It is normal that other team members suggest changes/improvements before merging. release-vX.X branches Only created when a release requires patches (hot-fixes). Commits to this branch are cherry-picks from master . It is not expected that many commits are made to this branch. If many commits are required to a release branch then this indicates the need for another release. Attention One day the project might desire a develop branch to ensure that master is always production ready. This can be useful when adding and maturing multiple inter-dependant features. At this stage, it is not required and would lead to more complexity. At this of project maturity, that complexity would be extra effort with the possibility of errors without a significant return.","title":"Branch Types"},{"location":"development/git_usage/#process","text":"","title":"Process"},{"location":"development/git_usage/#feature-branches","text":"Feature/Bug branches have a prefix consisting of the GitHub issue number - no need for the word bug or issue. The feature branch developer should squash commits to remove WIP commits before creating a Pull Request. It is preferably that each remaining commit passes testing/CI.","title":"Feature branches"},{"location":"development/git_usage/#merging","text":"Commits are not squashed when merged to master Not squashing commits maintains history of multiple issues being solved. Pull Request related commits remain grouped and can be understood as a single merge","title":"Merging"},{"location":"development/git_usage/#release-branch","text":"Only necessary bug fixes are cherry-picked from master to an existing release-vX.X branch.","title":"Release branch"},{"location":"development/git_usage/#too-many-cherry-picked-commits-to-a-release-branch","text":"If a large number of commits appear desirable on a release branch, it is probably an indication that another minor release would be a better idea. If another release is not desired because master contains unstable features then either CI needs improving or that feature requires more work and should not be in master .","title":"Too many cherry-picked commits to a Release branch"},{"location":"development/namespace_auth/","text":"Namespace Context and Authentication Namespaces All resources (instances/networks/interfaces) are assigned to a Namespace. All requests to Shaken Fist have a Namespace context. Only requests in the \"system\" Namespace are able to access resources in other (foreign) Namespaces. The Namespace \"system\" is reserved. Authentication A Namespace is accessed by supplying a valid \"Key\" (password). Namespaces can have multiple Keys. Each Key has a label referred to as a \"Key Name\". The Key Name is not specified during authentication. The Key Name \"service_key\" is reserved. API Request Authentication The authentication endpoint /auth is used to obtain a token to authenticate future API interaction. To obtain the token, the authentication request is made specifying the Namespace and the Key. The Key Name is not required (nor important). The response contains the (JWT) token to be used as a Bearer token for the actual API request. Internally, Shaken Fist determines the Namespace of each API request from the token. Authentication tokens expire after a fixed period of time (nominally 15 minutes). Interaction Name spaces can be created from within the \"system\" Namespace. The creation of a Namespace requires that a Key and it's Key Name are specified with the creation request. Keys do not have to be unique. A Key collision within a Namespace has no security consequences. Key Names are only unique within a Namespace. The purpose of the Key Name is to supply a handle to enable deletion of a Key. Actions are not logged against Key Names. Inter-Node Authentication Requests between Shaken Fist nodes use the same authentication system as external API requests. When a node makes an API request to another node, the originating node will create (or reuse) a \"service key\" specific to the Namespace of the original request. When a request is made from the \"system\" Namespace for a resource in a different Namespace, the API request is made using the foreign Namespace and the foreign Namespace service key.","title":"Namespace Authentication"},{"location":"development/namespace_auth/#namespace-context-and-authentication","text":"","title":"Namespace Context and Authentication"},{"location":"development/namespace_auth/#namespaces","text":"All resources (instances/networks/interfaces) are assigned to a Namespace. All requests to Shaken Fist have a Namespace context. Only requests in the \"system\" Namespace are able to access resources in other (foreign) Namespaces. The Namespace \"system\" is reserved.","title":"Namespaces"},{"location":"development/namespace_auth/#authentication","text":"A Namespace is accessed by supplying a valid \"Key\" (password). Namespaces can have multiple Keys. Each Key has a label referred to as a \"Key Name\". The Key Name is not specified during authentication. The Key Name \"service_key\" is reserved.","title":"Authentication"},{"location":"development/namespace_auth/#api-request-authentication","text":"The authentication endpoint /auth is used to obtain a token to authenticate future API interaction. To obtain the token, the authentication request is made specifying the Namespace and the Key. The Key Name is not required (nor important). The response contains the (JWT) token to be used as a Bearer token for the actual API request. Internally, Shaken Fist determines the Namespace of each API request from the token. Authentication tokens expire after a fixed period of time (nominally 15 minutes).","title":"API Request Authentication"},{"location":"development/namespace_auth/#interaction","text":"Name spaces can be created from within the \"system\" Namespace. The creation of a Namespace requires that a Key and it's Key Name are specified with the creation request. Keys do not have to be unique. A Key collision within a Namespace has no security consequences. Key Names are only unique within a Namespace. The purpose of the Key Name is to supply a handle to enable deletion of a Key. Actions are not logged against Key Names.","title":"Interaction"},{"location":"development/namespace_auth/#inter-node-authentication","text":"Requests between Shaken Fist nodes use the same authentication system as external API requests. When a node makes an API request to another node, the originating node will create (or reuse) a \"service key\" specific to the Namespace of the original request. When a request is made from the \"system\" Namespace for a resource in a different Namespace, the API request is made using the foreign Namespace and the foreign Namespace service key.","title":"Inter-Node Authentication"},{"location":"development/release_process/","text":"Shaken Fist's release process Shaken Fist is now split across a number of repositories to simplify development and usage. Unfortunately, that complicated the release process. This page documents the current release process. Step 1: Testing Before release, you should ensure that all of the clouds currently supported in the deploy repository work. These are important to new users and testers, so we should keep them working. For reference, they are at deploy/ansible/terraform . At the time of writing those are: aws aws-single node gcp metal openstack Note that to test these you need access to all those clouds, as well as needing to know the cloud specific values for each cloud. Unfortunately I can't tell you those because they vary with your specific cloud accounts. Step 2: shakenfist/shakenfist Test that pypi will accept Markdown formatted README. In the shakenfist/shakenfist repo: pip install --upgrade readme-renderer pip install --upgrade twine rm -f dist/* git tag -s v0.1 -m \"Release v0.1\" python3 setup.py sdist bdist_wheel twine check dist/* git push origin v0.1 twine upload dist/* Create the branch for cherry picks and minor releases: git checkout -b v0.1-devel git push origin v0.1-devel Step 3: shakenfist/client-python Test that pypi will accept Markdown formatted README. In the shakenfist/client-python repo: pip install --upgrade readme-renderer pip install --upgrade twine rm -f dist/* git tag -s v0.1 -m \"Release v0.1\" python3 setup.py sdist bdist_wheel twine check dist/* git push origin v0.1 twine upload dist/* Step 4: shakenfist/client-go Tag and release as per shakenfist/shakenfist - include the patch number eg. v0.1.0 Golang modules require an \"annotated git tag\" (not a lightweight git tag). Therefore use the sign option ( -s ) as above, or use the annotate option ( -a ) of git tag . Note that the Github website interface will create lightweight tags. Therefore tag locally and push to Github. IMPORTANT: Golang modules require the full X.Y.Z sermver version eg. v0.2.0 (Otherwise go will attach the wrong version numbers to fetches and update go.mod incorrectly.) Step 5: shakenfist/deploy Tag and release as per shakenfist/shakenfist. Step 6: shakenfist/terraform-provider-shakenfist Bump dependency in go.mod Tag and release Set the version number of github.com/shakenfist/client-go in the go.mod file to the new release version. Then tag and release as per shakenfist/shakenfist.","title":"Releases"},{"location":"development/release_process/#shaken-fists-release-process","text":"Shaken Fist is now split across a number of repositories to simplify development and usage. Unfortunately, that complicated the release process. This page documents the current release process.","title":"Shaken Fist's release process"},{"location":"development/release_process/#step-1-testing","text":"Before release, you should ensure that all of the clouds currently supported in the deploy repository work. These are important to new users and testers, so we should keep them working. For reference, they are at deploy/ansible/terraform . At the time of writing those are: aws aws-single node gcp metal openstack Note that to test these you need access to all those clouds, as well as needing to know the cloud specific values for each cloud. Unfortunately I can't tell you those because they vary with your specific cloud accounts.","title":"Step 1: Testing"},{"location":"development/release_process/#step-2-shakenfistshakenfist","text":"Test that pypi will accept Markdown formatted README. In the shakenfist/shakenfist repo: pip install --upgrade readme-renderer pip install --upgrade twine rm -f dist/* git tag -s v0.1 -m \"Release v0.1\" python3 setup.py sdist bdist_wheel twine check dist/* git push origin v0.1 twine upload dist/* Create the branch for cherry picks and minor releases: git checkout -b v0.1-devel git push origin v0.1-devel","title":"Step 2: shakenfist/shakenfist"},{"location":"development/release_process/#step-3-shakenfistclient-python","text":"Test that pypi will accept Markdown formatted README. In the shakenfist/client-python repo: pip install --upgrade readme-renderer pip install --upgrade twine rm -f dist/* git tag -s v0.1 -m \"Release v0.1\" python3 setup.py sdist bdist_wheel twine check dist/* git push origin v0.1 twine upload dist/*","title":"Step 3: shakenfist/client-python"},{"location":"development/release_process/#step-4-shakenfistclient-go","text":"Tag and release as per shakenfist/shakenfist - include the patch number eg. v0.1.0 Golang modules require an \"annotated git tag\" (not a lightweight git tag). Therefore use the sign option ( -s ) as above, or use the annotate option ( -a ) of git tag . Note that the Github website interface will create lightweight tags. Therefore tag locally and push to Github. IMPORTANT: Golang modules require the full X.Y.Z sermver version eg. v0.2.0 (Otherwise go will attach the wrong version numbers to fetches and update go.mod incorrectly.)","title":"Step 4: shakenfist/client-go"},{"location":"development/release_process/#step-5-shakenfistdeploy","text":"Tag and release as per shakenfist/shakenfist.","title":"Step 5: shakenfist/deploy"},{"location":"development/release_process/#step-6-shakenfistterraform-provider-shakenfist","text":"Bump dependency in go.mod Tag and release Set the version number of github.com/shakenfist/client-go in the go.mod file to the new release version. Then tag and release as per shakenfist/shakenfist.","title":"Step 6: shakenfist/terraform-provider-shakenfist"},{"location":"development/standards/","text":"Concepts and Standards Ensuring a Common Language within the code base This document records the standards and common language used within the Shaken Fist software system. It should also record why the choice was made. (This is actually just notes to save our future selves from tripping over the same problems.) Memory Memory is measured in MiB All references to memory size are stored/transmitted in MiB Gigabytes can be too big if you want a lot of small machines. Kilobytes is just too many numbers to type. Interactions The libvirt API measures memory in KiB. Therefore, interactions with the library need to be careful to convert from MiB to KiB.","title":"Standards"},{"location":"development/standards/#concepts-and-standards","text":"","title":"Concepts and Standards"},{"location":"development/standards/#ensuring-a-common-language-within-the-code-base","text":"This document records the standards and common language used within the Shaken Fist software system. It should also record why the choice was made. (This is actually just notes to save our future selves from tripping over the same problems.)","title":"Ensuring a Common Language within the code base"},{"location":"development/standards/#memory","text":"Memory is measured in MiB All references to memory size are stored/transmitted in MiB Gigabytes can be too big if you want a lot of small machines. Kilobytes is just too many numbers to type.","title":"Memory"},{"location":"development/standards/#interactions","text":"The libvirt API measures memory in KiB. Therefore, interactions with the library need to be careful to convert from MiB to KiB.","title":"Interactions"},{"location":"development/updating_docs/","text":"Updating These Docs Built using MkDocs: https://www.mkdocs.org/ Theme: https://squidfunk.github.io/mkdocs-material/customization/ Setup Install mkdocs and the material theme pip install mkdocs-material Viewing Locally Start the live web-server with mkdocs serve View at http://localhost:8000 Deploying to GitHub Pages Build and deploy with mkdocs gh-deploy This will push to the gh-pages branch of the current git remote. Navigation Bar The navigation bar is configured via the mkdocs.yml file in the repository root.","title":"Website"},{"location":"development/updating_docs/#updating-these-docs","text":"Built using MkDocs: https://www.mkdocs.org/ Theme: https://squidfunk.github.io/mkdocs-material/customization/","title":"Updating These Docs"},{"location":"development/updating_docs/#setup","text":"Install mkdocs and the material theme pip install mkdocs-material","title":"Setup"},{"location":"development/updating_docs/#viewing-locally","text":"Start the live web-server with mkdocs serve View at http://localhost:8000","title":"Viewing Locally"},{"location":"development/updating_docs/#deploying-to-github-pages","text":"Build and deploy with mkdocs gh-deploy This will push to the gh-pages branch of the current git remote.","title":"Deploying to GitHub Pages"},{"location":"development/updating_docs/#navigation-bar","text":"The navigation bar is configured via the mkdocs.yml file in the repository root.","title":"Navigation Bar"},{"location":"networking/overview/","text":"Networking Overview Shaken Fist networking is complicated. Its actually less complicated that OpenStack Neutron networking, and its about as simple as we can get away with, but in order to allow virtual networks to use overlapping network ranges we are forced to do some vaguely complicated things with network namespaces. This document attempts to incrementally describe how Shaken Fist networking works, so that I can remember later. VXLAN Shaken Fist networking is based on a VXLAN mesh. VXLAN is like a successor to VLANs, except that you can have 1.6 million virtual networks, it doesn't use an IP header field to divide the networks up, and it is transported inside UDP packets between the members of the mesh. Normally VXLAN meshes are implemented using multicast UDP, but that doesn't work in public clouds where Shaken Fist was born, so we instead use unicast meshes that we lovingly hand maintain. Note The virtual mesh manages itself and changes state over time. If your mesh entries do not look like mine, it does not nessesarily indicate that your networking is broken. This is a dynamic environment! Our worked examples For this document, we will assume there are three Shaken Fist nodes, named sf-1 , sf-2 , and sf-3 . Its a total coincidence that this is the default size for the installer ansible at the time of writing and the exact size of all of the production clusters we are aware of. sf-1 is configured as the \"network node\", which is just a hypervisor like every other node, except that it is also where packets to and from the virtual networks route in and out of the mesh. First, off let's start with a simple network with one instance and no DHCP or NAT .","title":"Overview"},{"location":"networking/overview/#networking-overview","text":"Shaken Fist networking is complicated. Its actually less complicated that OpenStack Neutron networking, and its about as simple as we can get away with, but in order to allow virtual networks to use overlapping network ranges we are forced to do some vaguely complicated things with network namespaces. This document attempts to incrementally describe how Shaken Fist networking works, so that I can remember later.","title":"Networking Overview"},{"location":"networking/overview/#vxlan","text":"Shaken Fist networking is based on a VXLAN mesh. VXLAN is like a successor to VLANs, except that you can have 1.6 million virtual networks, it doesn't use an IP header field to divide the networks up, and it is transported inside UDP packets between the members of the mesh. Normally VXLAN meshes are implemented using multicast UDP, but that doesn't work in public clouds where Shaken Fist was born, so we instead use unicast meshes that we lovingly hand maintain. Note The virtual mesh manages itself and changes state over time. If your mesh entries do not look like mine, it does not nessesarily indicate that your networking is broken. This is a dynamic environment!","title":"VXLAN"},{"location":"networking/overview/#our-worked-examples","text":"For this document, we will assume there are three Shaken Fist nodes, named sf-1 , sf-2 , and sf-3 . Its a total coincidence that this is the default size for the installer ansible at the time of writing and the exact size of all of the production clusters we are aware of. sf-1 is configured as the \"network node\", which is just a hypervisor like every other node, except that it is also where packets to and from the virtual networks route in and out of the mesh. First, off let's start with a simple network with one instance and no DHCP or NAT .","title":"Our worked examples"},{"location":"networking/single_instance/","text":"Networking Explained - Single Node This page is part of a series explaining how Shaken Fist networking works . You might want to check out the other pages as well. The simplest case: a virtual network with no DHCP and no NAT, and a single remote instance Let's assume you want a new virtual network with no network services. Its just two instances talking to each other. The basic flow is like this -- you create a virtual network. We allocate you a VXLAN network id (called the vxid in various places in the code): sf-1 # sf-client network create 192.168.0.0/24 demonet --no-dhcp --no-nat uuid : b41b067a-44b7-40c5-9ab8-7abdcf5fdc61 name : demonet vxlan id : 2 netblock : 192.168.0.0/24 provide dhcp : False provide nat : False floating gateway: None namespace : system state : initial Metadata: So in this case we were allocated VXLAN id 2, and have a network UUID of b41b067a-44b7-40c5-9ab8-7abdcf5fdc61. The state of the network is \"initial\" as it has not been created anywhere yet. If you wait a few seconds, you'll see it transition to a \"created\" state. You can see the new state with a show command: sf-1 # sf-client network show b41b067a-44b7-40c5-9ab8-7abdcf5fdc61 uuid : b41b067a-44b7-40c5-9ab8-7abdcf5fdc61 name : demonet vxlan id : 2 netblock : 192.168.0.0/24 provide dhcp : False provide nat : False floating gateway: None namespace : system state : created Metadata: And you can see the steps we went through to create the network in the events listing: sf-1 # sf-client network events b41b067a-44b7-40c5-9ab8-7abdcf5fdc61 +----------------------------+------+------------------------+------------+----------------------+-----------+ | timestamp | node | operation | phase | duration | message | +----------------------------+------+------------------------+------------+----------------------+-----------+ | 2020-08-01 06:49:07.753351 | sf-1 | api | create | None | None | | 2020-08-01 06:49:07.792583 | sf-1 | create vxlan interface | start | None | None | | 2020-08-01 06:49:07.819312 | sf-1 | create vxlan interface | finish | 0.025562286376953125 | None | | 2020-08-01 06:49:07.840636 | sf-1 | create vxlan bridge | start | None | None | | 2020-08-01 06:49:07.905165 | sf-1 | create vxlan bridge | finish | 0.0644679069519043 | None | | 2020-08-01 06:49:07.910409 | sf-1 | create netns | start | None | None | | 2020-08-01 06:49:07.997595 | sf-1 | create netns | finish | 0.0850062370300293 | None | | 2020-08-01 06:49:08.016509 | sf-1 | create router veth | start | None | None | | 2020-08-01 06:49:08.237167 | sf-1 | create router veth | finish | 0.2197411060333252 | None | | 2020-08-01 06:49:08.254165 | sf-1 | create physical veth | start | None | None | | 2020-08-01 06:49:08.342684 | sf-1 | create physical veth | finish | 0.08613038063049316 | None | | 2020-08-01 06:49:08.371490 | sf-1 | add mesh elements | None | None | 10.2.1.11 | | 2020-08-01 06:49:08.375682 | sf-1 | api | created | None | None | | 2020-08-01 06:49:40.664204 | sf-1 | api | get | None | None | | 2020-08-01 06:50:07.554738 | sf-1 | api | get events | None | None | +----------------------------+------+------------------------+------------+----------------------+-----------+ You can see here that the network node (sf-1) has created some network elements, and an IP (10.2.1.11) has been added to the mesh. That IP is sf-1, and its part of the network node being joined to the mesh. If we look on sf-1, we should now have a VXLAN interface, a bridge, and one end of a veth. sf-1 # ip addr show vxlan-2 287: vxlan-2: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 8950 qdisc noqueue master br-vxlan-2 state UNKNOWN group default qlen 1000 link/ether de:c4:ab:3d:79:fb brd ff:ff:ff:ff:ff:ff inet6 fe80::dcc4:abff:fe3d:79fb/64 scope link valid_lft forever preferred_lft forever sf-1 # ip addr show br-vxlan-2 288: br-vxlan-2: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP group default qlen 1000 link/ether be:c1:1b:20:b8:f7 brd ff:ff:ff:ff:ff:ff inet6 fe80::bcc1:1bff:fe20:b8f7/64 scope link valid_lft forever preferred_lft forever sf-1 # ip addr show veth-2-o 290: veth-2-o@if289: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue master br-vxlan-2 state UP group default qlen 1000 link/ether be:c1:1b:20:b8:f7 brd ff:ff:ff:ff:ff:ff link-netnsid 0 inet6 fe80::bcc1:1bff:fe20:b8f7/64 scope link valid_lft forever preferred_lft forever The vxlan-2 interface is the VXLAN mesh, and the br-vxlan-2 bridge is how VMs and veths will connect to the mesh on this local machine. Its important to note that MTU matters here. The MTU for the mesh network is 1500 bytes, and most client VMs will default to that as well. Therefore the underlying network needs to have a MTU greater than that. We default to an MTU of 9000 bytes in our installs, but 1550 would in fact be sufficient in this case. You can see this in the MTU for vxlan-2, which is our 9000 byte underlying MTU, with 50 bytes deducted for the VXLAN encapsulation. We can also ask the mesh for its current state: sf-1 # bridge fdb show brport vxlan-2 de:c4:ab:3d:79:fb master br-vxlan-2 permanent de:c4:ab:3d:79:fb vlan 1 master br-vxlan-2 permanent 00:00:00:00:00:00 dst 10.2.1.11 self permanent de:c4:ab:3d:79:fb dst 127.0.0.1 self be:c1:1b:20:b8:f7 dst 127.0.0.1 self e2:2d:32:6d:95:70 dst 127.0.0.1 self The current members of the mesh are: de:c4:ab:3d:79:fb: this is the mac address for vxlan-2. 00:00:00:00:00:00 dst 10.2.1.11: this is a mesh entry for the node with IP 10.2.1.11 (sf-1) be:c1:1b:20:b8:f7: this is the outside mac address of a veth between br-vxlan-2 and a network namespace on sf-1 e2:2d:32:6d:95:70: is the inside mac address of the veth between br-vxlan-2 and the network namespace What is this network namespace? Well, Shaken Fist needs to create a network namespace to contain routing, NAT, and DHCP for the virtual network. It's actually not strictly required in this simplest case, but we always create it. It is named for the UUID of the virtual network: sf-1 # ip netns exec b41b067a-44b7-40c5-9ab8-7abdcf5fdc61 ip addr list 1: lo: <LOOPBACK> mtu 65536 qdisc noop state DOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 289: veth-2-i@if290: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP group default qlen 1000 link/ether e2:2d:32:6d:95:70 brd ff:ff:ff:ff:ff:ff link-netnsid 0 inet 192.168.0.1/24 scope global veth-2-i valid_lft forever preferred_lft forever inet6 fe80::e02d:32ff:fe6d:9570/64 scope link valid_lft forever preferred_lft forever 291: phy-2-i@if292: <BROADCAST,MULTICAST> mtu 1500 qdisc noop state DOWN group default qlen 1000 link/ether fe:18:8e:f8:d1:5c brd ff:ff:ff:ff:ff:ff link-netnsid 0 The veth between the VXLAN mesh and this namespace is named veth-2-i (the interface inside the network namespace) and veth-2-o (the interface outside the network namespace). There is another veth named phy-2-i and phy-2-o, which is a link between the namespace and the outside world, but we'll talk about that more when we enable NAT. For those who are new to veths, think of them like patch cables -- so what we have here is a VXLAN mesh, which is patched into a network namespace, which is in turn patched into the outside world. We also do some things with iptables, especially around NAT. Here's the current state of iptables in the network namespace: sf-1 # ip netns exec b41b067a-44b7-40c5-9ab8-7abdcf5fdc61 iptables -L -t nat Chain PREROUTING (policy ACCEPT) target prot opt source destination Chain INPUT (policy ACCEPT) target prot opt source destination Chain OUTPUT (policy ACCEPT) target prot opt source destination Chain POSTROUTING (policy ACCEPT) target prot opt source destination That's empty for now because we're not doing any NAT yet, but watch this space. Next let's now start an instance on sf-2. This instance can't use DHCP to get an address because we have that disabled for this network. sf-1 # sf-client instance create inst-on-sf-2 1 1024 -d 20@ubuntu:18.04 -n b41b067a-44b7-40c5-9ab8-7abdcf5fdc61 -p sf-2 uuid : d53b345f-9d5d-493c-a1a3-7e7d6513cfa2 name : inst-on-sf-2 namespace : system cpus : 1 memory : 1024 disk spec : type=disk bus=None size=20 base=ubuntu:18.04 video : model=cirrus memory=16384 node : sf-2 power state : on state : created console port: 48420 vdi port : 32122 ssh key : None user data : None Metadata: Interfaces: uuid : db372968-1c74-4033-8423-8a698e9d4900 network : b41b067a-44b7-40c5-9ab8-7abdcf5fdc61 macaddr : 00:00:00:34:8d:90 order : 0 ipv4 : 192.168.0.3 floating: None model : virtio You can see that our instance (inst-on-sf-2) has been placed on sf-2 because we asked nicely (the -p is a placement option to the command), and has been allocated an IP (192.168.0.3). The virtual network still allocates IPs, even if DHCP is disabled. It has also been allocated a MAC address (00:00:00:34:8d:90). What is the state of the mesh on the network node now? sf-1 # bridge fdb show brport vxlan-2 de:c4:ab:3d:79:fb master br-vxlan-2 permanent de:c4:ab:3d:79:fb vlan 1 master br-vxlan-2 permanent 00:00:00:00:00:00 dst 10.2.1.11 self permanent 0a:ce:c4:f7:cb:dc dst 10.2.1.12 self de:c4:ab:3d:79:fb dst 127.0.0.1 self be:c1:1b:20:b8:f7 dst 127.0.0.1 self 00:00:00:34:8d:90 dst 10.2.1.12 self e2:2d:32:6d:95:70 dst 127.0.0.1 self The following entries there are new: 0a:ce:c4:f7:cb:dc dst 10.2.1.12 self 00:00:00:34:8d:90 dst 10.2.1.12 self These new entries: Add our new instance to the mesh (00:00:00:34:8d:90) And add vxlan-2 on sf-2 to the mesh (0a:ce:c4:f7:cb:dc) To repeat some commands from above but on sf-2, we now have two new network interfaces over there: sf-2 # ip addr list vxlan-2 127: vxlan-2: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 8950 qdisc noqueue master br-vxlan-2 state UNKNOWN group default qlen 1000 link/ether 0a:ce:c4:f7:cb:dc brd ff:ff:ff:ff:ff:ff inet6 fe80::8ce:c4ff:fef7:cbdc/64 scope link valid_lft forever preferred_lft forever sf-2 # ip addr show br-vxlan-2 128: br-vxlan-2: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 8950 qdisc noqueue state UP group default qlen 1000 link/ether 0a:ce:c4:f7:cb:dc brd ff:ff:ff:ff:ff:ff inet6 fe80::8ce:c4ff:fef7:cbdc/64 scope link valid_lft forever preferred_lft forever And the mesh looks like this: sf-2 # bridge fdb show brport vxlan-2 0a:ce:c4:f7:cb:dc master br-vxlan-2 permanent 0a:ce:c4:f7:cb:dc vlan 1 master br-vxlan-2 permanent 00:00:00:00:00:00 dst 10.2.1.11 self permanent 00:00:00:00:00:00 dst 10.2.1.12 self permanent 0a:ce:c4:f7:cb:dc dst 127.0.0.1 self 00:00:00:34:8d:90 dst 127.0.0.1 self e2:2d:32:6d:95:70 dst 10.2.1.11 self There is no network namespace on sf-2: sf-2 # ls /var/run/netns ls: cannot access '/var/run/netns': No such file or directory If we grep the console log of the instance on sf-2, we can see what cloud-init thought about the networking: sf-1 # grep ci-info /srv/shakenfist/instances/d53b345f-9d5d-493c-a1a3-7e7d6513cfa2/console.log [ 9.851378] cloud-init[643]: ci-info: +++++++++++++++++++++++++++++++++++++Net device info++++++++++++++++++++++++++++++++++++++ [ 9.856401] cloud-init[643]: ci-info: +--------+------+---------------------------+---------------+--------+-------------------+ [ 9.858628] cloud-init[643]: ci-info: | Device | Up | Address | Mask | Scope | Hw-Address | [ 9.862566] cloud-init[643]: ci-info: +--------+------+---------------------------+---------------+--------+-------------------+ [ 9.873611] cloud-init[643]: ci-info: | eth0 | True | 192.168.0.3 | 255.255.255.0 | global | 00:00:00:34:8d:90 | [ 9.884575] cloud-init[643]: ci-info: | eth0 | True | fe80::200:ff:fe34:8d90/64 | . | link | 00:00:00:34:8d:90 | [ 9.896315] cloud-init[643]: ci-info: | lo | True | 127.0.0.1 | 255.0.0.0 | host | . | [ 9.899272] cloud-init[643]: ci-info: | lo | True | ::1/128 | . | host | . | [ 9.904106] cloud-init[643]: ci-info: +--------+------+---------------------------+---------------+--------+-------------------+ [ 9.907816] cloud-init[643]: ci-info: +++++++++++++++++++++++++++++Route IPv4 info+++++++++++++++++++++++++++++ [ 9.912118] cloud-init[643]: ci-info: +-------+-------------+-------------+---------------+-----------+-------+ [ 9.913889] cloud-init[643]: ci-info: | Route | Destination | Gateway | Genmask | Interface | Flags | [ 9.917853] cloud-init[643]: ci-info: +-------+-------------+-------------+---------------+-----------+-------+ [ 9.920102] cloud-init[643]: ci-info: | 0 | 0.0.0.0 | 192.168.0.1 | 0.0.0.0 | eth0 | UG | [ 9.926243] cloud-init[643]: ci-info: | 1 | 192.168.0.0 | 0.0.0.0 | 255.255.255.0 | eth0 | U | [ 9.929182] cloud-init[643]: ci-info: +-------+-------------+-------------+---------------+-----------+-------+ [ 9.935249] cloud-init[643]: ci-info: +++++++++++++++++++Route IPv6 info+++++++++++++++++++ [ 9.942774] cloud-init[643]: ci-info: +-------+-------------+---------+-----------+-------+ [ 9.956377] cloud-init[643]: ci-info: | Route | Destination | Gateway | Interface | Flags | [ 9.959651] cloud-init[643]: ci-info: +-------+-------------+---------+-----------+-------+ [ 9.965082] cloud-init[643]: ci-info: | 1 | fe80::/64 | :: | eth0 | U | [ 9.968116] cloud-init[643]: ci-info: | 3 | local | :: | eth0 | U | [ 9.970423] cloud-init[643]: ci-info: | 4 | ff00::/8 | :: | eth0 | U | [ 9.974926] cloud-init[643]: ci-info: +-------+-------------+---------+-----------+-------+ ci-info: no authorized SSH keys fingerprints found for user ubuntu. [ 69.743452] cloud-init[970]: ci-info: no authorized SSH keys fingerprints found for user ubuntu. Here you can see that instance has an interface named eth0, which has the IP address that Shaken Fist allocated earlier. How did it get an IP address without DHCP? Well, Shaken Fist always attaches a config drive to the instance, and this contains a JSON file with the IP address in it. cloud-init running on boot of Ubuntu has used this to configure the interface. Before we poke more at this instance, let's start another instance on sf-3 so we can do some more testing...","title":"Single Instance"},{"location":"networking/single_instance/#networking-explained-single-node","text":"This page is part of a series explaining how Shaken Fist networking works . You might want to check out the other pages as well.","title":"Networking Explained - Single Node"},{"location":"networking/single_instance/#the-simplest-case-a-virtual-network-with-no-dhcp-and-no-nat-and-a-single-remote-instance","text":"Let's assume you want a new virtual network with no network services. Its just two instances talking to each other. The basic flow is like this -- you create a virtual network. We allocate you a VXLAN network id (called the vxid in various places in the code): sf-1 # sf-client network create 192.168.0.0/24 demonet --no-dhcp --no-nat uuid : b41b067a-44b7-40c5-9ab8-7abdcf5fdc61 name : demonet vxlan id : 2 netblock : 192.168.0.0/24 provide dhcp : False provide nat : False floating gateway: None namespace : system state : initial Metadata: So in this case we were allocated VXLAN id 2, and have a network UUID of b41b067a-44b7-40c5-9ab8-7abdcf5fdc61. The state of the network is \"initial\" as it has not been created anywhere yet. If you wait a few seconds, you'll see it transition to a \"created\" state. You can see the new state with a show command: sf-1 # sf-client network show b41b067a-44b7-40c5-9ab8-7abdcf5fdc61 uuid : b41b067a-44b7-40c5-9ab8-7abdcf5fdc61 name : demonet vxlan id : 2 netblock : 192.168.0.0/24 provide dhcp : False provide nat : False floating gateway: None namespace : system state : created Metadata: And you can see the steps we went through to create the network in the events listing: sf-1 # sf-client network events b41b067a-44b7-40c5-9ab8-7abdcf5fdc61 +----------------------------+------+------------------------+------------+----------------------+-----------+ | timestamp | node | operation | phase | duration | message | +----------------------------+------+------------------------+------------+----------------------+-----------+ | 2020-08-01 06:49:07.753351 | sf-1 | api | create | None | None | | 2020-08-01 06:49:07.792583 | sf-1 | create vxlan interface | start | None | None | | 2020-08-01 06:49:07.819312 | sf-1 | create vxlan interface | finish | 0.025562286376953125 | None | | 2020-08-01 06:49:07.840636 | sf-1 | create vxlan bridge | start | None | None | | 2020-08-01 06:49:07.905165 | sf-1 | create vxlan bridge | finish | 0.0644679069519043 | None | | 2020-08-01 06:49:07.910409 | sf-1 | create netns | start | None | None | | 2020-08-01 06:49:07.997595 | sf-1 | create netns | finish | 0.0850062370300293 | None | | 2020-08-01 06:49:08.016509 | sf-1 | create router veth | start | None | None | | 2020-08-01 06:49:08.237167 | sf-1 | create router veth | finish | 0.2197411060333252 | None | | 2020-08-01 06:49:08.254165 | sf-1 | create physical veth | start | None | None | | 2020-08-01 06:49:08.342684 | sf-1 | create physical veth | finish | 0.08613038063049316 | None | | 2020-08-01 06:49:08.371490 | sf-1 | add mesh elements | None | None | 10.2.1.11 | | 2020-08-01 06:49:08.375682 | sf-1 | api | created | None | None | | 2020-08-01 06:49:40.664204 | sf-1 | api | get | None | None | | 2020-08-01 06:50:07.554738 | sf-1 | api | get events | None | None | +----------------------------+------+------------------------+------------+----------------------+-----------+ You can see here that the network node (sf-1) has created some network elements, and an IP (10.2.1.11) has been added to the mesh. That IP is sf-1, and its part of the network node being joined to the mesh. If we look on sf-1, we should now have a VXLAN interface, a bridge, and one end of a veth. sf-1 # ip addr show vxlan-2 287: vxlan-2: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 8950 qdisc noqueue master br-vxlan-2 state UNKNOWN group default qlen 1000 link/ether de:c4:ab:3d:79:fb brd ff:ff:ff:ff:ff:ff inet6 fe80::dcc4:abff:fe3d:79fb/64 scope link valid_lft forever preferred_lft forever sf-1 # ip addr show br-vxlan-2 288: br-vxlan-2: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP group default qlen 1000 link/ether be:c1:1b:20:b8:f7 brd ff:ff:ff:ff:ff:ff inet6 fe80::bcc1:1bff:fe20:b8f7/64 scope link valid_lft forever preferred_lft forever sf-1 # ip addr show veth-2-o 290: veth-2-o@if289: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue master br-vxlan-2 state UP group default qlen 1000 link/ether be:c1:1b:20:b8:f7 brd ff:ff:ff:ff:ff:ff link-netnsid 0 inet6 fe80::bcc1:1bff:fe20:b8f7/64 scope link valid_lft forever preferred_lft forever The vxlan-2 interface is the VXLAN mesh, and the br-vxlan-2 bridge is how VMs and veths will connect to the mesh on this local machine. Its important to note that MTU matters here. The MTU for the mesh network is 1500 bytes, and most client VMs will default to that as well. Therefore the underlying network needs to have a MTU greater than that. We default to an MTU of 9000 bytes in our installs, but 1550 would in fact be sufficient in this case. You can see this in the MTU for vxlan-2, which is our 9000 byte underlying MTU, with 50 bytes deducted for the VXLAN encapsulation. We can also ask the mesh for its current state: sf-1 # bridge fdb show brport vxlan-2 de:c4:ab:3d:79:fb master br-vxlan-2 permanent de:c4:ab:3d:79:fb vlan 1 master br-vxlan-2 permanent 00:00:00:00:00:00 dst 10.2.1.11 self permanent de:c4:ab:3d:79:fb dst 127.0.0.1 self be:c1:1b:20:b8:f7 dst 127.0.0.1 self e2:2d:32:6d:95:70 dst 127.0.0.1 self The current members of the mesh are: de:c4:ab:3d:79:fb: this is the mac address for vxlan-2. 00:00:00:00:00:00 dst 10.2.1.11: this is a mesh entry for the node with IP 10.2.1.11 (sf-1) be:c1:1b:20:b8:f7: this is the outside mac address of a veth between br-vxlan-2 and a network namespace on sf-1 e2:2d:32:6d:95:70: is the inside mac address of the veth between br-vxlan-2 and the network namespace What is this network namespace? Well, Shaken Fist needs to create a network namespace to contain routing, NAT, and DHCP for the virtual network. It's actually not strictly required in this simplest case, but we always create it. It is named for the UUID of the virtual network: sf-1 # ip netns exec b41b067a-44b7-40c5-9ab8-7abdcf5fdc61 ip addr list 1: lo: <LOOPBACK> mtu 65536 qdisc noop state DOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 289: veth-2-i@if290: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP group default qlen 1000 link/ether e2:2d:32:6d:95:70 brd ff:ff:ff:ff:ff:ff link-netnsid 0 inet 192.168.0.1/24 scope global veth-2-i valid_lft forever preferred_lft forever inet6 fe80::e02d:32ff:fe6d:9570/64 scope link valid_lft forever preferred_lft forever 291: phy-2-i@if292: <BROADCAST,MULTICAST> mtu 1500 qdisc noop state DOWN group default qlen 1000 link/ether fe:18:8e:f8:d1:5c brd ff:ff:ff:ff:ff:ff link-netnsid 0 The veth between the VXLAN mesh and this namespace is named veth-2-i (the interface inside the network namespace) and veth-2-o (the interface outside the network namespace). There is another veth named phy-2-i and phy-2-o, which is a link between the namespace and the outside world, but we'll talk about that more when we enable NAT. For those who are new to veths, think of them like patch cables -- so what we have here is a VXLAN mesh, which is patched into a network namespace, which is in turn patched into the outside world. We also do some things with iptables, especially around NAT. Here's the current state of iptables in the network namespace: sf-1 # ip netns exec b41b067a-44b7-40c5-9ab8-7abdcf5fdc61 iptables -L -t nat Chain PREROUTING (policy ACCEPT) target prot opt source destination Chain INPUT (policy ACCEPT) target prot opt source destination Chain OUTPUT (policy ACCEPT) target prot opt source destination Chain POSTROUTING (policy ACCEPT) target prot opt source destination That's empty for now because we're not doing any NAT yet, but watch this space. Next let's now start an instance on sf-2. This instance can't use DHCP to get an address because we have that disabled for this network. sf-1 # sf-client instance create inst-on-sf-2 1 1024 -d 20@ubuntu:18.04 -n b41b067a-44b7-40c5-9ab8-7abdcf5fdc61 -p sf-2 uuid : d53b345f-9d5d-493c-a1a3-7e7d6513cfa2 name : inst-on-sf-2 namespace : system cpus : 1 memory : 1024 disk spec : type=disk bus=None size=20 base=ubuntu:18.04 video : model=cirrus memory=16384 node : sf-2 power state : on state : created console port: 48420 vdi port : 32122 ssh key : None user data : None Metadata: Interfaces: uuid : db372968-1c74-4033-8423-8a698e9d4900 network : b41b067a-44b7-40c5-9ab8-7abdcf5fdc61 macaddr : 00:00:00:34:8d:90 order : 0 ipv4 : 192.168.0.3 floating: None model : virtio You can see that our instance (inst-on-sf-2) has been placed on sf-2 because we asked nicely (the -p is a placement option to the command), and has been allocated an IP (192.168.0.3). The virtual network still allocates IPs, even if DHCP is disabled. It has also been allocated a MAC address (00:00:00:34:8d:90). What is the state of the mesh on the network node now? sf-1 # bridge fdb show brport vxlan-2 de:c4:ab:3d:79:fb master br-vxlan-2 permanent de:c4:ab:3d:79:fb vlan 1 master br-vxlan-2 permanent 00:00:00:00:00:00 dst 10.2.1.11 self permanent 0a:ce:c4:f7:cb:dc dst 10.2.1.12 self de:c4:ab:3d:79:fb dst 127.0.0.1 self be:c1:1b:20:b8:f7 dst 127.0.0.1 self 00:00:00:34:8d:90 dst 10.2.1.12 self e2:2d:32:6d:95:70 dst 127.0.0.1 self The following entries there are new: 0a:ce:c4:f7:cb:dc dst 10.2.1.12 self 00:00:00:34:8d:90 dst 10.2.1.12 self These new entries: Add our new instance to the mesh (00:00:00:34:8d:90) And add vxlan-2 on sf-2 to the mesh (0a:ce:c4:f7:cb:dc) To repeat some commands from above but on sf-2, we now have two new network interfaces over there: sf-2 # ip addr list vxlan-2 127: vxlan-2: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 8950 qdisc noqueue master br-vxlan-2 state UNKNOWN group default qlen 1000 link/ether 0a:ce:c4:f7:cb:dc brd ff:ff:ff:ff:ff:ff inet6 fe80::8ce:c4ff:fef7:cbdc/64 scope link valid_lft forever preferred_lft forever sf-2 # ip addr show br-vxlan-2 128: br-vxlan-2: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 8950 qdisc noqueue state UP group default qlen 1000 link/ether 0a:ce:c4:f7:cb:dc brd ff:ff:ff:ff:ff:ff inet6 fe80::8ce:c4ff:fef7:cbdc/64 scope link valid_lft forever preferred_lft forever And the mesh looks like this: sf-2 # bridge fdb show brport vxlan-2 0a:ce:c4:f7:cb:dc master br-vxlan-2 permanent 0a:ce:c4:f7:cb:dc vlan 1 master br-vxlan-2 permanent 00:00:00:00:00:00 dst 10.2.1.11 self permanent 00:00:00:00:00:00 dst 10.2.1.12 self permanent 0a:ce:c4:f7:cb:dc dst 127.0.0.1 self 00:00:00:34:8d:90 dst 127.0.0.1 self e2:2d:32:6d:95:70 dst 10.2.1.11 self There is no network namespace on sf-2: sf-2 # ls /var/run/netns ls: cannot access '/var/run/netns': No such file or directory If we grep the console log of the instance on sf-2, we can see what cloud-init thought about the networking: sf-1 # grep ci-info /srv/shakenfist/instances/d53b345f-9d5d-493c-a1a3-7e7d6513cfa2/console.log [ 9.851378] cloud-init[643]: ci-info: +++++++++++++++++++++++++++++++++++++Net device info++++++++++++++++++++++++++++++++++++++ [ 9.856401] cloud-init[643]: ci-info: +--------+------+---------------------------+---------------+--------+-------------------+ [ 9.858628] cloud-init[643]: ci-info: | Device | Up | Address | Mask | Scope | Hw-Address | [ 9.862566] cloud-init[643]: ci-info: +--------+------+---------------------------+---------------+--------+-------------------+ [ 9.873611] cloud-init[643]: ci-info: | eth0 | True | 192.168.0.3 | 255.255.255.0 | global | 00:00:00:34:8d:90 | [ 9.884575] cloud-init[643]: ci-info: | eth0 | True | fe80::200:ff:fe34:8d90/64 | . | link | 00:00:00:34:8d:90 | [ 9.896315] cloud-init[643]: ci-info: | lo | True | 127.0.0.1 | 255.0.0.0 | host | . | [ 9.899272] cloud-init[643]: ci-info: | lo | True | ::1/128 | . | host | . | [ 9.904106] cloud-init[643]: ci-info: +--------+------+---------------------------+---------------+--------+-------------------+ [ 9.907816] cloud-init[643]: ci-info: +++++++++++++++++++++++++++++Route IPv4 info+++++++++++++++++++++++++++++ [ 9.912118] cloud-init[643]: ci-info: +-------+-------------+-------------+---------------+-----------+-------+ [ 9.913889] cloud-init[643]: ci-info: | Route | Destination | Gateway | Genmask | Interface | Flags | [ 9.917853] cloud-init[643]: ci-info: +-------+-------------+-------------+---------------+-----------+-------+ [ 9.920102] cloud-init[643]: ci-info: | 0 | 0.0.0.0 | 192.168.0.1 | 0.0.0.0 | eth0 | UG | [ 9.926243] cloud-init[643]: ci-info: | 1 | 192.168.0.0 | 0.0.0.0 | 255.255.255.0 | eth0 | U | [ 9.929182] cloud-init[643]: ci-info: +-------+-------------+-------------+---------------+-----------+-------+ [ 9.935249] cloud-init[643]: ci-info: +++++++++++++++++++Route IPv6 info+++++++++++++++++++ [ 9.942774] cloud-init[643]: ci-info: +-------+-------------+---------+-----------+-------+ [ 9.956377] cloud-init[643]: ci-info: | Route | Destination | Gateway | Interface | Flags | [ 9.959651] cloud-init[643]: ci-info: +-------+-------------+---------+-----------+-------+ [ 9.965082] cloud-init[643]: ci-info: | 1 | fe80::/64 | :: | eth0 | U | [ 9.968116] cloud-init[643]: ci-info: | 3 | local | :: | eth0 | U | [ 9.970423] cloud-init[643]: ci-info: | 4 | ff00::/8 | :: | eth0 | U | [ 9.974926] cloud-init[643]: ci-info: +-------+-------------+---------+-----------+-------+ ci-info: no authorized SSH keys fingerprints found for user ubuntu. [ 69.743452] cloud-init[970]: ci-info: no authorized SSH keys fingerprints found for user ubuntu. Here you can see that instance has an interface named eth0, which has the IP address that Shaken Fist allocated earlier. How did it get an IP address without DHCP? Well, Shaken Fist always attaches a config drive to the instance, and this contains a JSON file with the IP address in it. cloud-init running on boot of Ubuntu has used this to configure the interface. Before we poke more at this instance, let's start another instance on sf-3 so we can do some more testing...","title":"The simplest case: a virtual network with no DHCP and no NAT, and a single remote instance"}]}