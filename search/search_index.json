{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Shaken Fist, a minimal cloud aimed at small and edge deployments Shaken Fist is a deliberately minimal cloud intended for small deployments. We spend a lot of time trying to do the simplest possible thing well, and keep our resource usage on idle deployments as low as possible. Shaken Fist also currently a work in progress, so take statements here with a grain of salt. Shaken Fist started a personal research project, but has grown into something which is starting to see wider contributions and some small commercial deployments. Here's a simple feature matrix: Feature Implemented Planned Not Planned Servers / instances v0.1 Networks v0.1 Multiple NIC's for a given server v0.1 Pre-cache a server image v0.1 Floating IPs v0.1 Pause v0.1 Reboot (hard and soft) v0.1 Security groups Yes Text console v0.1 VDI v0.1 User data v0.1 Keypairs v0.1 Virtual networks allow overlapping IP allocations v0.1 REST API authentication and object ownership v0.2 Snapshots (of all disks) v0.1 Central API service v0.1 Scheduling v0.1 Volumes No plans Quotas No plans API versioning No plans Keystone style service lookup and URLs No plans Create multiple servers in a single request No plans Resize a server No plans Server groups No plans Change admin password No plans Rebuild a server No plans Shelve / unshelve No plans Trigger crash dump No plans Live migration No plans Flavors No plans Guest agents No plans Host aggregates No plans Server tags v0.2, we call them \"metadata\" ~~Persistence in MySQL~~ v0.1 Distributed etcd for locking and persistence v0.2 Production grade REST API via gunicorn v0.2 Python REST API client v0.1 golang REST API client v0.2 Terraform provider v0.2 The underlying idea Originally Shaken Fist came about as a reaction to the increasing complexity of OpenStack, as well as a desire to experiment with alternative approaches to solving the problems that OpenStack Compute addresses. What I really wanted was a simple API to orchestrate virtual machines, but it needed to run with minimal resource overhead and be simple to deploy. I also wanted it to always work in a predictable way. One of the reasons OpenStack is so complicated and its behaviour varies is because it has many options to configure. The solution seemed obvious to me -- a cloud that is super opinionated. For each different functional requirement there is one option, and the simplest option is chosen where possible. Read on for some examples. Development choices If there is an existing library which does a thing, we use it. OpenStack suffered from being old (and having issues with re-writes being hard), as well as licensing constraints. We just use the code that others have provided to the community. Always. Deployment choices libvirt is the only supported hypervisor. Instances are specified to libvirt with simple templated XML. If your local requirements are different to what's in the template, you're welcome to change the template to meet your needs. If your template changes break things, you're also welcome to debug what went wrong for yourself. We provide a sample Ansible based deployer in the deploy directory. Here's what I said when the project was first announced To give you a basic flavour of the intent of Shaken Fist, here's what I said when I first announced the project. For at least six months I\u2019ve felt the desire for a simpler cloud orchestration layer \u2014 both for my own personal uses, and also as a test bed for ideas for what a smaller, simpler cloud might look like. My personal use case involves a relatively small environment which echoes what we now think of as edge compute \u2014 less than 10 RU of machines with a minimum of orchestration and management overhead. At the time that I was thinking about these things, the Australian bush fires and COVID-19 came along, and presented me with a lot more spare time than I had expected to have. While I\u2019m still blessed to be employed, all of my social activities have been cancelled, so I find myself at home at a loose end on weekends and evenings a lot more than before. Thus Shaken Fist was born \u2014 named for a Simpson\u2019s meme, Shaken Fist is a deliberately small and highly opinionated cloud implementation aimed at working well in small deployments such as homes, labs, edge compute locations, deployed systems, and so forth. I\u2019d taken a bit of trouble with each feature in Shaken Fist to think through what the simplest and highest value way of doing something is. For example, instances always get a config drive and there is no metadata server. There is also only one supported type of virtual networking, and one supported hypervisor. That said, this means Shaken Fist is less than 5,000 lines of code, and small enough that new things can be implemented very quickly by a single middle aged developer. I think Shaken Fist is useful to others. Its Apache-2.0 licensed, and available on github if you\u2019re interested. \"I'd like to subscribe to your newsletter\" First off, we don't have a newsletter. That said, updates will be announced here as they happen. What we do have is useful links: The Shaken Fist repository is where the code for the server is, including the deployer. Its a good place to start. There are a series of client repositories as well: The python client repository contains the python API client, as well as the command line client that users and shell scripts use to interact with Shaken Fist. The golang client repository contains... wait for it... the golang client library. This is used by the terraform provider. The javascript client repository contains... wait for it... a javascript client library. It should be noted that this client is currently incomplete. The terraform provider repository has a Terraform provider for Shaken Fist which uses the golang client. The ansible modules repository contains a few simple modules for using Shaken Fist in ansible roles and plays. We also have a few \"more internal\" repositories: The load test repository contains a simpler load tester we use for validating releases. The reproducibles repository contains simple test cases for reproducing strange behaviours we have seen while developing Shaken Fist. What is Shaken Fist? Can I help? Shaken Fist Manifesto New user guides We need more of these. For now, we have the following: An installation guide A user guide , which is currently incomplete but better than nothing. Release changelogs Version v0.2 was when we started taking releases and upgrades seriously. Thus, its also when we started writing changelogs: v0.3 series v0.2 series API documentation There is some limited API documentation, its definitely a known gap. The power states an instance can be in Documentation for developers of Shaken Fist We have release documentation . We found this mildly surprising too. Everyone is confused by the networking, so we wrote some networking documentation . Hopefully it helps.","title":"Introduction"},{"location":"#shaken-fist-a-minimal-cloud-aimed-at-small-and-edge-deployments","text":"Shaken Fist is a deliberately minimal cloud intended for small deployments. We spend a lot of time trying to do the simplest possible thing well, and keep our resource usage on idle deployments as low as possible. Shaken Fist also currently a work in progress, so take statements here with a grain of salt. Shaken Fist started a personal research project, but has grown into something which is starting to see wider contributions and some small commercial deployments. Here's a simple feature matrix: Feature Implemented Planned Not Planned Servers / instances v0.1 Networks v0.1 Multiple NIC's for a given server v0.1 Pre-cache a server image v0.1 Floating IPs v0.1 Pause v0.1 Reboot (hard and soft) v0.1 Security groups Yes Text console v0.1 VDI v0.1 User data v0.1 Keypairs v0.1 Virtual networks allow overlapping IP allocations v0.1 REST API authentication and object ownership v0.2 Snapshots (of all disks) v0.1 Central API service v0.1 Scheduling v0.1 Volumes No plans Quotas No plans API versioning No plans Keystone style service lookup and URLs No plans Create multiple servers in a single request No plans Resize a server No plans Server groups No plans Change admin password No plans Rebuild a server No plans Shelve / unshelve No plans Trigger crash dump No plans Live migration No plans Flavors No plans Guest agents No plans Host aggregates No plans Server tags v0.2, we call them \"metadata\" ~~Persistence in MySQL~~ v0.1 Distributed etcd for locking and persistence v0.2 Production grade REST API via gunicorn v0.2 Python REST API client v0.1 golang REST API client v0.2 Terraform provider v0.2","title":"Shaken Fist, a minimal cloud aimed at small and edge deployments"},{"location":"#the-underlying-idea","text":"Originally Shaken Fist came about as a reaction to the increasing complexity of OpenStack, as well as a desire to experiment with alternative approaches to solving the problems that OpenStack Compute addresses. What I really wanted was a simple API to orchestrate virtual machines, but it needed to run with minimal resource overhead and be simple to deploy. I also wanted it to always work in a predictable way. One of the reasons OpenStack is so complicated and its behaviour varies is because it has many options to configure. The solution seemed obvious to me -- a cloud that is super opinionated. For each different functional requirement there is one option, and the simplest option is chosen where possible. Read on for some examples.","title":"The underlying idea"},{"location":"#development-choices","text":"If there is an existing library which does a thing, we use it. OpenStack suffered from being old (and having issues with re-writes being hard), as well as licensing constraints. We just use the code that others have provided to the community. Always.","title":"Development choices"},{"location":"#deployment-choices","text":"libvirt is the only supported hypervisor. Instances are specified to libvirt with simple templated XML. If your local requirements are different to what's in the template, you're welcome to change the template to meet your needs. If your template changes break things, you're also welcome to debug what went wrong for yourself. We provide a sample Ansible based deployer in the deploy directory.","title":"Deployment choices"},{"location":"#heres-what-i-said-when-the-project-was-first-announced","text":"To give you a basic flavour of the intent of Shaken Fist, here's what I said when I first announced the project. For at least six months I\u2019ve felt the desire for a simpler cloud orchestration layer \u2014 both for my own personal uses, and also as a test bed for ideas for what a smaller, simpler cloud might look like. My personal use case involves a relatively small environment which echoes what we now think of as edge compute \u2014 less than 10 RU of machines with a minimum of orchestration and management overhead. At the time that I was thinking about these things, the Australian bush fires and COVID-19 came along, and presented me with a lot more spare time than I had expected to have. While I\u2019m still blessed to be employed, all of my social activities have been cancelled, so I find myself at home at a loose end on weekends and evenings a lot more than before. Thus Shaken Fist was born \u2014 named for a Simpson\u2019s meme, Shaken Fist is a deliberately small and highly opinionated cloud implementation aimed at working well in small deployments such as homes, labs, edge compute locations, deployed systems, and so forth. I\u2019d taken a bit of trouble with each feature in Shaken Fist to think through what the simplest and highest value way of doing something is. For example, instances always get a config drive and there is no metadata server. There is also only one supported type of virtual networking, and one supported hypervisor. That said, this means Shaken Fist is less than 5,000 lines of code, and small enough that new things can be implemented very quickly by a single middle aged developer. I think Shaken Fist is useful to others. Its Apache-2.0 licensed, and available on github if you\u2019re interested.","title":"Here's what I said when the project was first announced"},{"location":"#id-like-to-subscribe-to-your-newsletter","text":"First off, we don't have a newsletter. That said, updates will be announced here as they happen. What we do have is useful links: The Shaken Fist repository is where the code for the server is, including the deployer. Its a good place to start. There are a series of client repositories as well: The python client repository contains the python API client, as well as the command line client that users and shell scripts use to interact with Shaken Fist. The golang client repository contains... wait for it... the golang client library. This is used by the terraform provider. The javascript client repository contains... wait for it... a javascript client library. It should be noted that this client is currently incomplete. The terraform provider repository has a Terraform provider for Shaken Fist which uses the golang client. The ansible modules repository contains a few simple modules for using Shaken Fist in ansible roles and plays. We also have a few \"more internal\" repositories: The load test repository contains a simpler load tester we use for validating releases. The reproducibles repository contains simple test cases for reproducing strange behaviours we have seen while developing Shaken Fist.","title":"\"I'd like to subscribe to your newsletter\""},{"location":"#what-is-shaken-fist-can-i-help","text":"Shaken Fist Manifesto","title":"What is Shaken Fist? Can I help?"},{"location":"#new-user-guides","text":"We need more of these. For now, we have the following: An installation guide A user guide , which is currently incomplete but better than nothing.","title":"New user guides"},{"location":"#release-changelogs","text":"Version v0.2 was when we started taking releases and upgrades seriously. Thus, its also when we started writing changelogs: v0.3 series v0.2 series","title":"Release changelogs"},{"location":"#api-documentation","text":"There is some limited API documentation, its definitely a known gap. The power states an instance can be in","title":"API documentation"},{"location":"#documentation-for-developers-of-shaken-fist","text":"We have release documentation . We found this mildly surprising too. Everyone is confused by the networking, so we wrote some networking documentation . Hopefully it helps.","title":"Documentation for developers of Shaken Fist"},{"location":"community/","text":"Welcome to the Shaken Fist community First off, Shaken Fist is an open source project covered by the Apache2 license. The community is relatively small at this point and we're still working out what works for us. For now, we communicate through the following mechanisms: github issues and pull requests in the various repositories a slack workspace at https://shakenfist.slack.com -- unfortunately you need to be invited to that workspace, but we're happy to do that. If you're interested, please email mikal@stillhq.com Supporters We try to track supporters here. Our apologies if we've missed someone, let us know and we'll fix it. Michael Still and Andrew McCallum have contributed significant personal time to the project. FifthDomain has donated significant developer time as well. Shaken Fist was a recipient of a 2020 Icculus micro grant .","title":"Community"},{"location":"community/#welcome-to-the-shaken-fist-community","text":"First off, Shaken Fist is an open source project covered by the Apache2 license. The community is relatively small at this point and we're still working out what works for us. For now, we communicate through the following mechanisms: github issues and pull requests in the various repositories a slack workspace at https://shakenfist.slack.com -- unfortunately you need to be invited to that workspace, but we're happy to do that. If you're interested, please email mikal@stillhq.com","title":"Welcome to the Shaken Fist community"},{"location":"community/#supporters","text":"We try to track supporters here. Our apologies if we've missed someone, let us know and we'll fix it. Michael Still and Andrew McCallum have contributed significant personal time to the project. FifthDomain has donated significant developer time as well. Shaken Fist was a recipient of a 2020 Icculus micro grant .","title":"Supporters"},{"location":"installation/","text":"Installing Shaken Fist This guide will assume that you want to install Shaken Fist on a single local machine (that is, the one you're going to run ansible on). This is by no means the only installation option, but is the most simple to get people started. Shaken Fist only supports Ubuntu 18.04 or later but we strongly recommend 20.04 or higher, so if you're running on localhost that implies that you must be running a recent Ubuntu on your development machine. Note as well that the deployer installs software and changes the configuration of your networking, so be careful when running it on machines you are fond of. Note that we used to recommend deployers run the installer from git, but we've outgrown that approach. If you see that mentioned in the documentation, you are likely reading outdated guides. First install some dependancies: sudo apt-get update sudo apt-get -y dist-upgrade sudo apt-get -y install ansible tox pwgen build-essential python3-dev python3-wheel \\ python3-pip curl ansible vim git pwgen sudo ansible-galaxy install andrewrothstein.etcd-cluster andrewrothstein.terraform \\ andrewrothstein.go And then manually upgrade pip: sudo pip3 install -U pip sudo apt-get remove -y python3-pip Next install your desired Shaken Fist pip package. The default should be the latest release. sudo pip install -U shakenfist shakenfist_client And then run the installer. We describe the correct invocation for a local development environment in the section below. Local Development Shaken Fist uses ansible as its installer, with terraform to bring up cloud resources. Because we're going to install Shaken Fist on localhost, there isn't much terraform in this example. Installation is run by a simple wrapper called \"install.sh\". We also make the assumption that developer laptops move around more than servers. In a traditional install we detect the primary NIC of the machine and then use that to build VXLAN meshes. For localhost single node deploys we instead create a bridge called \"brsf\" and then use that as our primary NIC. This means your machine can move around and have different routes to the internet over time, but it also means its fiddly to convert a localhost install into a real production cluster. Please only use localhost installs for development purposes. sudo CLOUD=localhost /usr/local/share/shakenfist/installer/install.sh Your first instance Before you can start your first instance you'll need to authenticate to Shaken Fist, and create a network. Shaken Fist's python api client (as used by the command line client) looks for authentication details in the following locations: Command line flags Environment variables (prefixed with SHAKENFIST_ ) ~/.shakenfist , a JSON formatted configuration file /etc/sf/shakenfist.json , the same file as above, but global By default the installer creates /etc/sf/sfrc , which sets the required environment variables to authenticate. It is customized per installation, setting the following variables: SHAKENFIST_NAMESPACE , the namespace to create resources in SHAKENFIST_KEY , an authentication key for that namespace SHAKENFIST_API_URL , a URL to the Shaken Fist API server Before interacting with Shaken Fist, we need to source the rc file. . /etc/sf/sfrc Instances must be launched attached to a network. Create your first network: sf-client network create mynet 192.168.42.0/24 You can get help for the command line client by running `sf-client --help . The above command creates a new network called \"mynet\", with the IP block 192.168.42.0/24. You will receive some descriptive output back: $ sf-client network create mynet 192.168.42.0/24 uuid : 16baa325-5adf-473f-8e7a-75710a822d45 name : mynet vxlan id : 2 netblock : 192.168.42.0/24 provide dhcp : True provide nat : True floating gateway: None namespace : system state : initial Metadata: The UUID is important, as that is how we will refer to the network elsewhere. Let's now create a simple first instance (you'll need to change this to use your actual network UUID): $ sf-client instance create myvm 1 1024 -d 8@cirros -n 16baa325-5adf-473f-8e7a-75710a822d45 uuid : c6c4ba94-ed34-497d-8964-c223489dee3e name : myvm namespace : system cpus : 1 memory : 1024 disk spec : type=disk bus=None size=8 base=cirros video : model=cirrus memory=16384 node : marvin power state : on state : created console port: 31839 vdi port : 34442 ssh key : None user data : None Metadata: Interfaces: uuid : e56b3c7b-8056-4645-b5b5-1779721ff21d network : 16baa325-5adf-473f-8e7a-75710a822d45 macaddr : ae:15:4d:9c:d8:c0 order : 0 ipv4 : 192.168.42.76 floating: None model : virtio Probably the easiest way to interact with this instance is to connect to its console port, which is the serial console of the instance over telnet. In the case above, that is available on port 31829 on localhost (my laptop is called marvin). Real world cluster deployments It is probably best to start with a localhost deployment first to become familiar with Shaken Fist. From that, you can build out your real world deployment. Deployments are based on Hashicorp terraform configuration found in deploy/ansible/terraform/ where \"cloud\" is one of the following at the time of writing: aws: Amazon EC2 bare metal (3 node cluster) aws-single-node: Amazon EC2 bare metal (1 node cluster), note that the CI tests will not pass on a single node cluster gcp: Google cloud, using nested virtualization (see additional steps below). This deployment option is not for production use because of its lack of bare metal support and low MTUs affecting virtual network performance. We mainly use it for CI testing. metal: Baremetal provisioned outside of terraform openstack: OpenStack, using nested virtualization shakenfist: Shaken Fist can self host, this is useful for CI for example Common first steps sudo apt-get install ansible tox pwgen build-essential python3-dev python3-wheel curl git clone https://github.com/shakenfist/deploy ansible-galaxy install andrewrothstein.etcd-cluster andrewrothstein.terraform andrewrothstein.go Google Cloud additional first steps On Google Cloud, you need to enable nested virt first: # Create an image with nested virt enabled (only once) gcloud compute disks create sf-source-disk --image-project ubuntu-os-cloud \\ --image-family ubuntu-1804-lts --zone us-central1-b gcloud compute images create sf-image \\ --source-disk sf-source-disk --source-disk-zone us-central1-b \\ --licenses \"https://compute.googleapis.com/compute/v1/projects/vm-options/global/licenses/enable-vmx\" Please note that the gcp-xl cloud is a special definition used for larger scale CI testing. You're welcome to use it, but it does assume that the node performing the deployment is a Google cloud instance. VMWare ESXi additional first steps The \"metal\" installation option can be used to create a test cluster on VMWare ESXi hypervisors. Virtual machines hosted under ESXi need two CPU options enabled. Hardware virtualization: Expose hardware assisted virtualization to the guest OS Performance counters: Enable virtualized CPU performance counters Other caveats The installer will also enforce the following sanity checks: That KVM will operate on your machines. This is generally fine unless you're using virtual machines at which point nested virtualization needs to be enabled. That your network interface MTU is greater than 2,000 bytes. This is required because the VXLAN mesh our virtual networks use add overhead to packets and a standard MTU of 1500 bytes for the physical network will result in packets being fragmented too frequently on the virtual networks. You can set a higher MTU if you desire, I generally select 9,000 bytes. Deployment Each deployment takes slight different arguments. I tend to write a small shell script to wrap these up for convenience. Here's an example for a baremetal deployment: $ cat ~/sf-deploys/cbr-remote.sh #!/bin/bash export CLOUD=metal export ADMIN_PASSWORD=\"p4ssw0rd\" export FLOATING_IP_BLOCK=\"192.168.20.0/24\" export BOOTDELAY=0 # Tests are not currently safe for clusters whose data you are fond of export SKIP_SF_TESTS=1 ./deployandtest.sh I then execute that script from the deploy/ansible directory to do a deployment or upgrade. Note that running the CI suite will destroy the contents of your cloud so be sure to use SKIP_SF_TESTS if you're upgrading a cluster with real users. Deployment variables Option Terraform definition Description MODE All Options are \"deploy\" (the default) or \"hotfix\". Deploy performs a full install, whereas hotfix skips steps to try and push only changes to Shaken Fist code as quickly as possible. RELEASE All Which release to run. This can be a version number from pypi, the keyword \"git:\" for the current state of master, or \"git:branch\" to use a branch called \"branch\" from your local git. CLOUD All The terraform definition to use ADMIN_PASSWORD All The admin password for the cloud once installed FLOATING_IP_BLOCK All The IP range to use for the floating network BOOTDELAY All How long to wait for terraform deployed instances to boot before continuing with install, in minutes SKIP_SF_TEST All Set to 1 to skip running destructive testing of the cloud KSM_ENABLED All Set to 1 to enable KSM, 0 to disable DEPLOY_NAME All The name of the deployment to use as an external label for prometheus AWS_REGION aws, aws-single-node The AWS region to deploy in AWS_AVAILABILITY_ZONE aws, aws-single-node The AWS availability zone to deploy in AWS_VPC_ID aws, aws-single-node The AWS VPC to use AWS_SSH_KEY_NAME aws, aws-single-node The name of an SSH key in the AWS region to use for ansible GCP_PROJECT gcp, gcp-xl The GCP project id to deploy in GCP_SSH_KEY_FILENAME gcp, gcp-xl The path to a ssh private key file to use for authentication. It is assumed that the public key is at ${GCP_SSH_KEY_FILENAME}.pub . (optional, only required if not using gcloud). GCP_SSH_USER gcp, gcp-xl The username to add the GCP_SSH_KEY to. (optional, only used if GCPSSH_KEY_FILENAME is set). OS_SSH_KEY_NAME openstack The name of a SSH key in the OpenStack cloud to use for ansible OS_FLAVOR_NAME openstack The OpenStack flavor to use for instances OS_EXTERNAL_NET_NAME openstack The UUID of an OpenStack network with internet access METAL_IP_SF1 metal The IP address of a baremetal machine METAL_IP_SF2 metal The IP address of a baremetal machine METAL_IP_SF3 metal The IP address of a baremetal machine SHAKENFIST_KEY shakenfist The authentication key for a user on the shakenfist cluster to deploy in SHAKENFIST_SSH_KEY shakenfist The path to a SSH key to use for ansible","title":"Installation"},{"location":"installation/#installing-shaken-fist","text":"This guide will assume that you want to install Shaken Fist on a single local machine (that is, the one you're going to run ansible on). This is by no means the only installation option, but is the most simple to get people started. Shaken Fist only supports Ubuntu 18.04 or later but we strongly recommend 20.04 or higher, so if you're running on localhost that implies that you must be running a recent Ubuntu on your development machine. Note as well that the deployer installs software and changes the configuration of your networking, so be careful when running it on machines you are fond of. Note that we used to recommend deployers run the installer from git, but we've outgrown that approach. If you see that mentioned in the documentation, you are likely reading outdated guides. First install some dependancies: sudo apt-get update sudo apt-get -y dist-upgrade sudo apt-get -y install ansible tox pwgen build-essential python3-dev python3-wheel \\ python3-pip curl ansible vim git pwgen sudo ansible-galaxy install andrewrothstein.etcd-cluster andrewrothstein.terraform \\ andrewrothstein.go And then manually upgrade pip: sudo pip3 install -U pip sudo apt-get remove -y python3-pip Next install your desired Shaken Fist pip package. The default should be the latest release. sudo pip install -U shakenfist shakenfist_client And then run the installer. We describe the correct invocation for a local development environment in the section below.","title":"Installing Shaken Fist"},{"location":"installation/#local-development","text":"Shaken Fist uses ansible as its installer, with terraform to bring up cloud resources. Because we're going to install Shaken Fist on localhost, there isn't much terraform in this example. Installation is run by a simple wrapper called \"install.sh\". We also make the assumption that developer laptops move around more than servers. In a traditional install we detect the primary NIC of the machine and then use that to build VXLAN meshes. For localhost single node deploys we instead create a bridge called \"brsf\" and then use that as our primary NIC. This means your machine can move around and have different routes to the internet over time, but it also means its fiddly to convert a localhost install into a real production cluster. Please only use localhost installs for development purposes. sudo CLOUD=localhost /usr/local/share/shakenfist/installer/install.sh","title":"Local Development"},{"location":"installation/#your-first-instance","text":"Before you can start your first instance you'll need to authenticate to Shaken Fist, and create a network. Shaken Fist's python api client (as used by the command line client) looks for authentication details in the following locations: Command line flags Environment variables (prefixed with SHAKENFIST_ ) ~/.shakenfist , a JSON formatted configuration file /etc/sf/shakenfist.json , the same file as above, but global By default the installer creates /etc/sf/sfrc , which sets the required environment variables to authenticate. It is customized per installation, setting the following variables: SHAKENFIST_NAMESPACE , the namespace to create resources in SHAKENFIST_KEY , an authentication key for that namespace SHAKENFIST_API_URL , a URL to the Shaken Fist API server Before interacting with Shaken Fist, we need to source the rc file. . /etc/sf/sfrc Instances must be launched attached to a network. Create your first network: sf-client network create mynet 192.168.42.0/24 You can get help for the command line client by running `sf-client --help . The above command creates a new network called \"mynet\", with the IP block 192.168.42.0/24. You will receive some descriptive output back: $ sf-client network create mynet 192.168.42.0/24 uuid : 16baa325-5adf-473f-8e7a-75710a822d45 name : mynet vxlan id : 2 netblock : 192.168.42.0/24 provide dhcp : True provide nat : True floating gateway: None namespace : system state : initial Metadata: The UUID is important, as that is how we will refer to the network elsewhere. Let's now create a simple first instance (you'll need to change this to use your actual network UUID): $ sf-client instance create myvm 1 1024 -d 8@cirros -n 16baa325-5adf-473f-8e7a-75710a822d45 uuid : c6c4ba94-ed34-497d-8964-c223489dee3e name : myvm namespace : system cpus : 1 memory : 1024 disk spec : type=disk bus=None size=8 base=cirros video : model=cirrus memory=16384 node : marvin power state : on state : created console port: 31839 vdi port : 34442 ssh key : None user data : None Metadata: Interfaces: uuid : e56b3c7b-8056-4645-b5b5-1779721ff21d network : 16baa325-5adf-473f-8e7a-75710a822d45 macaddr : ae:15:4d:9c:d8:c0 order : 0 ipv4 : 192.168.42.76 floating: None model : virtio Probably the easiest way to interact with this instance is to connect to its console port, which is the serial console of the instance over telnet. In the case above, that is available on port 31829 on localhost (my laptop is called marvin).","title":"Your first instance"},{"location":"installation/#real-world-cluster-deployments","text":"It is probably best to start with a localhost deployment first to become familiar with Shaken Fist. From that, you can build out your real world deployment. Deployments are based on Hashicorp terraform configuration found in deploy/ansible/terraform/ where \"cloud\" is one of the following at the time of writing: aws: Amazon EC2 bare metal (3 node cluster) aws-single-node: Amazon EC2 bare metal (1 node cluster), note that the CI tests will not pass on a single node cluster gcp: Google cloud, using nested virtualization (see additional steps below). This deployment option is not for production use because of its lack of bare metal support and low MTUs affecting virtual network performance. We mainly use it for CI testing. metal: Baremetal provisioned outside of terraform openstack: OpenStack, using nested virtualization shakenfist: Shaken Fist can self host, this is useful for CI for example","title":"Real world cluster deployments"},{"location":"installation/#common-first-steps","text":"sudo apt-get install ansible tox pwgen build-essential python3-dev python3-wheel curl git clone https://github.com/shakenfist/deploy ansible-galaxy install andrewrothstein.etcd-cluster andrewrothstein.terraform andrewrothstein.go","title":"Common first steps"},{"location":"installation/#google-cloud-additional-first-steps","text":"On Google Cloud, you need to enable nested virt first: # Create an image with nested virt enabled (only once) gcloud compute disks create sf-source-disk --image-project ubuntu-os-cloud \\ --image-family ubuntu-1804-lts --zone us-central1-b gcloud compute images create sf-image \\ --source-disk sf-source-disk --source-disk-zone us-central1-b \\ --licenses \"https://compute.googleapis.com/compute/v1/projects/vm-options/global/licenses/enable-vmx\" Please note that the gcp-xl cloud is a special definition used for larger scale CI testing. You're welcome to use it, but it does assume that the node performing the deployment is a Google cloud instance.","title":"Google Cloud additional first steps"},{"location":"installation/#vmware-esxi-additional-first-steps","text":"The \"metal\" installation option can be used to create a test cluster on VMWare ESXi hypervisors. Virtual machines hosted under ESXi need two CPU options enabled. Hardware virtualization: Expose hardware assisted virtualization to the guest OS Performance counters: Enable virtualized CPU performance counters","title":"VMWare ESXi additional first steps"},{"location":"installation/#other-caveats","text":"The installer will also enforce the following sanity checks: That KVM will operate on your machines. This is generally fine unless you're using virtual machines at which point nested virtualization needs to be enabled. That your network interface MTU is greater than 2,000 bytes. This is required because the VXLAN mesh our virtual networks use add overhead to packets and a standard MTU of 1500 bytes for the physical network will result in packets being fragmented too frequently on the virtual networks. You can set a higher MTU if you desire, I generally select 9,000 bytes.","title":"Other caveats"},{"location":"installation/#deployment","text":"Each deployment takes slight different arguments. I tend to write a small shell script to wrap these up for convenience. Here's an example for a baremetal deployment: $ cat ~/sf-deploys/cbr-remote.sh #!/bin/bash export CLOUD=metal export ADMIN_PASSWORD=\"p4ssw0rd\" export FLOATING_IP_BLOCK=\"192.168.20.0/24\" export BOOTDELAY=0 # Tests are not currently safe for clusters whose data you are fond of export SKIP_SF_TESTS=1 ./deployandtest.sh I then execute that script from the deploy/ansible directory to do a deployment or upgrade. Note that running the CI suite will destroy the contents of your cloud so be sure to use SKIP_SF_TESTS if you're upgrading a cluster with real users.","title":"Deployment"},{"location":"installation/#deployment-variables","text":"Option Terraform definition Description MODE All Options are \"deploy\" (the default) or \"hotfix\". Deploy performs a full install, whereas hotfix skips steps to try and push only changes to Shaken Fist code as quickly as possible. RELEASE All Which release to run. This can be a version number from pypi, the keyword \"git:\" for the current state of master, or \"git:branch\" to use a branch called \"branch\" from your local git. CLOUD All The terraform definition to use ADMIN_PASSWORD All The admin password for the cloud once installed FLOATING_IP_BLOCK All The IP range to use for the floating network BOOTDELAY All How long to wait for terraform deployed instances to boot before continuing with install, in minutes SKIP_SF_TEST All Set to 1 to skip running destructive testing of the cloud KSM_ENABLED All Set to 1 to enable KSM, 0 to disable DEPLOY_NAME All The name of the deployment to use as an external label for prometheus AWS_REGION aws, aws-single-node The AWS region to deploy in AWS_AVAILABILITY_ZONE aws, aws-single-node The AWS availability zone to deploy in AWS_VPC_ID aws, aws-single-node The AWS VPC to use AWS_SSH_KEY_NAME aws, aws-single-node The name of an SSH key in the AWS region to use for ansible GCP_PROJECT gcp, gcp-xl The GCP project id to deploy in GCP_SSH_KEY_FILENAME gcp, gcp-xl The path to a ssh private key file to use for authentication. It is assumed that the public key is at ${GCP_SSH_KEY_FILENAME}.pub . (optional, only required if not using gcloud). GCP_SSH_USER gcp, gcp-xl The username to add the GCP_SSH_KEY to. (optional, only used if GCPSSH_KEY_FILENAME is set). OS_SSH_KEY_NAME openstack The name of a SSH key in the OpenStack cloud to use for ansible OS_FLAVOR_NAME openstack The OpenStack flavor to use for instances OS_EXTERNAL_NET_NAME openstack The UUID of an OpenStack network with internet access METAL_IP_SF1 metal The IP address of a baremetal machine METAL_IP_SF2 metal The IP address of a baremetal machine METAL_IP_SF3 metal The IP address of a baremetal machine SHAKENFIST_KEY shakenfist The authentication key for a user on the shakenfist cluster to deploy in SHAKENFIST_SSH_KEY shakenfist The path to a SSH key to use for ansible","title":"Deployment variables"},{"location":"manifesto/","text":"Shaken Fist Manifesto This document attempts to list Shaken Fist's defining features, give guidance on what type of features should be added to the project, how they should be implemented and how we work together. Shaken Fist Defining Characteristics Shaken Fist is smaller, simpler cloud. It is designed for relatively small environments with minimum management overhead. Its features are highly opinionated. This means that the maintainers have chosen the best (in their opinion) features to support. Opinionated features do not handle every single possible use case. This reduces the code base size thus increasing long-term maintainability. The code base is understandable in its entirety by a single developer. A Shaken Fist cluster does not need a team of engineers to install or operate. A Shaken Fist cluster should be simple to set up. We define 'simple' as \"a person with no knowledge of the project can build a reasonable cluster in an evening\". Project Goals Allow simple management of virtual machine instances without complexity. Support networking between those machines and also facilitate access to external networks. Avoid re-inventing the wheel (utilise other open source projects when appropriate). Feature Guidelines Features should be deliberately limited in the options available. The goal of limiting options is to reduce code complexity. If the option does not add significant code complexity then it should added. The supported features and the options of those features should aim to cover the majority of use cases. When a feature limits the available options, it should do so in a way that does not overly restrict a project fork from adding that option. New code should conform to the conventions of the existing code base and written to be easily understood. New code should have new tests (please). Significant Opinionated Design Decisions The only supported hypervisor is KVM managed by libvirt. Virtual networking is only implemented via VXLAN meshes. Single machine clusters should always be possible. Only the current Ubuntu LTS version is supported by the main project (forks to support other operating systems are encouraged). Project Interaction Guidelines Always polite Always generous Being opinionated is encouraged (but gently) Updating the documentation is just as important as the code change itself Developers who write tests are the most highly prized of all the developers","title":"Manifesto"},{"location":"manifesto/#shaken-fist-manifesto","text":"This document attempts to list Shaken Fist's defining features, give guidance on what type of features should be added to the project, how they should be implemented and how we work together.","title":"Shaken Fist Manifesto"},{"location":"manifesto/#shaken-fist-defining-characteristics","text":"Shaken Fist is smaller, simpler cloud. It is designed for relatively small environments with minimum management overhead. Its features are highly opinionated. This means that the maintainers have chosen the best (in their opinion) features to support. Opinionated features do not handle every single possible use case. This reduces the code base size thus increasing long-term maintainability. The code base is understandable in its entirety by a single developer. A Shaken Fist cluster does not need a team of engineers to install or operate. A Shaken Fist cluster should be simple to set up. We define 'simple' as \"a person with no knowledge of the project can build a reasonable cluster in an evening\".","title":"Shaken Fist Defining Characteristics"},{"location":"manifesto/#project-goals","text":"Allow simple management of virtual machine instances without complexity. Support networking between those machines and also facilitate access to external networks. Avoid re-inventing the wheel (utilise other open source projects when appropriate).","title":"Project Goals"},{"location":"manifesto/#feature-guidelines","text":"Features should be deliberately limited in the options available. The goal of limiting options is to reduce code complexity. If the option does not add significant code complexity then it should added. The supported features and the options of those features should aim to cover the majority of use cases. When a feature limits the available options, it should do so in a way that does not overly restrict a project fork from adding that option. New code should conform to the conventions of the existing code base and written to be easily understood. New code should have new tests (please).","title":"Feature Guidelines"},{"location":"manifesto/#significant-opinionated-design-decisions","text":"The only supported hypervisor is KVM managed by libvirt. Virtual networking is only implemented via VXLAN meshes. Single machine clusters should always be possible. Only the current Ubuntu LTS version is supported by the main project (forks to support other operating systems are encouraged).","title":"Significant Opinionated Design Decisions"},{"location":"manifesto/#project-interaction-guidelines","text":"Always polite Always generous Being opinionated is encouraged (but gently) Updating the documentation is just as important as the code change itself Developers who write tests are the most highly prized of all the developers","title":"Project Interaction Guidelines"},{"location":"power_states/","text":"Instance power states Shaken Fist version 0.2.1 introduced power states for instances. Before this, you could power on or off an instance, or pause it, but you couldn't tell what power state the instance was actually in. That was pretty confusing and was therefore treated as a bug. The following power states are implemented: on : the instance is running off : the instance is not running paused : the instance is paused crashed : the instance is crashed according to the hypervisor. Instances in this power state will also be in an instance state of \"error\". There are additionally a set of \"transition states\" which are used to indicate that you have requested a change of state that might not yet have completed. These are: transition-to-on transition-to-off transition-to-paused We're hoping to not have to implement a transition-to-crashed state, but you never know.","title":"Power States"},{"location":"power_states/#instance-power-states","text":"Shaken Fist version 0.2.1 introduced power states for instances. Before this, you could power on or off an instance, or pause it, but you couldn't tell what power state the instance was actually in. That was pretty confusing and was therefore treated as a bug. The following power states are implemented: on : the instance is running off : the instance is not running paused : the instance is paused crashed : the instance is crashed according to the hypervisor. Instances in this power state will also be in an instance state of \"error\". There are additionally a set of \"transition states\" which are used to indicate that you have requested a change of state that might not yet have completed. These are: transition-to-on transition-to-off transition-to-paused We're hoping to not have to implement a transition-to-crashed state, but you never know.","title":"Instance power states"},{"location":"usage/","text":"Clients There is a command line client called \"sf-client\" deployed by ansible. It talks to Shaken Fist via a REST API. There is also a python API client library at shakenfist.clients.apiclient, which is what the command line client uses to call the API. The apiclient module also serves as useful example code for how to write your own client. The command line client can produce output in three formats: the standard \"pretty\" format, a mostly-csv format called \"simple\" (which is aimed at being easy to parse in shell scripts), and JSON. You select the output format with a flag like this: sf-client --simple instance list The default formatter is the \"pretty\" formatter, so you never need to specify that on the command line. You can explore what the command line client is capable of by asking it for help: sf-client --help Networking Virtual networks / micro segmentation is provided by VXLAN meshes between the instances. Hypervisors are joined to a given mesh when they start their first instance on that network. DHCP services are optionally offered from a \"network services\" node, which is just a hypervisor node with some extra dnsmasq process. NAT is also optionally available from the network services node. If your network provides NAT, it consumes an IP address from the floating IP pool to do so, and performs NAT in a network namespace on the network node. You create a network on the command line like this: sf-client network create mynet 192.168.1.0/24 Where \"192.168.1.0/24\" is the netblock to use, and \"mynet\" is the name of the network. You'll get back output describing the network, including the UUID of the network, which is used in later calls. Instances Every instance gets a config drive. Its always an ISO9660 drive. It's always the second virtual disk attached to the VM (vdb on Linux). There is no metadata server. Additionally, there is no image service -- you specify the image to use by providing a URL. That URL is cached, but can be to any HTTP server anywhere. Even better, there are no flavors. You specify what resources your instance should have at boot time and that's what you get. No more being forced into a t-shirt sized description of your needs. Instances are always cattle. Any feature that made instances feel like pets has not been implemented. That said, you can snapshot an instance. Snapshots aren't reliable backups, just like they're not really reliable backups on OpenStack. There is a small but real chance that a snapshot will contain an inconsistent state if you're snapshotting a busy database or something like that. One minor difference from OpenStack -- when you snapshot your instance you can snapshot all of the virtual disks (except the config drive) if you want to. Snapshots are delivered as files you can download via a mechanism external to Shaken Fist (for example an HTTP server pointed at the snapshot directory). You start an instance like this: sf-client instance create \"myinstance\" 1 2048 -d 8@cirros -n netuuid Where \"myinstance\" is the name of the instance, it has 1 vCPU, 2048MB of RAM, a single 8gb disk (more on this in a second) and a single network interface on the network with the UUID \"netuuid\". \"8 @cirros \" is a \"short disk specification\". These are in the form size@image, where the @image is optional. You can specify more than one disk, so this is valid: sf-client instance create \"myinstance\" 1 2048 -d 8@cirros -d 8 -d 8 -n netuuid In this case we have three disks, all of 8gb. The boot disk is imaged with cirros. The \"cirros\" here is shorthand. By default, you specify a URL for the image you want, so to boot a cirros instance you might use http://download.cirros-cloud.net/0.5.1/cirros-0.5.1-x86_64-disk.img -- that gets old though, so for common cloud images there is a shorthand format, where Shaken Fist knows how to generate the download URL from a short description. In this case \"cirros\" means \"the latest release of cirros\". You can also specify a version like this: sf-client instance create \"myinstance\" 1 2048 -d 8@cirros:0.5.1 -d 8 -d 8 -n netuuid \"Common cloud images\" is currently defined as cirros and Ubuntu. You can also use a \"detailed disk specification\", which is what fancy people use. Its syntax is similar: sf-client instance create \"myinstance\" 1 2048 -D size=8,base=cirros,bus=ide,type=cdrom -d 8 -d 8 -n netuuid The specification is composed of a series of key-value pairs. Valid keys are: size; base; bus; and type. If you don't specify a key, you'll get a reasonable default. Here's how the keys work: size as per the shorthand notation. base as per the shorthand notation, including version specification. bus is any valid disk bus for libvirt, which is virtio, ide, scsi, usb. Use virtio unless you have a really good reason otherwise -- the performance of the others are terrible. An example of a good reason is to install virtio drivers into legacy operating systems that lack them natively. type can be one of disk or cdrom. Note that cdroms are excluded from snapshots. Similarly, networks have a \"short network specification\", where you can specify the UUID of a network, but also optionally the IP address to use for the interface. You can also have more than one network interface, so this is valid: sf-client instance create \"myinstance\" 1 2048 -d 8@cirros -n netuuid1@192.168.1.2 \\ -n netuuid2@10.0.0.4 There is a \"detailed network specification\" as well, which is composed of the following keys: network_uuid is the UUID of the network to use. address is the IPv4 network address to use, if free. If its not free the instance will fail to start. macaddress the mac address to use for the interface. Missing documentation I really should document these as well: nodes networks: delete, list instance: show, delete, list, ssh keys, user data, reboots (hard and soft), poweroff, poweron, pause, unpause, snapshot images: pre-caching metadata authentication Maybe one day I will.","title":"Usage"},{"location":"usage/#clients","text":"There is a command line client called \"sf-client\" deployed by ansible. It talks to Shaken Fist via a REST API. There is also a python API client library at shakenfist.clients.apiclient, which is what the command line client uses to call the API. The apiclient module also serves as useful example code for how to write your own client. The command line client can produce output in three formats: the standard \"pretty\" format, a mostly-csv format called \"simple\" (which is aimed at being easy to parse in shell scripts), and JSON. You select the output format with a flag like this: sf-client --simple instance list The default formatter is the \"pretty\" formatter, so you never need to specify that on the command line. You can explore what the command line client is capable of by asking it for help: sf-client --help","title":"Clients"},{"location":"usage/#networking","text":"Virtual networks / micro segmentation is provided by VXLAN meshes between the instances. Hypervisors are joined to a given mesh when they start their first instance on that network. DHCP services are optionally offered from a \"network services\" node, which is just a hypervisor node with some extra dnsmasq process. NAT is also optionally available from the network services node. If your network provides NAT, it consumes an IP address from the floating IP pool to do so, and performs NAT in a network namespace on the network node. You create a network on the command line like this: sf-client network create mynet 192.168.1.0/24 Where \"192.168.1.0/24\" is the netblock to use, and \"mynet\" is the name of the network. You'll get back output describing the network, including the UUID of the network, which is used in later calls.","title":"Networking"},{"location":"usage/#instances","text":"Every instance gets a config drive. Its always an ISO9660 drive. It's always the second virtual disk attached to the VM (vdb on Linux). There is no metadata server. Additionally, there is no image service -- you specify the image to use by providing a URL. That URL is cached, but can be to any HTTP server anywhere. Even better, there are no flavors. You specify what resources your instance should have at boot time and that's what you get. No more being forced into a t-shirt sized description of your needs. Instances are always cattle. Any feature that made instances feel like pets has not been implemented. That said, you can snapshot an instance. Snapshots aren't reliable backups, just like they're not really reliable backups on OpenStack. There is a small but real chance that a snapshot will contain an inconsistent state if you're snapshotting a busy database or something like that. One minor difference from OpenStack -- when you snapshot your instance you can snapshot all of the virtual disks (except the config drive) if you want to. Snapshots are delivered as files you can download via a mechanism external to Shaken Fist (for example an HTTP server pointed at the snapshot directory). You start an instance like this: sf-client instance create \"myinstance\" 1 2048 -d 8@cirros -n netuuid Where \"myinstance\" is the name of the instance, it has 1 vCPU, 2048MB of RAM, a single 8gb disk (more on this in a second) and a single network interface on the network with the UUID \"netuuid\". \"8 @cirros \" is a \"short disk specification\". These are in the form size@image, where the @image is optional. You can specify more than one disk, so this is valid: sf-client instance create \"myinstance\" 1 2048 -d 8@cirros -d 8 -d 8 -n netuuid In this case we have three disks, all of 8gb. The boot disk is imaged with cirros. The \"cirros\" here is shorthand. By default, you specify a URL for the image you want, so to boot a cirros instance you might use http://download.cirros-cloud.net/0.5.1/cirros-0.5.1-x86_64-disk.img -- that gets old though, so for common cloud images there is a shorthand format, where Shaken Fist knows how to generate the download URL from a short description. In this case \"cirros\" means \"the latest release of cirros\". You can also specify a version like this: sf-client instance create \"myinstance\" 1 2048 -d 8@cirros:0.5.1 -d 8 -d 8 -n netuuid \"Common cloud images\" is currently defined as cirros and Ubuntu. You can also use a \"detailed disk specification\", which is what fancy people use. Its syntax is similar: sf-client instance create \"myinstance\" 1 2048 -D size=8,base=cirros,bus=ide,type=cdrom -d 8 -d 8 -n netuuid The specification is composed of a series of key-value pairs. Valid keys are: size; base; bus; and type. If you don't specify a key, you'll get a reasonable default. Here's how the keys work: size as per the shorthand notation. base as per the shorthand notation, including version specification. bus is any valid disk bus for libvirt, which is virtio, ide, scsi, usb. Use virtio unless you have a really good reason otherwise -- the performance of the others are terrible. An example of a good reason is to install virtio drivers into legacy operating systems that lack them natively. type can be one of disk or cdrom. Note that cdroms are excluded from snapshots. Similarly, networks have a \"short network specification\", where you can specify the UUID of a network, but also optionally the IP address to use for the interface. You can also have more than one network interface, so this is valid: sf-client instance create \"myinstance\" 1 2048 -d 8@cirros -n netuuid1@192.168.1.2 \\ -n netuuid2@10.0.0.4 There is a \"detailed network specification\" as well, which is composed of the following keys: network_uuid is the UUID of the network to use. address is the IPv4 network address to use, if free. If its not free the instance will fail to start. macaddress the mac address to use for the interface.","title":"Instances"},{"location":"usage/#missing-documentation","text":"I really should document these as well: nodes networks: delete, list instance: show, delete, list, ssh keys, user data, reboots (hard and soft), poweroff, poweron, pause, unpause, snapshot images: pre-caching metadata authentication Maybe one day I will.","title":"Missing documentation"},{"location":"changelog/changelog_v02/","text":"Changes between v0.2.7 and v0.2.8 v0.2.8 has not yet been released. Allow the setting of numeric configuration values. shakenfist#324 Backing file information must be provided with modern libvirts. shakenfist#326 Changes between v0.2.6 and v0.2.7 v0.2.7 was released on 26 September 2020. Fix import error in scheduler.py Changes between v0.2.5 and v0.2.6 v0.2.6 was released on 26 September 2020. Fix typo in gunicorn command line. Changes between v0.2.4 and v0.2.5 v0.2.5 was released on 3 August 2020. API requests without a JSON payload fail when made to a non-network node. shakenfist#261 Resolve error during instance start. shakenfist#263 Resolve a crash in the network monitor. shakenfist#264 Changes between v0.2.3 and v0.2.4 v0.2.4 was released on 2 August 2020. Remove stray networks when detected. shakenfist#161 Display video details of an instance in sf-client. shakenfist#216 The login prompt trigger is now more reliable. shakenfist#223 Rapid creates from terraform can crash Shaken Fist with a race condition. shakenfist#225 Instance deletes could leave internal IP addresses allocated to deleted instances. shakenfist#227 sf-client now displays network card model. shakenfist#228 Missing node metrics could cause a scheduler crash. shakenfist#236 A missing import caused a scheduler crash. shakenfist#236 You can now list the instances on a network with sf-client. shakenfist#240 Disabling DHCP for networks did not work correctly. shakenfist#245 Ubuntu 18.04's cloud-init would issue warnings about network interface types. shakenfist#250 Network interfaces were sometimes leaked. shakenfist#252 sf-client would sometimes crash if the disk bus was the default. shakenfist#253 Load balancers were causing annoying log messages which have been demoted to debug level. shakenfist#258 Changes between v0.2.2 and v0.2.3 v0.2.3 was released on 25 July 2020. Run CI tests multiple times to try and shake out timing errors. shakenfist#191 Be more flexible in what VDI video configurations we allow. shakenfist#201 Log power state changes as instance events. shakenfist#203 Handle bad video card choices more gracefully. shakenfist#219 Changes between v0.2.1 and v0.2.2 v0.2.2 was released on 23 July 2020. Support for cascading delete of resources when you delete a namespace. shakenfist#157 Shaken Fist now tracks the power state of instances and exposes that via the REST API and command line client. We also kill stray instances which are left running after deletion. shakenfist#197 The API (and command line client) now display the version of Shaken Fist installed on each node. shakenfist#175 The network event cleanup code handles larger numbers of events needing to be cleaned on upgrade. shakenfist#176 Kernel Shared Memory is now configured by the deployer and used by Shaken Fist to over subscribe memory in cases where pages are successfully being shared. shakenfist#177 , deploy#28 and deploy#33 . Instance nodes are now correctly reported in cases where placement was forced. shakenfist#179 Instance scheduling is retried on a different node in cases where the churn rate is sufficient for the cached resource availability information to be inaccurate. shakenfist#186 A permissions denied error was corrected for shakenfist.json accesses in the comment line client. shakenfist#187 Incorrect database information for instances or network interfaces no longer crashes the start of new instances. shakenfist#194 Instance names must now be DNS safe. shakenfist#200 The deployer now checks that the configured MTU on the VXLAN mesh interface is sane. deploy#30 , and deploy#32 . Changes between v0.2.0 and v0.2.1 v0.2.1 was released on 16 July 2020. Fix crash in cleaner daemon when an etcd compaction fails. shakenfist#152 Fix HTTP 500 errors when malformed authorization headers are passed on API calls. shakenfist#154 Avoid starting instances on the network node if possible. shakenfist#156 Track and expose instance power states. Show instance state and power state in instance listings. shakenfist#159 Correct resource-in-use errors for specific IP requests. shakenfist#162 Network mesh event logging was too verbose. Only log additions and removals from the mesh. Also cleanup old mesh events on upgrade. shakenfist#163 Nodes now report what version of Shaken Fist they are running via etcd. shakenfist#164","title":"v0.2"},{"location":"changelog/changelog_v02/#changes-between-v027-and-v028","text":"v0.2.8 has not yet been released. Allow the setting of numeric configuration values. shakenfist#324 Backing file information must be provided with modern libvirts. shakenfist#326","title":"Changes between v0.2.7 and v0.2.8"},{"location":"changelog/changelog_v02/#changes-between-v026-and-v027","text":"v0.2.7 was released on 26 September 2020. Fix import error in scheduler.py","title":"Changes between v0.2.6 and v0.2.7"},{"location":"changelog/changelog_v02/#changes-between-v025-and-v026","text":"v0.2.6 was released on 26 September 2020. Fix typo in gunicorn command line.","title":"Changes between v0.2.5 and v0.2.6"},{"location":"changelog/changelog_v02/#changes-between-v024-and-v025","text":"v0.2.5 was released on 3 August 2020. API requests without a JSON payload fail when made to a non-network node. shakenfist#261 Resolve error during instance start. shakenfist#263 Resolve a crash in the network monitor. shakenfist#264","title":"Changes between v0.2.4 and v0.2.5"},{"location":"changelog/changelog_v02/#changes-between-v023-and-v024","text":"v0.2.4 was released on 2 August 2020. Remove stray networks when detected. shakenfist#161 Display video details of an instance in sf-client. shakenfist#216 The login prompt trigger is now more reliable. shakenfist#223 Rapid creates from terraform can crash Shaken Fist with a race condition. shakenfist#225 Instance deletes could leave internal IP addresses allocated to deleted instances. shakenfist#227 sf-client now displays network card model. shakenfist#228 Missing node metrics could cause a scheduler crash. shakenfist#236 A missing import caused a scheduler crash. shakenfist#236 You can now list the instances on a network with sf-client. shakenfist#240 Disabling DHCP for networks did not work correctly. shakenfist#245 Ubuntu 18.04's cloud-init would issue warnings about network interface types. shakenfist#250 Network interfaces were sometimes leaked. shakenfist#252 sf-client would sometimes crash if the disk bus was the default. shakenfist#253 Load balancers were causing annoying log messages which have been demoted to debug level. shakenfist#258","title":"Changes between v0.2.3 and v0.2.4"},{"location":"changelog/changelog_v02/#changes-between-v022-and-v023","text":"v0.2.3 was released on 25 July 2020. Run CI tests multiple times to try and shake out timing errors. shakenfist#191 Be more flexible in what VDI video configurations we allow. shakenfist#201 Log power state changes as instance events. shakenfist#203 Handle bad video card choices more gracefully. shakenfist#219","title":"Changes between v0.2.2 and v0.2.3"},{"location":"changelog/changelog_v02/#changes-between-v021-and-v022","text":"v0.2.2 was released on 23 July 2020. Support for cascading delete of resources when you delete a namespace. shakenfist#157 Shaken Fist now tracks the power state of instances and exposes that via the REST API and command line client. We also kill stray instances which are left running after deletion. shakenfist#197 The API (and command line client) now display the version of Shaken Fist installed on each node. shakenfist#175 The network event cleanup code handles larger numbers of events needing to be cleaned on upgrade. shakenfist#176 Kernel Shared Memory is now configured by the deployer and used by Shaken Fist to over subscribe memory in cases where pages are successfully being shared. shakenfist#177 , deploy#28 and deploy#33 . Instance nodes are now correctly reported in cases where placement was forced. shakenfist#179 Instance scheduling is retried on a different node in cases where the churn rate is sufficient for the cached resource availability information to be inaccurate. shakenfist#186 A permissions denied error was corrected for shakenfist.json accesses in the comment line client. shakenfist#187 Incorrect database information for instances or network interfaces no longer crashes the start of new instances. shakenfist#194 Instance names must now be DNS safe. shakenfist#200 The deployer now checks that the configured MTU on the VXLAN mesh interface is sane. deploy#30 , and deploy#32 .","title":"Changes between v0.2.1 and v0.2.2"},{"location":"changelog/changelog_v02/#changes-between-v020-and-v021","text":"v0.2.1 was released on 16 July 2020. Fix crash in cleaner daemon when an etcd compaction fails. shakenfist#152 Fix HTTP 500 errors when malformed authorization headers are passed on API calls. shakenfist#154 Avoid starting instances on the network node if possible. shakenfist#156 Track and expose instance power states. Show instance state and power state in instance listings. shakenfist#159 Correct resource-in-use errors for specific IP requests. shakenfist#162 Network mesh event logging was too verbose. Only log additions and removals from the mesh. Also cleanup old mesh events on upgrade. shakenfist#163 Nodes now report what version of Shaken Fist they are running via etcd. shakenfist#164","title":"Changes between v0.2.0 and v0.2.1"},{"location":"changelog/changelog_v03/","text":"The big ideas of v0.3 v0.3 is a re-write of portions of v0.2 that we felt were holding Shaken Fist back. The two most obvious examples are that slow operations would often timeout because of our HTTP worker model, and locking simply didn't work at all. Some more detail on those: All operations in v0.2 are handled by the REST API HTTP workers (gunicorn). So, if you ask us to launch an instance, we use the HTTP worker to do that thing. That works great, unless the operation is going to take more time than the HTTP worker is allowed to run for. This is pretty easy to achieve if the image you're fetching is large. Instead, we now move to a model where the HTTP worker creates a queued job, and then polls its state for a small period of time before returning. That means if things are quick you get the same API behaviour as before, but for slow operations you'll be told that the job is incomplete but still executing. We also realised somewhere late in v0.2's life that the etcd library we were using was pretty buggy. Locking simply didn't work some of the time. Additionally, our locking code was pretty ad hoc and sometimes we would get the names of the locks wrong because they were just strings. This has now been completely re-written, but that has shaken out a number of bugs that are surfaced by locking actually working now. We have worked through those bugs and sought to resolve them. Changes between v0.3.4 and v0.3.5 (hotfix) v0.3.5 was released on 17 January 2021. Pin Flask-JWT-Extended to resolve CI breakage. Changes between v0.3.3 and v0.3.4 (hotfix) v0.3.4 was released on 15 January 2021. Package libvirt and DHCP templates in the python package, so that the modern installer can install the correct version of these templates when installing older releases. Changes between v0.3.2 and v0.3.3 v0.3.3 was released on 13 November 2020. Remove incorrect warnings for extra VLANs. shakenfist#496 Fix logging for queue workers. shakenfist#498 Resolve network delete collisions and races. shakenfist#500 , shakenfist#504 Resolve resources daemon issue casued by race with instance deletion. shakenfist#507 Image fetch should retry after bad checksum. shakenfist#509 Add an option to delay deletion of failed CI jobs. shakenfist#511 Enable full state change CI. shakenfist#514 Fix etcd connection error on compaction. shakenfist#516 CI fails when the Ubuntu mirror is slow. shakenfist#518 Nightly large CI failing because of logic errors in grep. shakenfist#522 Fix numeric conversion error in disk sizes. shakenfist#526 Ensure requested IPs are within the ipblock of the virtual network. shakenfist#533 , shakenfist#536 , shakenfist#538 Changes between v0.3.1 and v0.3.2 v0.3.2 was released on 29 October 2020. Networking shake down as we work towards CI reliably passing. shakenfist#435 , shakenfist#438 , shakenfist#469 , shakenfist#477 Images improvements including moving towards cluster wide image management. shakenfist#440 , shakenfist#442 , shakenfist#451 , shakenfist#453 , shakenfist#460 , shakenfist#465 , shakenfist#472 , shakenfist#481 Admins can now list locks that Shaken Fist is holding and locks include a description of the operation being undertaken. Reduce the number of locks we hold to reduce etcd load. shakenfist#444 , shakenfist#449 , shakenfist#455 , shakenfist#463 Cleanup trigger daemon defunct processes. shakenfist#446 Deployments were broken if you specified a local prometheus snippet. shakenfist#456 Console and VDI ports were being checked for availability on the API node not the hypervisor node. shakenfist#487 Changes between v0.3.0 and v0.3.1 v0.3.1 was released on 21 October 2020. Reject power on while powering off. shakenfist#394 Always use locally administered MAC addresses. shakenfist#409 Fix unintentionally ignored exceptions. shakenfist#410 Image downloads should verify checksums where possible. shakenfist#412 Improved CI reliability. shakenfist#416 , shakenfist3418, shakenfist#419 , shakenfist#420 , shakenfist#426 , shakenfist#428","title":"v0.3"},{"location":"changelog/changelog_v03/#the-big-ideas-of-v03","text":"v0.3 is a re-write of portions of v0.2 that we felt were holding Shaken Fist back. The two most obvious examples are that slow operations would often timeout because of our HTTP worker model, and locking simply didn't work at all. Some more detail on those: All operations in v0.2 are handled by the REST API HTTP workers (gunicorn). So, if you ask us to launch an instance, we use the HTTP worker to do that thing. That works great, unless the operation is going to take more time than the HTTP worker is allowed to run for. This is pretty easy to achieve if the image you're fetching is large. Instead, we now move to a model where the HTTP worker creates a queued job, and then polls its state for a small period of time before returning. That means if things are quick you get the same API behaviour as before, but for slow operations you'll be told that the job is incomplete but still executing. We also realised somewhere late in v0.2's life that the etcd library we were using was pretty buggy. Locking simply didn't work some of the time. Additionally, our locking code was pretty ad hoc and sometimes we would get the names of the locks wrong because they were just strings. This has now been completely re-written, but that has shaken out a number of bugs that are surfaced by locking actually working now. We have worked through those bugs and sought to resolve them.","title":"The big ideas of v0.3"},{"location":"changelog/changelog_v03/#changes-between-v034-and-v035-hotfix","text":"v0.3.5 was released on 17 January 2021. Pin Flask-JWT-Extended to resolve CI breakage.","title":"Changes between v0.3.4 and v0.3.5 (hotfix)"},{"location":"changelog/changelog_v03/#changes-between-v033-and-v034-hotfix","text":"v0.3.4 was released on 15 January 2021. Package libvirt and DHCP templates in the python package, so that the modern installer can install the correct version of these templates when installing older releases.","title":"Changes between v0.3.3 and v0.3.4 (hotfix)"},{"location":"changelog/changelog_v03/#changes-between-v032-and-v033","text":"v0.3.3 was released on 13 November 2020. Remove incorrect warnings for extra VLANs. shakenfist#496 Fix logging for queue workers. shakenfist#498 Resolve network delete collisions and races. shakenfist#500 , shakenfist#504 Resolve resources daemon issue casued by race with instance deletion. shakenfist#507 Image fetch should retry after bad checksum. shakenfist#509 Add an option to delay deletion of failed CI jobs. shakenfist#511 Enable full state change CI. shakenfist#514 Fix etcd connection error on compaction. shakenfist#516 CI fails when the Ubuntu mirror is slow. shakenfist#518 Nightly large CI failing because of logic errors in grep. shakenfist#522 Fix numeric conversion error in disk sizes. shakenfist#526 Ensure requested IPs are within the ipblock of the virtual network. shakenfist#533 , shakenfist#536 , shakenfist#538","title":"Changes between v0.3.2 and v0.3.3"},{"location":"changelog/changelog_v03/#changes-between-v031-and-v032","text":"v0.3.2 was released on 29 October 2020. Networking shake down as we work towards CI reliably passing. shakenfist#435 , shakenfist#438 , shakenfist#469 , shakenfist#477 Images improvements including moving towards cluster wide image management. shakenfist#440 , shakenfist#442 , shakenfist#451 , shakenfist#453 , shakenfist#460 , shakenfist#465 , shakenfist#472 , shakenfist#481 Admins can now list locks that Shaken Fist is holding and locks include a description of the operation being undertaken. Reduce the number of locks we hold to reduce etcd load. shakenfist#444 , shakenfist#449 , shakenfist#455 , shakenfist#463 Cleanup trigger daemon defunct processes. shakenfist#446 Deployments were broken if you specified a local prometheus snippet. shakenfist#456 Console and VDI ports were being checked for availability on the API node not the hypervisor node. shakenfist#487","title":"Changes between v0.3.1 and v0.3.2"},{"location":"changelog/changelog_v03/#changes-between-v030-and-v031","text":"v0.3.1 was released on 21 October 2020. Reject power on while powering off. shakenfist#394 Always use locally administered MAC addresses. shakenfist#409 Fix unintentionally ignored exceptions. shakenfist#410 Image downloads should verify checksums where possible. shakenfist#412 Improved CI reliability. shakenfist#416 , shakenfist3418, shakenfist#419 , shakenfist#420 , shakenfist#426 , shakenfist#428","title":"Changes between v0.3.0 and v0.3.1"},{"location":"changelog/changelog_v04/","text":"The big ideas of v0.4 The focus of v0.4 is reliability -- we've used behaviour in the continuous integration pipeline as a proxy for that, but it should be a significant improvement in the real world as well. This has included: much more extensive continuous integration coverage, including several new jobs. checksumming image downloads, and retrying images where the checksum fails. reworked locking. etcd reliability improvements. refactoring instances and networks to a new \"non-volatile\" object model where only immutable values are cached. images now track a state much like instances and networks. a reworked state model for instances, where its clearer why an instance ended up in an error state. This is documented in our developer docs . In terms of new features, we also added: a network ping API, which will emit ICMP ping packets on the network node onto your virtual network. We use this in testing to ensure instances booted and ended up online. networks are now checked to ensure that they have a reasonable minimum size. addition of a simple etcd backup and restore tool (sf-backup). improved data upgrade of previous installations. VXLAN ids are now randomized, and this has forced a new naming scheme for network interfaces and bridges. we are smarter about what networks we restore on startup, and don't restore dead networks. We also now require python 3.8. Changes between v0.4.0 and v0.4.1 v0.4.1 was released on 26 January 2021. Remove stray persist() call from floating network setup. shakenfist#667 Networks should enter the 'created' state once setup on the network node. shakenfist#669 Changes between v0.4.1 and v0.4.2 v0.4.2 was released on 6 February 2021. Improved CI for image API calls. Improved upgrade CI testing. Improved network state tracking. Floating IPs now work, and have covering CI. shakenfist#257 Resolve leaks of floating IPs from both direct use and NAT gateways. shakenfist#256 Resolve leaks of IPManagers on network delete. shakenfist#675 Use system packages for ansible during install.","title":"v0.4"},{"location":"changelog/changelog_v04/#the-big-ideas-of-v04","text":"The focus of v0.4 is reliability -- we've used behaviour in the continuous integration pipeline as a proxy for that, but it should be a significant improvement in the real world as well. This has included: much more extensive continuous integration coverage, including several new jobs. checksumming image downloads, and retrying images where the checksum fails. reworked locking. etcd reliability improvements. refactoring instances and networks to a new \"non-volatile\" object model where only immutable values are cached. images now track a state much like instances and networks. a reworked state model for instances, where its clearer why an instance ended up in an error state. This is documented in our developer docs . In terms of new features, we also added: a network ping API, which will emit ICMP ping packets on the network node onto your virtual network. We use this in testing to ensure instances booted and ended up online. networks are now checked to ensure that they have a reasonable minimum size. addition of a simple etcd backup and restore tool (sf-backup). improved data upgrade of previous installations. VXLAN ids are now randomized, and this has forced a new naming scheme for network interfaces and bridges. we are smarter about what networks we restore on startup, and don't restore dead networks. We also now require python 3.8.","title":"The big ideas of v0.4"},{"location":"changelog/changelog_v04/#changes-between-v040-and-v041","text":"v0.4.1 was released on 26 January 2021. Remove stray persist() call from floating network setup. shakenfist#667 Networks should enter the 'created' state once setup on the network node. shakenfist#669","title":"Changes between v0.4.0 and v0.4.1"},{"location":"changelog/changelog_v04/#changes-between-v041-and-v042","text":"v0.4.2 was released on 6 February 2021. Improved CI for image API calls. Improved upgrade CI testing. Improved network state tracking. Floating IPs now work, and have covering CI. shakenfist#257 Resolve leaks of floating IPs from both direct use and NAT gateways. shakenfist#256 Resolve leaks of IPManagers on network delete. shakenfist#675 Use system packages for ansible during install.","title":"Changes between v0.4.1 and v0.4.2"},{"location":"development/ci_api_coverage/","text":"CI API Coverage This document tracks the CI coverage for each of our public APIs. The intent to make it clear what is \"sufficiently tested\", and what needs further effort. This list is manually updated, so we'll need to show discipline in ensuring that we update it as we change APIs or CI. For this document we use the python API client as a model of what to cover, as its simpler to extract a list of calls from than the API implementation itself. We list whether we have CI which calls the API directly, CI which uses the python command line client to call the API, or both. The gold standard is both. get_instances Whilst being implied by every test tearDown(), this call is explicitly used in: TestCirros.test_cirros_boot_no_network TestCirros.test_cirros_boot_network TestPlacement.test_local_placement_works TestPlacement.test_remote_placement_works TestSystemNamespace.test_system_namespace TestUbuntu.test_ubuntu_pings delete_all_instances Not tested. get_instance All callers of await_instance_event call get_instance(). However, these more explicit tests exist as well: TestCacheImage.test_instance_invalid_image get_instance_interfaces TestMultipleNics.test_simple TestNetworking.test_virtual_networks_are_separate TestNetworking.test_overlapping_virtual_networks_are_separate TestNetworking.test_single_virtal_networks_work TestNetworking.test_specific_ip_request TestPlacement.test_local_placement_works TestPlacement.test_remote_placement_works TestStateChanges.test_lifecycle_events TestUbuntu.test_ubuntu_pings get_instance_metadata TestInstanceMetadata.test_simple set_instance_metadata_item TestInstanceMetadata.test_simple delete_instance_metadata_item Not tested. create_instance Tested extensively in most other tests, so tests are not listed here. snapshot_instance TestSnapshots.test_single_disk_snapshots TestSnapshots.test_multiple_disk_snapshots get_instance_snapshots TestSnapshots.test_single_disk_snapshots TestSnapshots.test_multiple_disk_snapshots reboot_instance TestStateChanges.test_lifecycle_events power_off_instance TestStateChanges.test_lifecycle_events power_on_instance TestStateChanges.test_lifecycle_events pause_instance TestStateChanges.test_lifecycle_events unpause_instance TestStateChanges.test_lifecycle_events delete_instance Whilst being implied by every test tearDown(), this call is explicitly used in: TestCirros.test_cirros_boot_no_network TestCirros.test_cirros_boot_network TestPlacement.test_local_placement_works TestPlacement.test_remote_placement_works TestSnapshots.test_single_disk_snapshots TestSnapshots.test_multiple_disk_snapshots TestSystemNamespace.test_system_namespace TestUbuntu.test_ubuntu_pings get_instance_events All callers of await_instance_event call get_instance(). However, more testing of this method is required. cache_image TestImages.test_cache_image get_images (Formerly get_image_meta, old name to be removed in 0.5). TestImages.test_cache_image get_image_events Not tested. get_networks Whilst being implied by every test tearDown(), this call is explicitly used in: TestSystemNamespace.test_system_namespace get_network Not tested. delete_network Whilst being implied by every test tearDown(), this call is explicitly used in: TestSystemNamespace.test_system_namespace delete_all_networks Not tested. get_network_events Not tested. allocate_network Tested extensively in most other tests, so tests are not listed here. get_network_interfaces Not tested. get_network_metadata Not tested. set_network_metadata_item Not tested. delete_network_metadata_item Not tested. get_nodes Not tested. get_interface Not tested. float_interface Not tested. defloat_interface Not tested. get_console_data TestConsoleLog.test_console_log get_namespaces As well as being tested as a side effect of most other tests, there is the following explicit test: TestAuth.test_namespaces create_namespace As well as being tested as a side effect of most other tests, there is the following explicit test: TestAuth.test_namespaces delete_namespace As well as being tested as a side effect of most other tests, there is the following explicit test: TestAuth.test_namespaces get_namespace_keynames Not tested. add_namespace_key TestAuth.test_namespaces delete_namespace_key TestAuth.test_namespaces get_namespace_metadata Not tested. set_namespace_metadata_item Not tested. delete_namespace_metadata_item Not tested. get_existing_locks Not tested. ping Tested as a side effect of many other tests, but no explicit test.","title":"CI API coverage"},{"location":"development/ci_api_coverage/#ci-api-coverage","text":"This document tracks the CI coverage for each of our public APIs. The intent to make it clear what is \"sufficiently tested\", and what needs further effort. This list is manually updated, so we'll need to show discipline in ensuring that we update it as we change APIs or CI. For this document we use the python API client as a model of what to cover, as its simpler to extract a list of calls from than the API implementation itself. We list whether we have CI which calls the API directly, CI which uses the python command line client to call the API, or both. The gold standard is both.","title":"CI API Coverage"},{"location":"development/ci_api_coverage/#get_instances","text":"Whilst being implied by every test tearDown(), this call is explicitly used in: TestCirros.test_cirros_boot_no_network TestCirros.test_cirros_boot_network TestPlacement.test_local_placement_works TestPlacement.test_remote_placement_works TestSystemNamespace.test_system_namespace TestUbuntu.test_ubuntu_pings","title":"get_instances"},{"location":"development/ci_api_coverage/#delete_all_instances","text":"Not tested.","title":"delete_all_instances"},{"location":"development/ci_api_coverage/#get_instance","text":"All callers of await_instance_event call get_instance(). However, these more explicit tests exist as well: TestCacheImage.test_instance_invalid_image","title":"get_instance"},{"location":"development/ci_api_coverage/#get_instance_interfaces","text":"TestMultipleNics.test_simple TestNetworking.test_virtual_networks_are_separate TestNetworking.test_overlapping_virtual_networks_are_separate TestNetworking.test_single_virtal_networks_work TestNetworking.test_specific_ip_request TestPlacement.test_local_placement_works TestPlacement.test_remote_placement_works TestStateChanges.test_lifecycle_events TestUbuntu.test_ubuntu_pings","title":"get_instance_interfaces"},{"location":"development/ci_api_coverage/#get_instance_metadata","text":"TestInstanceMetadata.test_simple","title":"get_instance_metadata"},{"location":"development/ci_api_coverage/#set_instance_metadata_item","text":"TestInstanceMetadata.test_simple","title":"set_instance_metadata_item"},{"location":"development/ci_api_coverage/#delete_instance_metadata_item","text":"Not tested.","title":"delete_instance_metadata_item"},{"location":"development/ci_api_coverage/#create_instance","text":"Tested extensively in most other tests, so tests are not listed here.","title":"create_instance"},{"location":"development/ci_api_coverage/#snapshot_instance","text":"TestSnapshots.test_single_disk_snapshots TestSnapshots.test_multiple_disk_snapshots","title":"snapshot_instance"},{"location":"development/ci_api_coverage/#get_instance_snapshots","text":"TestSnapshots.test_single_disk_snapshots TestSnapshots.test_multiple_disk_snapshots","title":"get_instance_snapshots"},{"location":"development/ci_api_coverage/#reboot_instance","text":"TestStateChanges.test_lifecycle_events","title":"reboot_instance"},{"location":"development/ci_api_coverage/#power_off_instance","text":"TestStateChanges.test_lifecycle_events","title":"power_off_instance"},{"location":"development/ci_api_coverage/#power_on_instance","text":"TestStateChanges.test_lifecycle_events","title":"power_on_instance"},{"location":"development/ci_api_coverage/#pause_instance","text":"TestStateChanges.test_lifecycle_events","title":"pause_instance"},{"location":"development/ci_api_coverage/#unpause_instance","text":"TestStateChanges.test_lifecycle_events","title":"unpause_instance"},{"location":"development/ci_api_coverage/#delete_instance","text":"Whilst being implied by every test tearDown(), this call is explicitly used in: TestCirros.test_cirros_boot_no_network TestCirros.test_cirros_boot_network TestPlacement.test_local_placement_works TestPlacement.test_remote_placement_works TestSnapshots.test_single_disk_snapshots TestSnapshots.test_multiple_disk_snapshots TestSystemNamespace.test_system_namespace TestUbuntu.test_ubuntu_pings","title":"delete_instance"},{"location":"development/ci_api_coverage/#get_instance_events","text":"All callers of await_instance_event call get_instance(). However, more testing of this method is required.","title":"get_instance_events"},{"location":"development/ci_api_coverage/#cache_image","text":"TestImages.test_cache_image","title":"cache_image"},{"location":"development/ci_api_coverage/#get_images","text":"(Formerly get_image_meta, old name to be removed in 0.5). TestImages.test_cache_image","title":"get_images"},{"location":"development/ci_api_coverage/#get_image_events","text":"Not tested.","title":"get_image_events"},{"location":"development/ci_api_coverage/#get_networks","text":"Whilst being implied by every test tearDown(), this call is explicitly used in: TestSystemNamespace.test_system_namespace","title":"get_networks"},{"location":"development/ci_api_coverage/#get_network","text":"Not tested.","title":"get_network"},{"location":"development/ci_api_coverage/#delete_network","text":"Whilst being implied by every test tearDown(), this call is explicitly used in: TestSystemNamespace.test_system_namespace","title":"delete_network"},{"location":"development/ci_api_coverage/#delete_all_networks","text":"Not tested.","title":"delete_all_networks"},{"location":"development/ci_api_coverage/#get_network_events","text":"Not tested.","title":"get_network_events"},{"location":"development/ci_api_coverage/#allocate_network","text":"Tested extensively in most other tests, so tests are not listed here.","title":"allocate_network"},{"location":"development/ci_api_coverage/#get_network_interfaces","text":"Not tested.","title":"get_network_interfaces"},{"location":"development/ci_api_coverage/#get_network_metadata","text":"Not tested.","title":"get_network_metadata"},{"location":"development/ci_api_coverage/#set_network_metadata_item","text":"Not tested.","title":"set_network_metadata_item"},{"location":"development/ci_api_coverage/#delete_network_metadata_item","text":"Not tested.","title":"delete_network_metadata_item"},{"location":"development/ci_api_coverage/#get_nodes","text":"Not tested.","title":"get_nodes"},{"location":"development/ci_api_coverage/#get_interface","text":"Not tested.","title":"get_interface"},{"location":"development/ci_api_coverage/#float_interface","text":"Not tested.","title":"float_interface"},{"location":"development/ci_api_coverage/#defloat_interface","text":"Not tested.","title":"defloat_interface"},{"location":"development/ci_api_coverage/#get_console_data","text":"TestConsoleLog.test_console_log","title":"get_console_data"},{"location":"development/ci_api_coverage/#get_namespaces","text":"As well as being tested as a side effect of most other tests, there is the following explicit test: TestAuth.test_namespaces","title":"get_namespaces"},{"location":"development/ci_api_coverage/#create_namespace","text":"As well as being tested as a side effect of most other tests, there is the following explicit test: TestAuth.test_namespaces","title":"create_namespace"},{"location":"development/ci_api_coverage/#delete_namespace","text":"As well as being tested as a side effect of most other tests, there is the following explicit test: TestAuth.test_namespaces","title":"delete_namespace"},{"location":"development/ci_api_coverage/#get_namespace_keynames","text":"Not tested.","title":"get_namespace_keynames"},{"location":"development/ci_api_coverage/#add_namespace_key","text":"TestAuth.test_namespaces","title":"add_namespace_key"},{"location":"development/ci_api_coverage/#delete_namespace_key","text":"TestAuth.test_namespaces","title":"delete_namespace_key"},{"location":"development/ci_api_coverage/#get_namespace_metadata","text":"Not tested.","title":"get_namespace_metadata"},{"location":"development/ci_api_coverage/#set_namespace_metadata_item","text":"Not tested.","title":"set_namespace_metadata_item"},{"location":"development/ci_api_coverage/#delete_namespace_metadata_item","text":"Not tested.","title":"delete_namespace_metadata_item"},{"location":"development/ci_api_coverage/#get_existing_locks","text":"Not tested.","title":"get_existing_locks"},{"location":"development/ci_api_coverage/#ping","text":"Tested as a side effect of many other tests, but no explicit test.","title":"ping"},{"location":"development/ci_images/","text":"CI Images This page documents how the CI images for Shaken Fist are setup in our testing cloud account. At the moment Shaken Fist CI is not self hosting, and runs on Google Compute Engine. It would be good to change this in the future. Creating a new CI image First off, you need to create the base CI image for the Jenkins CI workers. We currently use Ubuntu 20.04 and Debian 10, and regularly update those (see below). Other distribtions require that you create an image, bless it for nested virtualization ( https://cloud.google.com/compute/docs/instances/enable-nested-virtualization-vm-instances ), and then install some dependancies: sudo apt-get update sudo apt-get -y dist-upgrade sudo apt-get -y install openjdk-11-jdk git ansible tox pwgen build-essential \\ python3-dev python3-wheel python3-pip curl ansible git ansible-galaxy install andrewrothstein.etcd-cluster andrewrothstein.terraform \\ andrewrothstein.go Keeping a CI image up to date Our test nodes are used for a single test each, and are based on the \"sf-privci\" series of images in the relevant Google Cloud project. These images need regular updates or the dist-upgrade time on startup gets out of hand. The process to do that is as follows: Find the most recent image and boot a VM using it: DISTRO=debian-10 IMAGE=`gcloud compute images list | grep sf-$DISTRO | cut -f 1 -d \" \" | sort -n | tail -1` gcloud compute instances create update-image \\ --zone us-central1-b --min-cpu-platform \"Intel Haswell\" --image $IMAGE Wait for the instance to boot and then log into it: # gcloud compute ssh update-image And now you can do whatever updates are required. May I suggest: sudo apt-get update sudo apt-get dist-upgrade sudo sync Now we can create a new image: gcloud compute instances stop update-image gcloud compute images create sf-$DISTRO-`date +%Y%m%d` \\ --source-disk=update-image --source-disk-zone=us-central1-b gcloud compute instances delete update-image Finally, you need to update Jenkins to use that new disk image. That hides at https://jenkins.shakenfist.com/configureClouds/ Remember to occassionally clean up old images, but do that via the Google Cloud UI.","title":"CI images"},{"location":"development/ci_images/#ci-images","text":"This page documents how the CI images for Shaken Fist are setup in our testing cloud account. At the moment Shaken Fist CI is not self hosting, and runs on Google Compute Engine. It would be good to change this in the future.","title":"CI Images"},{"location":"development/ci_images/#creating-a-new-ci-image","text":"First off, you need to create the base CI image for the Jenkins CI workers. We currently use Ubuntu 20.04 and Debian 10, and regularly update those (see below). Other distribtions require that you create an image, bless it for nested virtualization ( https://cloud.google.com/compute/docs/instances/enable-nested-virtualization-vm-instances ), and then install some dependancies: sudo apt-get update sudo apt-get -y dist-upgrade sudo apt-get -y install openjdk-11-jdk git ansible tox pwgen build-essential \\ python3-dev python3-wheel python3-pip curl ansible git ansible-galaxy install andrewrothstein.etcd-cluster andrewrothstein.terraform \\ andrewrothstein.go","title":"Creating a new CI image"},{"location":"development/ci_images/#keeping-a-ci-image-up-to-date","text":"Our test nodes are used for a single test each, and are based on the \"sf-privci\" series of images in the relevant Google Cloud project. These images need regular updates or the dist-upgrade time on startup gets out of hand. The process to do that is as follows: Find the most recent image and boot a VM using it: DISTRO=debian-10 IMAGE=`gcloud compute images list | grep sf-$DISTRO | cut -f 1 -d \" \" | sort -n | tail -1` gcloud compute instances create update-image \\ --zone us-central1-b --min-cpu-platform \"Intel Haswell\" --image $IMAGE Wait for the instance to boot and then log into it: # gcloud compute ssh update-image And now you can do whatever updates are required. May I suggest: sudo apt-get update sudo apt-get dist-upgrade sudo sync Now we can create a new image: gcloud compute instances stop update-image gcloud compute images create sf-$DISTRO-`date +%Y%m%d` \\ --source-disk=update-image --source-disk-zone=us-central1-b gcloud compute instances delete update-image Finally, you need to update Jenkins to use that new disk image. That hides at https://jenkins.shakenfist.com/configureClouds/ Remember to occassionally clean up old images, but do that via the Google Cloud UI.","title":"Keeping a CI image up to date"},{"location":"development/git_usage/","text":"Development Workflow Short Lesson The majority of teams using git have a work flow that looks similar to the four well known work flows: Git Flow GitHub Flow GitLab Flow Trunk Based Development Git Development - the Shaken Fist Way The Shaken Fist developers have chosen Trunk Based Development. Branch Types Branch master This branch should be a working version of the project that has passed all unit and integration tests. The code is reasonably reliable but still has the reliability of software with a v0.x semver tag. Code on the develop branch that has passed all CI pipelines can be merged to master . Branch develop This is the development trunk. All feature branches are branched from develop and merged to develop . The develop branch is merged to master when significant development milestones have been adequately tested. Feature branches Short-lived, generally a few days. Normally only one developer. When presented to the team, it is expected to pass the linter and unit tests. It is normal that other team members suggest changes/improvements before merging. Branches release-vX.X Only created when a release requires patches (hot-fixes). Commits to this branch are cherry-picks from develop . It is not expected that many commits are made to this branch. If many commits are required to a release branch then this indicates the need for another release. Process Feature branches Feature/Bug branches have a prefix consisting of the GitHub issue number - no need for the word bug or issue. The feature branch developer should squash commits to remove WIP commits before creating a Pull Request. It is preferably that each remaining commit passes testing/CI. Merging Commits are not squashed when merged to master Not squashing commits maintains history of multiple issues being solved. Pull Request related commits remain grouped and can be understood as a single merge Release branch Only necessary bug fixes are cherry-picked from master to an existing release-vX.X branch. Too many cherry-picked commits to a Release branch If a large number of commits appear desirable on a release branch, it is probably an indication that another minor release would be a better idea. If another release is not desired because master contains unstable features then either CI needs improving or that feature requires more work and should not be in master .","title":"Workflow"},{"location":"development/git_usage/#development-workflow","text":"","title":"Development Workflow"},{"location":"development/git_usage/#short-lesson","text":"The majority of teams using git have a work flow that looks similar to the four well known work flows: Git Flow GitHub Flow GitLab Flow Trunk Based Development","title":"Short Lesson"},{"location":"development/git_usage/#git-development-the-shaken-fist-way","text":"The Shaken Fist developers have chosen Trunk Based Development.","title":"Git Development - the Shaken Fist Way"},{"location":"development/git_usage/#branch-types","text":"Branch master This branch should be a working version of the project that has passed all unit and integration tests. The code is reasonably reliable but still has the reliability of software with a v0.x semver tag. Code on the develop branch that has passed all CI pipelines can be merged to master . Branch develop This is the development trunk. All feature branches are branched from develop and merged to develop . The develop branch is merged to master when significant development milestones have been adequately tested. Feature branches Short-lived, generally a few days. Normally only one developer. When presented to the team, it is expected to pass the linter and unit tests. It is normal that other team members suggest changes/improvements before merging. Branches release-vX.X Only created when a release requires patches (hot-fixes). Commits to this branch are cherry-picks from develop . It is not expected that many commits are made to this branch. If many commits are required to a release branch then this indicates the need for another release.","title":"Branch Types"},{"location":"development/git_usage/#process","text":"","title":"Process"},{"location":"development/git_usage/#feature-branches","text":"Feature/Bug branches have a prefix consisting of the GitHub issue number - no need for the word bug or issue. The feature branch developer should squash commits to remove WIP commits before creating a Pull Request. It is preferably that each remaining commit passes testing/CI.","title":"Feature branches"},{"location":"development/git_usage/#merging","text":"Commits are not squashed when merged to master Not squashing commits maintains history of multiple issues being solved. Pull Request related commits remain grouped and can be understood as a single merge","title":"Merging"},{"location":"development/git_usage/#release-branch","text":"Only necessary bug fixes are cherry-picked from master to an existing release-vX.X branch.","title":"Release branch"},{"location":"development/git_usage/#too-many-cherry-picked-commits-to-a-release-branch","text":"If a large number of commits appear desirable on a release branch, it is probably an indication that another minor release would be a better idea. If another release is not desired because master contains unstable features then either CI needs improving or that feature requires more work and should not be in master .","title":"Too many cherry-picked commits to a Release branch"},{"location":"development/gluster/","text":"Gluster support Shaken Fist now supports gluster as a shared block filesystem for instance storage, and by supports we mean \"doesn't really know what disk it is using\". This document seeks to explain how that works, and why it is built the way it is. There are possible future improvements that could be made, and those are included here as well. What works The deployer knows how to install and configure glusterfs as a shared filesystem with optional replication. This filesystem is mounted at /srv/shakenfist/instances if GLUSTER_ENABLED is set to \"1\". You should note that the performance of that shared filesystem isn't great, because it uses a fuse mount to get data from the virtual machine to the disk. What doesn't work right now Lack of qemu support Ubuntu has chosen to not provide qemu with glusterfs support compiled in ( https://bugs.launchpad.net/ubuntu/+source/glusterfs/+bug/1274247 ). This means we can't specify direct paths to glusterfs in qemu commands. In a perfect world we'd be able to execute command lines like this: qemu-img create -f qcow2 gluster://server.domain.com:24007/testvol/a.img 5G We should investigate if there is a qemu PPA which improves this situation. Difficulty getting libvirt to work Modern libvirts support writing directly to gluster instead of using the fuse filesystem mount. This should perform much better, but I can't get it to work. With a libvirt.xml which includes this: <disk type='network' device='disk'> <driver name='qemu' type='qcow2'/> <source protocol='gluster' name='shakenfist/ba6db72c-7110-40c6-99df-6449ee8b0a69/vda'> <host name='sf-3' port='24007' /> </source> <backingStore type='file'> <format type='qcow2'/> <source file='/srv/shakenfist/image_cache/xxx.v001'/> </backingStore> <target dev='vda' bus='virtio'/> </disk> I get an error like this starting the instance: libvirtd[300135]: internal error: qemu unexpectedly closed the monitor: 2020-11-05T04:32:15.672972Z qemu-system-x86_64: -blockdev {\"driver\":\"gluster\",\"volume\":\"shakenfist\",\"path\":\"ba6db72c-7110-40c6-99df-6449ee8b0a69/vda\",\"server\":[{\"type\":\"inet\",\"host\":\"sf-3\",\"port\":\"24007\"}],\"debug\":4,\"node-name\":\"libvirt-2-storage\",\"auto-read-only\":true,\"discard\":\"unmap\"}: Unknown driver 'gluster' Hints welcome. To use the broken direct gluster support, append \"_gluster\" to your SHAKENFIST_DISK_FORMAT environment variable in the sf.service file. You might find https://staged-gluster-docs.readthedocs.io/en/release3.7.0beta1/Features/qemu-integration/#create-libvirt-xml-to-define-virtual-machine to be helful, as might https://docs.gluster.org/en/latest/Administrator%20Guide/Building%20QEMU%20With%20gfapi%20For%20Debian%20Based%20Systems/#building-qemu be. Performance via fuse mount How does using the fuse mount affect the performance of instances? To test this, I ran a cirros instance on raw local disk, and ran this test: $ for i in `seq 1 10` > do > time dd if=/dev/zero of=foo bs=1024 count=1024000 2>> out > done $ grep real out real 0m 12.30s real 0m 13.24s real 0m 13.47s real 0m 13.96s real 0m 16.62s real 0m 13.77s real 0m 13.56s real 0m 13.05s real 0m 12.08s real 0m 11.44s So, writing approximately 1gb of data to the qcow2 COW layer of this VM takes a median time of 13.355 seconds. How does this compare with gluster via the fuse mount? real 0m 26.13s real 0m 31.66s real 0m 31.30s real 0m 30.74s real 0m 30.42s real 0m 30.84s real 0m 26.75s real 0m 24.47s real 0m 27.02s real 0m 24.47s So, about half the speed. Sad face.","title":"Gluster support"},{"location":"development/gluster/#gluster-support","text":"Shaken Fist now supports gluster as a shared block filesystem for instance storage, and by supports we mean \"doesn't really know what disk it is using\". This document seeks to explain how that works, and why it is built the way it is. There are possible future improvements that could be made, and those are included here as well.","title":"Gluster support"},{"location":"development/gluster/#what-works","text":"The deployer knows how to install and configure glusterfs as a shared filesystem with optional replication. This filesystem is mounted at /srv/shakenfist/instances if GLUSTER_ENABLED is set to \"1\". You should note that the performance of that shared filesystem isn't great, because it uses a fuse mount to get data from the virtual machine to the disk.","title":"What works"},{"location":"development/gluster/#what-doesnt-work-right-now","text":"","title":"What doesn't work right now"},{"location":"development/gluster/#lack-of-qemu-support","text":"Ubuntu has chosen to not provide qemu with glusterfs support compiled in ( https://bugs.launchpad.net/ubuntu/+source/glusterfs/+bug/1274247 ). This means we can't specify direct paths to glusterfs in qemu commands. In a perfect world we'd be able to execute command lines like this: qemu-img create -f qcow2 gluster://server.domain.com:24007/testvol/a.img 5G We should investigate if there is a qemu PPA which improves this situation.","title":"Lack of qemu support"},{"location":"development/gluster/#difficulty-getting-libvirt-to-work","text":"Modern libvirts support writing directly to gluster instead of using the fuse filesystem mount. This should perform much better, but I can't get it to work. With a libvirt.xml which includes this: <disk type='network' device='disk'> <driver name='qemu' type='qcow2'/> <source protocol='gluster' name='shakenfist/ba6db72c-7110-40c6-99df-6449ee8b0a69/vda'> <host name='sf-3' port='24007' /> </source> <backingStore type='file'> <format type='qcow2'/> <source file='/srv/shakenfist/image_cache/xxx.v001'/> </backingStore> <target dev='vda' bus='virtio'/> </disk> I get an error like this starting the instance: libvirtd[300135]: internal error: qemu unexpectedly closed the monitor: 2020-11-05T04:32:15.672972Z qemu-system-x86_64: -blockdev {\"driver\":\"gluster\",\"volume\":\"shakenfist\",\"path\":\"ba6db72c-7110-40c6-99df-6449ee8b0a69/vda\",\"server\":[{\"type\":\"inet\",\"host\":\"sf-3\",\"port\":\"24007\"}],\"debug\":4,\"node-name\":\"libvirt-2-storage\",\"auto-read-only\":true,\"discard\":\"unmap\"}: Unknown driver 'gluster' Hints welcome. To use the broken direct gluster support, append \"_gluster\" to your SHAKENFIST_DISK_FORMAT environment variable in the sf.service file. You might find https://staged-gluster-docs.readthedocs.io/en/release3.7.0beta1/Features/qemu-integration/#create-libvirt-xml-to-define-virtual-machine to be helful, as might https://docs.gluster.org/en/latest/Administrator%20Guide/Building%20QEMU%20With%20gfapi%20For%20Debian%20Based%20Systems/#building-qemu be.","title":"Difficulty getting libvirt to work"},{"location":"development/gluster/#performance-via-fuse-mount","text":"How does using the fuse mount affect the performance of instances? To test this, I ran a cirros instance on raw local disk, and ran this test: $ for i in `seq 1 10` > do > time dd if=/dev/zero of=foo bs=1024 count=1024000 2>> out > done $ grep real out real 0m 12.30s real 0m 13.24s real 0m 13.47s real 0m 13.96s real 0m 16.62s real 0m 13.77s real 0m 13.56s real 0m 13.05s real 0m 12.08s real 0m 11.44s So, writing approximately 1gb of data to the qcow2 COW layer of this VM takes a median time of 13.355 seconds. How does this compare with gluster via the fuse mount? real 0m 26.13s real 0m 31.66s real 0m 31.30s real 0m 30.74s real 0m 30.42s real 0m 30.84s real 0m 26.75s real 0m 24.47s real 0m 27.02s real 0m 24.47s So, about half the speed. Sad face.","title":"Performance via fuse mount"},{"location":"development/namespace_auth/","text":"Namespace Context and Authentication Namespaces All resources (instances/networks/interfaces) are assigned to a Namespace. All requests to Shaken Fist have a Namespace context. Only requests in the \"system\" Namespace are able to access resources in other (foreign) Namespaces. The Namespace \"system\" is reserved. Authentication A Namespace is accessed by supplying a valid \"Key\" (password). Namespaces can have multiple Keys. Each Key has a label referred to as a \"Key Name\". The Key Name is not specified during authentication. The Key Name \"service_key\" is reserved. API Request Authentication The authentication endpoint /auth is used to obtain a token to authenticate future API interaction. To obtain the token, the authentication request is made specifying the Namespace and the Key. The Key Name is not required (nor important). The response contains the (JWT) token to be used as a Bearer token for the actual API request. Internally, Shaken Fist determines the Namespace of each API request from the token. Authentication tokens expire after a fixed period of time (nominally 15 minutes). Interaction Name spaces can be created from within the \"system\" Namespace. The creation of a Namespace requires that a Key and it's Key Name are specified with the creation request. Keys do not have to be unique. A Key collision within a Namespace has no security consequences. Key Names are only unique within a Namespace. The purpose of the Key Name is to supply a handle to enable deletion of a Key. Actions are not logged against Key Names. Inter-Node Authentication Requests between Shaken Fist nodes use the same authentication system as external API requests. When a node makes an API request to another node, the originating node will create (or reuse) a \"service key\" specific to the Namespace of the original request. When a request is made from the \"system\" Namespace for a resource in a different Namespace, the API request is made using the foreign Namespace and the foreign Namespace service key.","title":"Namespace Authentication"},{"location":"development/namespace_auth/#namespace-context-and-authentication","text":"","title":"Namespace Context and Authentication"},{"location":"development/namespace_auth/#namespaces","text":"All resources (instances/networks/interfaces) are assigned to a Namespace. All requests to Shaken Fist have a Namespace context. Only requests in the \"system\" Namespace are able to access resources in other (foreign) Namespaces. The Namespace \"system\" is reserved.","title":"Namespaces"},{"location":"development/namespace_auth/#authentication","text":"A Namespace is accessed by supplying a valid \"Key\" (password). Namespaces can have multiple Keys. Each Key has a label referred to as a \"Key Name\". The Key Name is not specified during authentication. The Key Name \"service_key\" is reserved.","title":"Authentication"},{"location":"development/namespace_auth/#api-request-authentication","text":"The authentication endpoint /auth is used to obtain a token to authenticate future API interaction. To obtain the token, the authentication request is made specifying the Namespace and the Key. The Key Name is not required (nor important). The response contains the (JWT) token to be used as a Bearer token for the actual API request. Internally, Shaken Fist determines the Namespace of each API request from the token. Authentication tokens expire after a fixed period of time (nominally 15 minutes).","title":"API Request Authentication"},{"location":"development/namespace_auth/#interaction","text":"Name spaces can be created from within the \"system\" Namespace. The creation of a Namespace requires that a Key and it's Key Name are specified with the creation request. Keys do not have to be unique. A Key collision within a Namespace has no security consequences. Key Names are only unique within a Namespace. The purpose of the Key Name is to supply a handle to enable deletion of a Key. Actions are not logged against Key Names.","title":"Interaction"},{"location":"development/namespace_auth/#inter-node-authentication","text":"Requests between Shaken Fist nodes use the same authentication system as external API requests. When a node makes an API request to another node, the originating node will create (or reuse) a \"service key\" specific to the Namespace of the original request. When a request is made from the \"system\" Namespace for a resource in a different Namespace, the API request is made using the foreign Namespace and the foreign Namespace service key.","title":"Inter-Node Authentication"},{"location":"development/release_process/","text":"Shaken Fist's release process Shaken Fist is now split across a number of repositories to simplify development and usage. Unfortunately, that complicated the release process. This page documents the current release process. Step 1: Testing Before release, you should ensure that all of the clouds currently supported by the deployer work. These are important to new users and testers, so we should keep them working. For reference, they are at deploy/ansible/terraform . At the time of writing those are: aws aws-single node gcp metal openstack Note that to test these you need access to all those clouds, as well as needing to know the cloud specific values for each cloud. Unfortunately I can't tell you those because they vary with your specific cloud accounts. Step 2: shakenfist/shakenfist Create a pull request to merge develop into master for shakenfist/shakenfist. As a releaser you do not need human review of that pull request (as they are so big and have already been reviewed in individual elements), but you do need to ensure that CI is passing before merging the change. Tag the release, update github, and then test that pypi will accept Markdown formatted README. In the shakenfist/shakenfist repo: pip install --upgrade readme-renderer pip install --upgrade twine rm -f dist/* git checkout master git pull git tag -s v0.1.0 -m \"Release v0.1.0\" python3 setup.py sdist bdist_wheel twine check dist/* git push origin v0.1.0 twine upload dist/* Step 3: shakenfist/client-python Tag the release, update github, and then test that pypi will accept Markdown formatted README. In the shakenfist/client-python repo: pip install --upgrade readme-renderer pip install --upgrade twine rm -f dist/* git tag -s v0.1.0 -m \"Release v0.1.0\" python3 setup.py sdist bdist_wheel twine check dist/* git push origin v0.1.0 twine upload dist/* Step 4: shakenfist/client-go Tag and release as per shakenfist/shakenfist - include the patch number eg. v0.1.0 git tag -s v0.1.0 -m \"Release v0.1.0\" git push origin v0.1.0 Golang modules require an \"annotated git tag\" (not a lightweight git tag). Therefore use the sign option ( -s ) as above, or use the annotate option ( -a ) of git tag . Note that the Github website interface will create lightweight tags. Therefore tag locally and push to Github. IMPORTANT: Golang modules require the full X.Y.Z sermver version eg. v0.2.0 (Otherwise go will attach the wrong version numbers to fetches and update go.mod incorrectly.) Step 5: shakenfist/terraform-provider-shakenfist Bump dependency in go.mod Tag and release Set the version number of github.com/shakenfist/client-go in the go.mod file to the new release version. Then tag and release as per shakenfist/shakenfist.","title":"Releases"},{"location":"development/release_process/#shaken-fists-release-process","text":"Shaken Fist is now split across a number of repositories to simplify development and usage. Unfortunately, that complicated the release process. This page documents the current release process.","title":"Shaken Fist's release process"},{"location":"development/release_process/#step-1-testing","text":"Before release, you should ensure that all of the clouds currently supported by the deployer work. These are important to new users and testers, so we should keep them working. For reference, they are at deploy/ansible/terraform . At the time of writing those are: aws aws-single node gcp metal openstack Note that to test these you need access to all those clouds, as well as needing to know the cloud specific values for each cloud. Unfortunately I can't tell you those because they vary with your specific cloud accounts.","title":"Step 1: Testing"},{"location":"development/release_process/#step-2-shakenfistshakenfist","text":"Create a pull request to merge develop into master for shakenfist/shakenfist. As a releaser you do not need human review of that pull request (as they are so big and have already been reviewed in individual elements), but you do need to ensure that CI is passing before merging the change. Tag the release, update github, and then test that pypi will accept Markdown formatted README. In the shakenfist/shakenfist repo: pip install --upgrade readme-renderer pip install --upgrade twine rm -f dist/* git checkout master git pull git tag -s v0.1.0 -m \"Release v0.1.0\" python3 setup.py sdist bdist_wheel twine check dist/* git push origin v0.1.0 twine upload dist/*","title":"Step 2: shakenfist/shakenfist"},{"location":"development/release_process/#step-3-shakenfistclient-python","text":"Tag the release, update github, and then test that pypi will accept Markdown formatted README. In the shakenfist/client-python repo: pip install --upgrade readme-renderer pip install --upgrade twine rm -f dist/* git tag -s v0.1.0 -m \"Release v0.1.0\" python3 setup.py sdist bdist_wheel twine check dist/* git push origin v0.1.0 twine upload dist/*","title":"Step 3: shakenfist/client-python"},{"location":"development/release_process/#step-4-shakenfistclient-go","text":"Tag and release as per shakenfist/shakenfist - include the patch number eg. v0.1.0 git tag -s v0.1.0 -m \"Release v0.1.0\" git push origin v0.1.0 Golang modules require an \"annotated git tag\" (not a lightweight git tag). Therefore use the sign option ( -s ) as above, or use the annotate option ( -a ) of git tag . Note that the Github website interface will create lightweight tags. Therefore tag locally and push to Github. IMPORTANT: Golang modules require the full X.Y.Z sermver version eg. v0.2.0 (Otherwise go will attach the wrong version numbers to fetches and update go.mod incorrectly.)","title":"Step 4: shakenfist/client-go"},{"location":"development/release_process/#step-5-shakenfistterraform-provider-shakenfist","text":"Bump dependency in go.mod Tag and release Set the version number of github.com/shakenfist/client-go in the go.mod file to the new release version. Then tag and release as per shakenfist/shakenfist.","title":"Step 5: shakenfist/terraform-provider-shakenfist"},{"location":"development/standards/","text":"Concepts and Standards Ensuring a Common Language within the code base This document records the standards and common language used within the Shaken Fist software system. It should also record why the choice was made. (This is actually just notes to save our future selves from tripping over the same problems.) Memory Memory is measured in MiB All references to memory size are stored/transmitted in MiB Gigabytes can be too big if you want a lot of small machines. Kilobytes is just too many numbers to type. Interactions The libvirt API measures memory in KiB. Therefore, interactions with the library need to be careful to convert from MiB to KiB.","title":"Standards"},{"location":"development/standards/#concepts-and-standards","text":"","title":"Concepts and Standards"},{"location":"development/standards/#ensuring-a-common-language-within-the-code-base","text":"This document records the standards and common language used within the Shaken Fist software system. It should also record why the choice was made. (This is actually just notes to save our future selves from tripping over the same problems.)","title":"Ensuring a Common Language within the code base"},{"location":"development/standards/#memory","text":"Memory is measured in MiB All references to memory size are stored/transmitted in MiB Gigabytes can be too big if you want a lot of small machines. Kilobytes is just too many numbers to type.","title":"Memory"},{"location":"development/standards/#interactions","text":"The libvirt API measures memory in KiB. Therefore, interactions with the library need to be careful to convert from MiB to KiB.","title":"Interactions"},{"location":"development/state_machine/","text":"Shaken Fist's State Machine Shaken Fist implements a state machine for each object type. This page documents the possible states for each object, and which transitions between states are valid. Instances None -> Initial: this is the first state for an instance. A UUID has been allocated, a placeholder database entry created, and a request to create the instance has been queued. Initial -> Preflight: the instance creation request has been dequeued and is being validated against the current state of the cluster by the scheduler. Preflight -> Creating: the instance is being created. Creating -> Created: the instance is now running. Created -> Deleted: the instance is now deleted. Deleted -> None: the instance has been hard deleted after sitting deleted for some period of time. Any instance may enter the Error state, which happens when something bad has happened. That process involves the instance being moved to a transition state named for the instance's previous state, so for example an instance which was Created that went into Error would transition through Created-Error. This is done because the Error transition is a queue job and happens sometime later. Instances in the Error state are not removed like those in the deleted state, as we assume a caller must acknowledge an error occured. To remove them, delete the instance in Error state. Nodes None -> Created: on first check in, a node is created in the \"created\" state. Created -> Deleted: the node was manually evacuated and removed. Created -> Missing: the node has not checked in within the NODE_CHECKIN_MAXIMUM deadline. Created -> Error: the node has not check in for ten times NODE_CHECKIN_MAXIMUM, and all instances on this node have been declared to be in an error state.","title":"State machine"},{"location":"development/state_machine/#shaken-fists-state-machine","text":"Shaken Fist implements a state machine for each object type. This page documents the possible states for each object, and which transitions between states are valid.","title":"Shaken Fist's State Machine"},{"location":"development/state_machine/#instances","text":"None -> Initial: this is the first state for an instance. A UUID has been allocated, a placeholder database entry created, and a request to create the instance has been queued. Initial -> Preflight: the instance creation request has been dequeued and is being validated against the current state of the cluster by the scheduler. Preflight -> Creating: the instance is being created. Creating -> Created: the instance is now running. Created -> Deleted: the instance is now deleted. Deleted -> None: the instance has been hard deleted after sitting deleted for some period of time. Any instance may enter the Error state, which happens when something bad has happened. That process involves the instance being moved to a transition state named for the instance's previous state, so for example an instance which was Created that went into Error would transition through Created-Error. This is done because the Error transition is a queue job and happens sometime later. Instances in the Error state are not removed like those in the deleted state, as we assume a caller must acknowledge an error occured. To remove them, delete the instance in Error state.","title":"Instances"},{"location":"development/state_machine/#nodes","text":"None -> Created: on first check in, a node is created in the \"created\" state. Created -> Deleted: the node was manually evacuated and removed. Created -> Missing: the node has not checked in within the NODE_CHECKIN_MAXIMUM deadline. Created -> Error: the node has not check in for ten times NODE_CHECKIN_MAXIMUM, and all instances on this node have been declared to be in an error state.","title":"Nodes"},{"location":"development/updating_docs/","text":"Updating These Docs Built using MkDocs: https://www.mkdocs.org/ Theme: https://squidfunk.github.io/mkdocs-material/customization/ Setup Install mkdocs and the material theme pip install mkdocs-material Viewing Locally Start the live web-server with mkdocs serve View at http://localhost:8000 Deploying to GitHub Pages Build and deploy with mkdocs gh-deploy This will push to the gh-pages branch of the current git remote. Navigation Bar The navigation bar is configured via the mkdocs.yml file in the repository root.","title":"Website"},{"location":"development/updating_docs/#updating-these-docs","text":"Built using MkDocs: https://www.mkdocs.org/ Theme: https://squidfunk.github.io/mkdocs-material/customization/","title":"Updating These Docs"},{"location":"development/updating_docs/#setup","text":"Install mkdocs and the material theme pip install mkdocs-material","title":"Setup"},{"location":"development/updating_docs/#viewing-locally","text":"Start the live web-server with mkdocs serve View at http://localhost:8000","title":"Viewing Locally"},{"location":"development/updating_docs/#deploying-to-github-pages","text":"Build and deploy with mkdocs gh-deploy This will push to the gh-pages branch of the current git remote.","title":"Deploying to GitHub Pages"},{"location":"development/updating_docs/#navigation-bar","text":"The navigation bar is configured via the mkdocs.yml file in the repository root.","title":"Navigation Bar"},{"location":"networking/overview/","text":"Networking Overview Shaken Fist networking is complicated. Its actually less complicated that OpenStack Neutron networking, and its about as simple as we can get away with, but in order to allow virtual networks to use overlapping network ranges we are forced to do some vaguely complicated things with network namespaces. This document attempts to incrementally describe how Shaken Fist networking works, so that I can remember later. VXLAN Shaken Fist networking is based on a VXLAN mesh. VXLAN is like a successor to VLANs, except that you can have 1.6 million virtual networks, it doesn't use an IP header field to divide the networks up, and it is transported inside UDP packets between the members of the mesh. Normally VXLAN meshes are implemented using multicast UDP, but that doesn't work in public clouds where Shaken Fist was born, so we instead use unicast meshes that we lovingly hand maintain. Note The virtual mesh manages itself and changes state over time. If your mesh entries do not look like mine, it does not nessesarily indicate that your networking is broken. This is a dynamic environment! Our worked examples For this document, we will assume there are three Shaken Fist nodes, named sf-1 , sf-2 , and sf-3 . Its a total coincidence that this is the default size for the installer ansible at the time of writing and the exact size of all of the production clusters we are aware of. sf-1 is configured as the \"network node\", which is just a hypervisor like every other node, except that it is also where packets to and from the virtual networks route in and out of the mesh. First, off let's start with a simple network with one instance and no DHCP or NAT .","title":"Overview"},{"location":"networking/overview/#networking-overview","text":"Shaken Fist networking is complicated. Its actually less complicated that OpenStack Neutron networking, and its about as simple as we can get away with, but in order to allow virtual networks to use overlapping network ranges we are forced to do some vaguely complicated things with network namespaces. This document attempts to incrementally describe how Shaken Fist networking works, so that I can remember later.","title":"Networking Overview"},{"location":"networking/overview/#vxlan","text":"Shaken Fist networking is based on a VXLAN mesh. VXLAN is like a successor to VLANs, except that you can have 1.6 million virtual networks, it doesn't use an IP header field to divide the networks up, and it is transported inside UDP packets between the members of the mesh. Normally VXLAN meshes are implemented using multicast UDP, but that doesn't work in public clouds where Shaken Fist was born, so we instead use unicast meshes that we lovingly hand maintain. Note The virtual mesh manages itself and changes state over time. If your mesh entries do not look like mine, it does not nessesarily indicate that your networking is broken. This is a dynamic environment!","title":"VXLAN"},{"location":"networking/overview/#our-worked-examples","text":"For this document, we will assume there are three Shaken Fist nodes, named sf-1 , sf-2 , and sf-3 . Its a total coincidence that this is the default size for the installer ansible at the time of writing and the exact size of all of the production clusters we are aware of. sf-1 is configured as the \"network node\", which is just a hypervisor like every other node, except that it is also where packets to and from the virtual networks route in and out of the mesh. First, off let's start with a simple network with one instance and no DHCP or NAT .","title":"Our worked examples"},{"location":"networking/single_instance/","text":"Networking Explained - Single Node This page is part of a series explaining how Shaken Fist networking works . You might want to check out the other pages as well. The simplest case: a virtual network with no DHCP and no NAT, and a single remote instance Let's assume you want a new virtual network with no network services. Its just two instances talking to each other. The basic flow is like this -- you create a virtual network. We allocate you a VXLAN network id (called the vxid in various places in the code): sf-1 # sf-client network create demonet 192.168.0.0/24 --no-dhcp --no-nat uuid : b41b067a-44b7-40c5-9ab8-7abdcf5fdc61 name : demonet vxlan id : 2 netblock : 192.168.0.0/24 provide dhcp : False provide nat : False floating gateway: None namespace : system state : initial Metadata: So in this case we were allocated VXLAN id 2, and have a network UUID of b41b067a-44b7-40c5-9ab8-7abdcf5fdc61. The state of the network is \"initial\" as it has not been created anywhere yet. If you wait a few seconds, you'll see it transition to a \"created\" state. You can see the new state with a show command: sf-1 # sf-client network show b41b067a-44b7-40c5-9ab8-7abdcf5fdc61 uuid : b41b067a-44b7-40c5-9ab8-7abdcf5fdc61 name : demonet vxlan id : 2 netblock : 192.168.0.0/24 provide dhcp : False provide nat : False floating gateway: None namespace : system state : created Metadata: And you can see the steps we went through to create the network in the events listing: sf-1 # sf-client network events b41b067a-44b7-40c5-9ab8-7abdcf5fdc61 +----------------------------+------+------------------------+------------+----------------------+-----------+ | timestamp | node | operation | phase | duration | message | +----------------------------+------+------------------------+------------+----------------------+-----------+ | 2020-08-01 06:49:07.753351 | sf-1 | api | create | None | None | | 2020-08-01 06:49:07.792583 | sf-1 | create vxlan interface | start | None | None | | 2020-08-01 06:49:07.819312 | sf-1 | create vxlan interface | finish | 0.025562286376953125 | None | | 2020-08-01 06:49:07.840636 | sf-1 | create vxlan bridge | start | None | None | | 2020-08-01 06:49:07.905165 | sf-1 | create vxlan bridge | finish | 0.0644679069519043 | None | | 2020-08-01 06:49:07.910409 | sf-1 | create netns | start | None | None | | 2020-08-01 06:49:07.997595 | sf-1 | create netns | finish | 0.0850062370300293 | None | | 2020-08-01 06:49:08.016509 | sf-1 | create router veth | start | None | None | | 2020-08-01 06:49:08.237167 | sf-1 | create router veth | finish | 0.2197411060333252 | None | | 2020-08-01 06:49:08.254165 | sf-1 | create physical veth | start | None | None | | 2020-08-01 06:49:08.342684 | sf-1 | create physical veth | finish | 0.08613038063049316 | None | | 2020-08-01 06:49:08.371490 | sf-1 | add mesh elements | None | None | 10.2.1.11 | | 2020-08-01 06:49:08.375682 | sf-1 | api | created | None | None | | 2020-08-01 06:49:40.664204 | sf-1 | api | get | None | None | | 2020-08-01 06:50:07.554738 | sf-1 | api | get events | None | None | +----------------------------+------+------------------------+------------+----------------------+-----------+ You can see here that the network node (sf-1) has created some network elements, and an IP (10.2.1.11) has been added to the mesh. That IP is sf-1, and its part of the network node being joined to the mesh. If we look on sf-1, we should now have a VXLAN interface, a bridge, and one end of a veth. sf-1 # ip addr show vxlan-2 287: vxlan-2: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 8950 qdisc noqueue master br-vxlan-2 state UNKNOWN group default qlen 1000 link/ether de:c4:ab:3d:79:fb brd ff:ff:ff:ff:ff:ff inet6 fe80::dcc4:abff:fe3d:79fb/64 scope link valid_lft forever preferred_lft forever sf-1 # ip addr show br-vxlan-2 288: br-vxlan-2: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP group default qlen 1000 link/ether be:c1:1b:20:b8:f7 brd ff:ff:ff:ff:ff:ff inet6 fe80::bcc1:1bff:fe20:b8f7/64 scope link valid_lft forever preferred_lft forever sf-1 # ip addr show veth-2-o 290: veth-2-o@if289: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue master br-vxlan-2 state UP group default qlen 1000 link/ether be:c1:1b:20:b8:f7 brd ff:ff:ff:ff:ff:ff link-netnsid 0 inet6 fe80::bcc1:1bff:fe20:b8f7/64 scope link valid_lft forever preferred_lft forever The vxlan-2 interface is the VXLAN mesh, and the br-vxlan-2 bridge is how VMs and veths will connect to the mesh on this local machine. Its important to note that MTU matters here. The MTU for the mesh network is 1500 bytes, and most client VMs will default to that as well. Therefore the underlying network needs to have a MTU greater than that. We default to an MTU of 9000 bytes in our installs, but 1550 would in fact be sufficient in this case. You can see this in the MTU for vxlan-2, which is our 9000 byte underlying MTU, with 50 bytes deducted for the VXLAN encapsulation. We can also ask the mesh for its current state: sf-1 # bridge fdb show brport vxlan-2 de:c4:ab:3d:79:fb master br-vxlan-2 permanent de:c4:ab:3d:79:fb vlan 1 master br-vxlan-2 permanent 00:00:00:00:00:00 dst 10.2.1.11 self permanent de:c4:ab:3d:79:fb dst 127.0.0.1 self be:c1:1b:20:b8:f7 dst 127.0.0.1 self e2:2d:32:6d:95:70 dst 127.0.0.1 self The current members of the mesh are: de:c4:ab:3d:79:fb: this is the mac address for vxlan-2. 00:00:00:00:00:00 dst 10.2.1.11: this is a mesh entry for the node with IP 10.2.1.11 (sf-1) be:c1:1b:20:b8:f7: this is the outside mac address of a veth between br-vxlan-2 and a network namespace on sf-1 e2:2d:32:6d:95:70: is the inside mac address of the veth between br-vxlan-2 and the network namespace What is this network namespace? Well, Shaken Fist needs to create a network namespace to contain routing, NAT, and DHCP for the virtual network. It's actually not strictly required in this simplest case, but we always create it. It is named for the UUID of the virtual network: sf-1 # ip netns exec b41b067a-44b7-40c5-9ab8-7abdcf5fdc61 ip addr list 1: lo: <LOOPBACK> mtu 65536 qdisc noop state DOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 289: veth-2-i@if290: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP group default qlen 1000 link/ether e2:2d:32:6d:95:70 brd ff:ff:ff:ff:ff:ff link-netnsid 0 inet 192.168.0.1/24 scope global veth-2-i valid_lft forever preferred_lft forever inet6 fe80::e02d:32ff:fe6d:9570/64 scope link valid_lft forever preferred_lft forever 291: phy-2-i@if292: <BROADCAST,MULTICAST> mtu 1500 qdisc noop state DOWN group default qlen 1000 link/ether fe:18:8e:f8:d1:5c brd ff:ff:ff:ff:ff:ff link-netnsid 0 The veth between the VXLAN mesh and this namespace is named veth-2-i (the interface inside the network namespace) and veth-2-o (the interface outside the network namespace). There is another veth named phy-2-i and phy-2-o, which is a link between the namespace and the outside world, but we'll talk about that more when we enable NAT. For those who are new to veths, think of them like patch cables -- so what we have here is a VXLAN mesh, which is patched into a network namespace, which is in turn patched into the outside world. We also do some things with iptables, especially around NAT. Here's the current state of iptables in the network namespace: sf-1 # ip netns exec b41b067a-44b7-40c5-9ab8-7abdcf5fdc61 iptables -L -t nat Chain PREROUTING (policy ACCEPT) target prot opt source destination Chain INPUT (policy ACCEPT) target prot opt source destination Chain OUTPUT (policy ACCEPT) target prot opt source destination Chain POSTROUTING (policy ACCEPT) target prot opt source destination That's empty for now because we're not doing any NAT yet, but watch this space. Next let's now start an instance on sf-2. This instance can't use DHCP to get an address because we have that disabled for this network. sf-1 # sf-client instance create inst-on-sf-2 1 1024 -d 20@ubuntu:18.04 -n b41b067a-44b7-40c5-9ab8-7abdcf5fdc61 -p sf-2 uuid : d53b345f-9d5d-493c-a1a3-7e7d6513cfa2 name : inst-on-sf-2 namespace : system cpus : 1 memory : 1024 disk spec : type=disk bus=None size=20 base=ubuntu:18.04 video : model=cirrus memory=16384 node : sf-2 power state : on state : created console port: 48420 vdi port : 32122 ssh key : None user data : None Metadata: Interfaces: uuid : db372968-1c74-4033-8423-8a698e9d4900 network : b41b067a-44b7-40c5-9ab8-7abdcf5fdc61 macaddr : 00:00:00:34:8d:90 order : 0 ipv4 : 192.168.0.3 floating: None model : virtio You can see that our instance (inst-on-sf-2) has been placed on sf-2 because we asked nicely (the -p is a placement option to the command), and has been allocated an IP (192.168.0.3). The virtual network still allocates IPs, even if DHCP is disabled. It has also been allocated a MAC address (00:00:00:34:8d:90). What is the state of the mesh on the network node now? sf-1 # bridge fdb show brport vxlan-2 de:c4:ab:3d:79:fb master br-vxlan-2 permanent de:c4:ab:3d:79:fb vlan 1 master br-vxlan-2 permanent 00:00:00:00:00:00 dst 10.2.1.11 self permanent 0a:ce:c4:f7:cb:dc dst 10.2.1.12 self de:c4:ab:3d:79:fb dst 127.0.0.1 self be:c1:1b:20:b8:f7 dst 127.0.0.1 self 00:00:00:34:8d:90 dst 10.2.1.12 self e2:2d:32:6d:95:70 dst 127.0.0.1 self The following entries there are new: 0a:ce:c4:f7:cb:dc dst 10.2.1.12 self 00:00:00:34:8d:90 dst 10.2.1.12 self These new entries: Add our new instance to the mesh (00:00:00:34:8d:90) And add vxlan-2 on sf-2 to the mesh (0a:ce:c4:f7:cb:dc) To repeat some commands from above but on sf-2, we now have two new network interfaces over there: sf-2 # ip addr list vxlan-2 127: vxlan-2: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 8950 qdisc noqueue master br-vxlan-2 state UNKNOWN group default qlen 1000 link/ether 0a:ce:c4:f7:cb:dc brd ff:ff:ff:ff:ff:ff inet6 fe80::8ce:c4ff:fef7:cbdc/64 scope link valid_lft forever preferred_lft forever sf-2 # ip addr show br-vxlan-2 128: br-vxlan-2: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 8950 qdisc noqueue state UP group default qlen 1000 link/ether 0a:ce:c4:f7:cb:dc brd ff:ff:ff:ff:ff:ff inet6 fe80::8ce:c4ff:fef7:cbdc/64 scope link valid_lft forever preferred_lft forever And the mesh looks like this: sf-2 # bridge fdb show brport vxlan-2 0a:ce:c4:f7:cb:dc master br-vxlan-2 permanent 0a:ce:c4:f7:cb:dc vlan 1 master br-vxlan-2 permanent 00:00:00:00:00:00 dst 10.2.1.11 self permanent 00:00:00:00:00:00 dst 10.2.1.12 self permanent 0a:ce:c4:f7:cb:dc dst 127.0.0.1 self 00:00:00:34:8d:90 dst 127.0.0.1 self e2:2d:32:6d:95:70 dst 10.2.1.11 self There is no network namespace on sf-2: sf-2 # ls /var/run/netns ls: cannot access '/var/run/netns': No such file or directory If we grep the console log of the instance on sf-2, we can see what cloud-init thought about the networking: sf-1 # grep ci-info /srv/shakenfist/instances/d53b345f-9d5d-493c-a1a3-7e7d6513cfa2/console.log [ 9.851378] cloud-init[643]: ci-info: +++++++++++++++++++++++++++++++++++++Net device info++++++++++++++++++++++++++++++++++++++ [ 9.856401] cloud-init[643]: ci-info: +--------+------+---------------------------+---------------+--------+-------------------+ [ 9.858628] cloud-init[643]: ci-info: | Device | Up | Address | Mask | Scope | Hw-Address | [ 9.862566] cloud-init[643]: ci-info: +--------+------+---------------------------+---------------+--------+-------------------+ [ 9.873611] cloud-init[643]: ci-info: | eth0 | True | 192.168.0.3 | 255.255.255.0 | global | 00:00:00:34:8d:90 | [ 9.884575] cloud-init[643]: ci-info: | eth0 | True | fe80::200:ff:fe34:8d90/64 | . | link | 00:00:00:34:8d:90 | [ 9.896315] cloud-init[643]: ci-info: | lo | True | 127.0.0.1 | 255.0.0.0 | host | . | [ 9.899272] cloud-init[643]: ci-info: | lo | True | ::1/128 | . | host | . | [ 9.904106] cloud-init[643]: ci-info: +--------+------+---------------------------+---------------+--------+-------------------+ [ 9.907816] cloud-init[643]: ci-info: +++++++++++++++++++++++++++++Route IPv4 info+++++++++++++++++++++++++++++ [ 9.912118] cloud-init[643]: ci-info: +-------+-------------+-------------+---------------+-----------+-------+ [ 9.913889] cloud-init[643]: ci-info: | Route | Destination | Gateway | Genmask | Interface | Flags | [ 9.917853] cloud-init[643]: ci-info: +-------+-------------+-------------+---------------+-----------+-------+ [ 9.920102] cloud-init[643]: ci-info: | 0 | 0.0.0.0 | 192.168.0.1 | 0.0.0.0 | eth0 | UG | [ 9.926243] cloud-init[643]: ci-info: | 1 | 192.168.0.0 | 0.0.0.0 | 255.255.255.0 | eth0 | U | [ 9.929182] cloud-init[643]: ci-info: +-------+-------------+-------------+---------------+-----------+-------+ [ 9.935249] cloud-init[643]: ci-info: +++++++++++++++++++Route IPv6 info+++++++++++++++++++ [ 9.942774] cloud-init[643]: ci-info: +-------+-------------+---------+-----------+-------+ [ 9.956377] cloud-init[643]: ci-info: | Route | Destination | Gateway | Interface | Flags | [ 9.959651] cloud-init[643]: ci-info: +-------+-------------+---------+-----------+-------+ [ 9.965082] cloud-init[643]: ci-info: | 1 | fe80::/64 | :: | eth0 | U | [ 9.968116] cloud-init[643]: ci-info: | 3 | local | :: | eth0 | U | [ 9.970423] cloud-init[643]: ci-info: | 4 | ff00::/8 | :: | eth0 | U | [ 9.974926] cloud-init[643]: ci-info: +-------+-------------+---------+-----------+-------+ ci-info: no authorized SSH keys fingerprints found for user ubuntu. [ 69.743452] cloud-init[970]: ci-info: no authorized SSH keys fingerprints found for user ubuntu. Here you can see that instance has an interface named eth0, which has the IP address that Shaken Fist allocated earlier. How did it get an IP address without DHCP? Well, Shaken Fist always attaches a config drive to the instance, and this contains a JSON file with the IP address in it. cloud-init running on boot of Ubuntu has used this to configure the interface. Before we poke more at this instance, let's start another instance on sf-3 so we can do some more testing...","title":"Single Instance"},{"location":"networking/single_instance/#networking-explained-single-node","text":"This page is part of a series explaining how Shaken Fist networking works . You might want to check out the other pages as well.","title":"Networking Explained - Single Node"},{"location":"networking/single_instance/#the-simplest-case-a-virtual-network-with-no-dhcp-and-no-nat-and-a-single-remote-instance","text":"Let's assume you want a new virtual network with no network services. Its just two instances talking to each other. The basic flow is like this -- you create a virtual network. We allocate you a VXLAN network id (called the vxid in various places in the code): sf-1 # sf-client network create demonet 192.168.0.0/24 --no-dhcp --no-nat uuid : b41b067a-44b7-40c5-9ab8-7abdcf5fdc61 name : demonet vxlan id : 2 netblock : 192.168.0.0/24 provide dhcp : False provide nat : False floating gateway: None namespace : system state : initial Metadata: So in this case we were allocated VXLAN id 2, and have a network UUID of b41b067a-44b7-40c5-9ab8-7abdcf5fdc61. The state of the network is \"initial\" as it has not been created anywhere yet. If you wait a few seconds, you'll see it transition to a \"created\" state. You can see the new state with a show command: sf-1 # sf-client network show b41b067a-44b7-40c5-9ab8-7abdcf5fdc61 uuid : b41b067a-44b7-40c5-9ab8-7abdcf5fdc61 name : demonet vxlan id : 2 netblock : 192.168.0.0/24 provide dhcp : False provide nat : False floating gateway: None namespace : system state : created Metadata: And you can see the steps we went through to create the network in the events listing: sf-1 # sf-client network events b41b067a-44b7-40c5-9ab8-7abdcf5fdc61 +----------------------------+------+------------------------+------------+----------------------+-----------+ | timestamp | node | operation | phase | duration | message | +----------------------------+------+------------------------+------------+----------------------+-----------+ | 2020-08-01 06:49:07.753351 | sf-1 | api | create | None | None | | 2020-08-01 06:49:07.792583 | sf-1 | create vxlan interface | start | None | None | | 2020-08-01 06:49:07.819312 | sf-1 | create vxlan interface | finish | 0.025562286376953125 | None | | 2020-08-01 06:49:07.840636 | sf-1 | create vxlan bridge | start | None | None | | 2020-08-01 06:49:07.905165 | sf-1 | create vxlan bridge | finish | 0.0644679069519043 | None | | 2020-08-01 06:49:07.910409 | sf-1 | create netns | start | None | None | | 2020-08-01 06:49:07.997595 | sf-1 | create netns | finish | 0.0850062370300293 | None | | 2020-08-01 06:49:08.016509 | sf-1 | create router veth | start | None | None | | 2020-08-01 06:49:08.237167 | sf-1 | create router veth | finish | 0.2197411060333252 | None | | 2020-08-01 06:49:08.254165 | sf-1 | create physical veth | start | None | None | | 2020-08-01 06:49:08.342684 | sf-1 | create physical veth | finish | 0.08613038063049316 | None | | 2020-08-01 06:49:08.371490 | sf-1 | add mesh elements | None | None | 10.2.1.11 | | 2020-08-01 06:49:08.375682 | sf-1 | api | created | None | None | | 2020-08-01 06:49:40.664204 | sf-1 | api | get | None | None | | 2020-08-01 06:50:07.554738 | sf-1 | api | get events | None | None | +----------------------------+------+------------------------+------------+----------------------+-----------+ You can see here that the network node (sf-1) has created some network elements, and an IP (10.2.1.11) has been added to the mesh. That IP is sf-1, and its part of the network node being joined to the mesh. If we look on sf-1, we should now have a VXLAN interface, a bridge, and one end of a veth. sf-1 # ip addr show vxlan-2 287: vxlan-2: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 8950 qdisc noqueue master br-vxlan-2 state UNKNOWN group default qlen 1000 link/ether de:c4:ab:3d:79:fb brd ff:ff:ff:ff:ff:ff inet6 fe80::dcc4:abff:fe3d:79fb/64 scope link valid_lft forever preferred_lft forever sf-1 # ip addr show br-vxlan-2 288: br-vxlan-2: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP group default qlen 1000 link/ether be:c1:1b:20:b8:f7 brd ff:ff:ff:ff:ff:ff inet6 fe80::bcc1:1bff:fe20:b8f7/64 scope link valid_lft forever preferred_lft forever sf-1 # ip addr show veth-2-o 290: veth-2-o@if289: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue master br-vxlan-2 state UP group default qlen 1000 link/ether be:c1:1b:20:b8:f7 brd ff:ff:ff:ff:ff:ff link-netnsid 0 inet6 fe80::bcc1:1bff:fe20:b8f7/64 scope link valid_lft forever preferred_lft forever The vxlan-2 interface is the VXLAN mesh, and the br-vxlan-2 bridge is how VMs and veths will connect to the mesh on this local machine. Its important to note that MTU matters here. The MTU for the mesh network is 1500 bytes, and most client VMs will default to that as well. Therefore the underlying network needs to have a MTU greater than that. We default to an MTU of 9000 bytes in our installs, but 1550 would in fact be sufficient in this case. You can see this in the MTU for vxlan-2, which is our 9000 byte underlying MTU, with 50 bytes deducted for the VXLAN encapsulation. We can also ask the mesh for its current state: sf-1 # bridge fdb show brport vxlan-2 de:c4:ab:3d:79:fb master br-vxlan-2 permanent de:c4:ab:3d:79:fb vlan 1 master br-vxlan-2 permanent 00:00:00:00:00:00 dst 10.2.1.11 self permanent de:c4:ab:3d:79:fb dst 127.0.0.1 self be:c1:1b:20:b8:f7 dst 127.0.0.1 self e2:2d:32:6d:95:70 dst 127.0.0.1 self The current members of the mesh are: de:c4:ab:3d:79:fb: this is the mac address for vxlan-2. 00:00:00:00:00:00 dst 10.2.1.11: this is a mesh entry for the node with IP 10.2.1.11 (sf-1) be:c1:1b:20:b8:f7: this is the outside mac address of a veth between br-vxlan-2 and a network namespace on sf-1 e2:2d:32:6d:95:70: is the inside mac address of the veth between br-vxlan-2 and the network namespace What is this network namespace? Well, Shaken Fist needs to create a network namespace to contain routing, NAT, and DHCP for the virtual network. It's actually not strictly required in this simplest case, but we always create it. It is named for the UUID of the virtual network: sf-1 # ip netns exec b41b067a-44b7-40c5-9ab8-7abdcf5fdc61 ip addr list 1: lo: <LOOPBACK> mtu 65536 qdisc noop state DOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 289: veth-2-i@if290: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP group default qlen 1000 link/ether e2:2d:32:6d:95:70 brd ff:ff:ff:ff:ff:ff link-netnsid 0 inet 192.168.0.1/24 scope global veth-2-i valid_lft forever preferred_lft forever inet6 fe80::e02d:32ff:fe6d:9570/64 scope link valid_lft forever preferred_lft forever 291: phy-2-i@if292: <BROADCAST,MULTICAST> mtu 1500 qdisc noop state DOWN group default qlen 1000 link/ether fe:18:8e:f8:d1:5c brd ff:ff:ff:ff:ff:ff link-netnsid 0 The veth between the VXLAN mesh and this namespace is named veth-2-i (the interface inside the network namespace) and veth-2-o (the interface outside the network namespace). There is another veth named phy-2-i and phy-2-o, which is a link between the namespace and the outside world, but we'll talk about that more when we enable NAT. For those who are new to veths, think of them like patch cables -- so what we have here is a VXLAN mesh, which is patched into a network namespace, which is in turn patched into the outside world. We also do some things with iptables, especially around NAT. Here's the current state of iptables in the network namespace: sf-1 # ip netns exec b41b067a-44b7-40c5-9ab8-7abdcf5fdc61 iptables -L -t nat Chain PREROUTING (policy ACCEPT) target prot opt source destination Chain INPUT (policy ACCEPT) target prot opt source destination Chain OUTPUT (policy ACCEPT) target prot opt source destination Chain POSTROUTING (policy ACCEPT) target prot opt source destination That's empty for now because we're not doing any NAT yet, but watch this space. Next let's now start an instance on sf-2. This instance can't use DHCP to get an address because we have that disabled for this network. sf-1 # sf-client instance create inst-on-sf-2 1 1024 -d 20@ubuntu:18.04 -n b41b067a-44b7-40c5-9ab8-7abdcf5fdc61 -p sf-2 uuid : d53b345f-9d5d-493c-a1a3-7e7d6513cfa2 name : inst-on-sf-2 namespace : system cpus : 1 memory : 1024 disk spec : type=disk bus=None size=20 base=ubuntu:18.04 video : model=cirrus memory=16384 node : sf-2 power state : on state : created console port: 48420 vdi port : 32122 ssh key : None user data : None Metadata: Interfaces: uuid : db372968-1c74-4033-8423-8a698e9d4900 network : b41b067a-44b7-40c5-9ab8-7abdcf5fdc61 macaddr : 00:00:00:34:8d:90 order : 0 ipv4 : 192.168.0.3 floating: None model : virtio You can see that our instance (inst-on-sf-2) has been placed on sf-2 because we asked nicely (the -p is a placement option to the command), and has been allocated an IP (192.168.0.3). The virtual network still allocates IPs, even if DHCP is disabled. It has also been allocated a MAC address (00:00:00:34:8d:90). What is the state of the mesh on the network node now? sf-1 # bridge fdb show brport vxlan-2 de:c4:ab:3d:79:fb master br-vxlan-2 permanent de:c4:ab:3d:79:fb vlan 1 master br-vxlan-2 permanent 00:00:00:00:00:00 dst 10.2.1.11 self permanent 0a:ce:c4:f7:cb:dc dst 10.2.1.12 self de:c4:ab:3d:79:fb dst 127.0.0.1 self be:c1:1b:20:b8:f7 dst 127.0.0.1 self 00:00:00:34:8d:90 dst 10.2.1.12 self e2:2d:32:6d:95:70 dst 127.0.0.1 self The following entries there are new: 0a:ce:c4:f7:cb:dc dst 10.2.1.12 self 00:00:00:34:8d:90 dst 10.2.1.12 self These new entries: Add our new instance to the mesh (00:00:00:34:8d:90) And add vxlan-2 on sf-2 to the mesh (0a:ce:c4:f7:cb:dc) To repeat some commands from above but on sf-2, we now have two new network interfaces over there: sf-2 # ip addr list vxlan-2 127: vxlan-2: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 8950 qdisc noqueue master br-vxlan-2 state UNKNOWN group default qlen 1000 link/ether 0a:ce:c4:f7:cb:dc brd ff:ff:ff:ff:ff:ff inet6 fe80::8ce:c4ff:fef7:cbdc/64 scope link valid_lft forever preferred_lft forever sf-2 # ip addr show br-vxlan-2 128: br-vxlan-2: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 8950 qdisc noqueue state UP group default qlen 1000 link/ether 0a:ce:c4:f7:cb:dc brd ff:ff:ff:ff:ff:ff inet6 fe80::8ce:c4ff:fef7:cbdc/64 scope link valid_lft forever preferred_lft forever And the mesh looks like this: sf-2 # bridge fdb show brport vxlan-2 0a:ce:c4:f7:cb:dc master br-vxlan-2 permanent 0a:ce:c4:f7:cb:dc vlan 1 master br-vxlan-2 permanent 00:00:00:00:00:00 dst 10.2.1.11 self permanent 00:00:00:00:00:00 dst 10.2.1.12 self permanent 0a:ce:c4:f7:cb:dc dst 127.0.0.1 self 00:00:00:34:8d:90 dst 127.0.0.1 self e2:2d:32:6d:95:70 dst 10.2.1.11 self There is no network namespace on sf-2: sf-2 # ls /var/run/netns ls: cannot access '/var/run/netns': No such file or directory If we grep the console log of the instance on sf-2, we can see what cloud-init thought about the networking: sf-1 # grep ci-info /srv/shakenfist/instances/d53b345f-9d5d-493c-a1a3-7e7d6513cfa2/console.log [ 9.851378] cloud-init[643]: ci-info: +++++++++++++++++++++++++++++++++++++Net device info++++++++++++++++++++++++++++++++++++++ [ 9.856401] cloud-init[643]: ci-info: +--------+------+---------------------------+---------------+--------+-------------------+ [ 9.858628] cloud-init[643]: ci-info: | Device | Up | Address | Mask | Scope | Hw-Address | [ 9.862566] cloud-init[643]: ci-info: +--------+------+---------------------------+---------------+--------+-------------------+ [ 9.873611] cloud-init[643]: ci-info: | eth0 | True | 192.168.0.3 | 255.255.255.0 | global | 00:00:00:34:8d:90 | [ 9.884575] cloud-init[643]: ci-info: | eth0 | True | fe80::200:ff:fe34:8d90/64 | . | link | 00:00:00:34:8d:90 | [ 9.896315] cloud-init[643]: ci-info: | lo | True | 127.0.0.1 | 255.0.0.0 | host | . | [ 9.899272] cloud-init[643]: ci-info: | lo | True | ::1/128 | . | host | . | [ 9.904106] cloud-init[643]: ci-info: +--------+------+---------------------------+---------------+--------+-------------------+ [ 9.907816] cloud-init[643]: ci-info: +++++++++++++++++++++++++++++Route IPv4 info+++++++++++++++++++++++++++++ [ 9.912118] cloud-init[643]: ci-info: +-------+-------------+-------------+---------------+-----------+-------+ [ 9.913889] cloud-init[643]: ci-info: | Route | Destination | Gateway | Genmask | Interface | Flags | [ 9.917853] cloud-init[643]: ci-info: +-------+-------------+-------------+---------------+-----------+-------+ [ 9.920102] cloud-init[643]: ci-info: | 0 | 0.0.0.0 | 192.168.0.1 | 0.0.0.0 | eth0 | UG | [ 9.926243] cloud-init[643]: ci-info: | 1 | 192.168.0.0 | 0.0.0.0 | 255.255.255.0 | eth0 | U | [ 9.929182] cloud-init[643]: ci-info: +-------+-------------+-------------+---------------+-----------+-------+ [ 9.935249] cloud-init[643]: ci-info: +++++++++++++++++++Route IPv6 info+++++++++++++++++++ [ 9.942774] cloud-init[643]: ci-info: +-------+-------------+---------+-----------+-------+ [ 9.956377] cloud-init[643]: ci-info: | Route | Destination | Gateway | Interface | Flags | [ 9.959651] cloud-init[643]: ci-info: +-------+-------------+---------+-----------+-------+ [ 9.965082] cloud-init[643]: ci-info: | 1 | fe80::/64 | :: | eth0 | U | [ 9.968116] cloud-init[643]: ci-info: | 3 | local | :: | eth0 | U | [ 9.970423] cloud-init[643]: ci-info: | 4 | ff00::/8 | :: | eth0 | U | [ 9.974926] cloud-init[643]: ci-info: +-------+-------------+---------+-----------+-------+ ci-info: no authorized SSH keys fingerprints found for user ubuntu. [ 69.743452] cloud-init[970]: ci-info: no authorized SSH keys fingerprints found for user ubuntu. Here you can see that instance has an interface named eth0, which has the IP address that Shaken Fist allocated earlier. How did it get an IP address without DHCP? Well, Shaken Fist always attaches a config drive to the instance, and this contains a JSON file with the IP address in it. cloud-init running on boot of Ubuntu has used this to configure the interface. Before we poke more at this instance, let's start another instance on sf-3 so we can do some more testing...","title":"The simplest case: a virtual network with no DHCP and no NAT, and a single remote instance"}]}