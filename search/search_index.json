{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":""},{"location":"#shaken-fist-an-open-cloud-aimed-at-small-and-edge-deployments","title":"Shaken Fist, an open cloud aimed at small and edge deployments","text":"<p>Shaken Fist is a deliberately opinionated cloud intended for small deployments. We spend a lot of time trying to do the simplest possible thing well, and keep our resource usage on idle deployments as low as possible. Shaken Fist has progressed from being a proof of concept to being a functional cloud, although the release numbers being below zero indicates that we are still stabilizing the REST API and that breaking changes might occur. 1.0 will be released when we are relatively sure of stability going forwards.</p> <p>Shaken Fist started a personal research project, but has grown into something which is starting to see wider contributions and some small commercial deployments.</p>"},{"location":"#the-underlying-idea","title":"The underlying idea","text":"<p>Originally Shaken Fist came about as a reaction to the increasing complexity of OpenStack, as well as a desire to experiment with alternative approaches to solving the problems that OpenStack Compute addresses. What I really wanted was a simple API to orchestrate virtual machines, but it needed to run with minimal resource overhead and be simple to deploy. I also wanted it to always work in a predictable way.</p> <p>One of the reasons OpenStack is so complicated and its behaviour varies is because it has many options to configure. The solution seemed obvious to me -- a cloud that is super opinionated. For each different functional requirement there is one option, and the simplest option is chosen where possible. Read on for some examples.</p>"},{"location":"#development-choices","title":"Development choices","text":"<p>If there is an existing library which does a thing, we use it. OpenStack suffered from being old (and having issues with re-writes being hard), as well as licensing constraints. We just use the code that others have provided to the community. Always.</p>"},{"location":"#deployment-choices","title":"Deployment choices","text":"<p>libvirt is the only supported hypervisor. Instances are specified to libvirt with simple templated XML. If your local requirements are different to what's in the template, you're welcome to change the template to meet your needs. If your template changes break things, you're also welcome to debug what went wrong for yourself.</p>"},{"location":"#id-like-to-subscribe-to-your-newsletter","title":"\"I'd like to subscribe to your newsletter\"","text":"<p>First off, we don't have a newsletter. That said, updates will be announced here as they happen. What we do have is useful links:</p> <ul> <li> <p>The Shaken Fist repository is where   the code for the server is, including the deployer. Its a good place to start.</p> </li> <li> <p>There is also the python client repository   contains the python API client, as well as the command line client that users   and shell scripts use to interact with Shaken Fist.</p> </li> </ul>"},{"location":"#what-is-shaken-fist-can-i-help","title":"What is Shaken Fist? Can I help?","text":"<p>The Shaken Fist Manifesto is our general conceptual starting point, but apart from that just reach out and have a chat.</p>"},{"location":"community/","title":"Welcome to the Shaken Fist community","text":"<p>First off, Shaken Fist is an open source project covered by the Apache2 license. The community is relatively small at this point and we're still working out what works for us. For now, we communicate through the following mechanisms:</p> <ul> <li>GitHub issues and pull requests in the various repositories.</li> <li>A slack workspace at https://shakenfist.slack.com -- unfortunately you need to be invited to that workspace, but we're happy to do that. If you're interested, please email mikal@stillhq.com.</li> </ul>"},{"location":"community/#supporters","title":"Supporters","text":"<p>We try to track supporters here. Our apologies if we've missed someone, let us know and we'll fix it.</p> <ul> <li>Michael Still and Andrew McCallum have contributed significant personal time to the project.</li> <li>Aptira has donated developer time, as well as provided invaluable feedback from the largest real world deployments that we've had so far.</li> <li>FifthDomain has also donated developer time.</li> <li>Shaken Fist was a recipient of a 2020 Icculus micro grant.</li> </ul>"},{"location":"features/","title":"Feature matrix","text":"<p>What features does Shaken Fist have now? What about in the future? This page attempts to document the currently implemented features, but it is a bit a moving target. If you're left wondering if something works, please reach out to us and ask.</p>"},{"location":"features/#high-level-functionality","title":"High level functionality","text":"<p>Our high level functionality is why you'd consider using Shaken Fist. Specifically, we support:</p> <ul> <li>instances: which are virtual machines deployed and managed by Shaken Fist.</li> <li>virtual networks: which are VXLAN meshes between hypervisors managed by Shaken Fist. These virtual networks do automatic IP address management, optionally provide DHCP and NAT, and support floating IPs for external accessability.</li> <li>resource efficiency: we try hard to not use much in terms of resources in an orchestration idle state (that is, your workload isn't changing), but we also deploy and configure Kernel Shared Memory (KSM) and make heavy use of qcow2 Copy On Write (COW) layers to reduce the resources used by a single instance. This means you can pack more instances onto a Shaken Fist cluster than you can alternative deployments of the same size from other projects.</li> </ul>"},{"location":"features/#object-types","title":"Object types","text":"<p>We also have a lot of implementation functionality that is quite useful, but not the sort of thing you'd put on a billboard. Let's work through that by object type.</p>"},{"location":"features/#artifacts","title":"Artifacts","text":"<p>Artifacts are Shaken Fist's object type for disk images -- the sort of thing that you would store in Glance in OpenStack. Artifacts can store downloaded disk images from the internet (the \"image\" type), snapshots of previous instances (the \"snapshot\" type), and arbitrary uploads (also stored with the \"image\" type). There is also a special \"label\" artifact type, which is an overlay on top of the other types. Its easiest to explain its behavior by explaining the lifecycle of an artifact.</p> <p>The normal way to get your first artifact is to download something from the internet. So for example, you might start an instance with a standard Ubuntu cloud image from https://cloud-images.ubuntu.com/. This would be done by specifying the URL of the image in the disk specification of the image: Shaken Fist will then download the image and store it as an artifact, and then start your instance. A second instance using the same image will then check the image at the URL hasn't changed, and if it hasn't use the same artifact as the first instance, skipping the repeated download.</p> <p>However, if the image has changed, a second version would be downloaded. Depending on the settings for the artifact, both versions are retained. By default Shaken Fist keeps the last three versions of each artifact, although this is configurable.</p> <p>Now let's assume that you have a nightly CI job which starts an instance from the latest Ubuntu cloud image, and performs some tests to ensure that it works for your software stack. You want to somehow mark for your other workloads what versions of the Ubuntu image are trusted, and you do this with a label. So, your CI job would specify the upstream URL for the cloud image, perform its tests, and then label the image if it passed those tests. Other Ubuntu users in your cloud could then specify that they wanted the most recent version which passed testing by specifying the label for their disk specification, instead of the upstream URL.</p> <p>Shaken Fist's CI does exactly this. Each night we download a set of cloud images, customize them to make the CI runs a bit faster (pre-installing packages and so forth), and then test that they work. At the end of that run we take a snapshot of the instance we customized, and label it with a label along the lines of \"sfci-ubuntu-2004\". CI jobs then use that label for their base disk. You can see the ansible we use to do this at https://github.com/shakenfist/shakenfist/blob/develop/deploy/ansible/ci-image.yml if you're interested.</p> <p>The following operations are exposed on artifacts by the REST API:</p> Operation Command line client API client list artifacts <code>artifact list</code> <code>get_artifacts()</code> show an artifact <code>artifact show</code> <code>get_artifact()</code> fetch an artifact from a URL without starting an instance <code>artifact cache</code> <code>cache_artifact()</code> upload <code>artifact upload</code> <code>create_upload()</code> followed by calls to <code>send_upload()</code> and then <code>upload_artifact()</code> download <code>artifact download</code> lookup the desired version's blob with <code>get_artifact()</code>, then download with <code>get_blob_data()</code> show detailed information about versions <code>artifact versions</code> <code>get_artifact_versions()</code> delete <code>artifact delete</code> <code>delete_artifact()</code> delete a version <code>artifact delete-version</code> <code>delete_artifact_version()</code> set the maximum number of versions <code>artifact max-versions</code> <code>set_artifact_max_versions()</code> <p>Note that artifacts exist in namespaces (since v0.6). This means that your artifacts are private to your namespace, and can't be seen or used by other namespaces. There are two exceptions -- the \"system\" administrative namespace can see all artifacts, and the \"system\" namespace can create artifacts visible to all other namespaces -- this is done with the shared flag on the relevant command line or API calls, and uses a \"sharedwithall\" namespace in the database.</p>"},{"location":"features/#blobs","title":"Blobs","text":"<p>Each version of an artifact is an object called a blob. Blobs are stored on Shaken Fist nodes, and are automatically replicated around the cluster as required. By default we store at least two copies of each blob, although this is configurable. Its possible we'll store a lot more copies than that, because we only reap excess copies when we start to run low on disk. This is because these blobs are often used during the startup of instances, so having a local cache of popular blobs can significantly improve instance start up times.</p> <p>All hypervisor nodes store blobs, but it is also possible to have \"storage only\" nodes which don't run VMs and just store blobs. In previous deployments we have used these storage nodes to handle having more blobs than we need for currently running instances -- for example historical snapshots we are fond of, but are unlikely to require frequent access to. The storage nodes were therefore a cheaper machine type with slower CPU and disk, but a lot more disk than our hypervisor nodes.</p> <p>So for example if you had an edge deployment where you are resource constrained, but also want to take nightly instance snapshots as a backup, you might have a more centrally located storage node and Shaken Fist would migrate unused blobs there to free up space on the edge nodes as required. If a blob only present on a storage only node is required for an instance start, a hypervisor node will fetch it at that time.</p> <p>Finally, blobs are reference counted. They can be used by more than one artifact (for example an image which is then labelled), and we also count how many instances are using a specific blob. We only delete a blob from disk when there are no remaining references to it.</p> <p>The following operations are exposed on blobs by the REST API:</p> Operation Command line client API client list blobs <code>blob list</code> <code>get_blobs()</code>"},{"location":"features/#events","title":"Events","text":"<p>Shaken Fist has an event logging system for the main object types. So for example, instead of reading through log files to find all the state changes that an instance went through, you can simply ask for a list of the events for that instance. This also means that the instance owner can see those logs without having to be given access to your log files.</p> <p>The following object types currently record events: artifacts; blobs; instances; networks; networkinterfaces; nodes; and uploads. In general, events are exposed in the API as operations on the object they relate to. So for example there is a <code>instance events</code> command, which calls the <code>get_instance_events()</code> API client call. Those various calls are documented by their object type.</p>"},{"location":"features/#networks","title":"Networks","text":"<p>Note that networks exist in namespaces. This means that your networks are private to your namespace, and can't be seen or used by other namespaces. There is one exception -- the \"system\" administrative namespace can see all networks.</p>"},{"location":"features/#instances","title":"Instances","text":"<p>Instances are the primary reason that you'd run Shaken Fist, so there's a lot to cover in their implementation. Obviously instances can be created, deleted, listed, and shown. Additionally, you can list the network interfaces on an instance, track and change metadata on a given instance (a simple key value store similar to OpenStack tags), request the current serial console output; and see events related to the instance. Instances can also have their power state managed: soft (ACPI) reboots; hard (power cycle) reboots; powered off; powered on; and paused.</p> <p>When creating an instance you can configure:</p> <ul> <li>the name of the instance</li> <li>how many vCPUs the instance has</li> <li>how much memory the instance has</li> <li>what network connections the instance has, including floating IP attachments and the network interface model to use</li> <li>what disks the instance has, their size, type, and bus</li> <li>what ssh key cloud-init should set up, if your instance includes cloud-init</li> <li>other arbitrary user data which will be passed to cloud-init, if installed</li> <li>the namespace of the instance</li> <li>what video card the instance has, including the model and amount of video memory</li> <li>whether BIOS boot or UEFI boot is used</li> <li>whether secure boot is enabled, including a NVRAM template if required</li> <li>what configuration drive type is used, with a default of OpenStack style</li> <li>key and value metadata</li> </ul> <p>Note that instances exist in namespaces. This means that your instances are private to your namespace, and can't be seen or used by other namespaces. There is one exception -- the \"system\" administrative namespace can see all instances.</p>"},{"location":"features/#other-features","title":"Other features","text":"<p>Shaken Fist supports the follow other features that are not directly related to an object type:</p> <ul> <li>JWT based API authentication</li> <li>graceful shutdown of hypervisors where current work is finished before the processes are stopped</li> <li>online upgrade of object versions as required</li> </ul>"},{"location":"features/#comparison-to-openstack","title":"Comparison to OpenStack","text":"<p>The development team's background is OpenStack, so we find it useful to provide a comparison between what OpenStack supports and what Shaken Fist supports. However, Shaken Fist does not intend to be a direct replacement for OpenStack, and implements many features not present in OpenStack (for example in guest agents).</p> <p>Here's a simple feature matrix listing when a feature was introduced:</p> Feature Implemented Planned Not Planned Servers / instances v0.1 Networks v0.1 Multiple NIC's for a given server v0.1 Pre-cache a server image v0.1 Floating IPs v0.1 Pause v0.1 Reboot (hard and soft) v0.1 Security groups Yes Text console v0.1 VDI v0.1 User data v0.1 Keypairs v0.1 Virtual networks allow overlapping IP allocations v0.1 REST API authentication and object ownership v0.2 Snapshots (of all disks) v0.1 Central API service v0.1 Scheduling v0.1 Volumes No plans Quotas No plans API versioning No plans Keystone style service lookup and URLs No plans Create multiple servers in a single request No plans Resize a server No plans Server groups No plans Change admin password No plans Rebuild a server No plans Shelve / unshelve No plans Trigger crash dump No plans Live migration No plans Flavors No plans Guest agents No plans Host aggregates No plans Server tags v0.2, we call them \"metadata\" ~~Persistence in MySQL~~ v0.1 Distributed etcd for locking and persistence v0.2 Production grade REST API via gunicorn v0.2 Python REST API client v0.1 golang REST API client v0.2 Terraform provider v0.2"},{"location":"manifesto/","title":"The Shaken Fist Manifesto","text":"<p>This document attempts to list Shaken Fist's defining features, give guidance on what type of features should be added to the project, how they should be implemented and how we work together.</p>"},{"location":"manifesto/#shaken-fist-defining-characteristics","title":"Shaken Fist Defining Characteristics","text":"<ul> <li>Shaken Fist is smaller, simpler cloud.</li> <li>It is designed for relatively small environments with minimum management overhead.</li> <li>Its features are highly opinionated. This means that the maintainers have chosen   the best (in their opinion) features to support.</li> <li>Opinionated features do not handle every single possible use case. This reduces   the code base size thus increasing long-term maintainability.</li> <li>The code base is understandable in its entirety by a single developer.</li> <li>A Shaken Fist cluster does not need a team of engineers to install or operate.</li> <li>A Shaken Fist cluster should be simple to set up. We define 'simple' as \"a person   with no knowledge of the project can build a reasonable cluster in an evening\".</li> </ul>"},{"location":"manifesto/#project-goals","title":"Project Goals","text":"<ul> <li>Allow simple management of virtual machine instances without complexity.</li> <li>Support networking between those machines and also facilitate access to external   networks.</li> <li>Avoid re-inventing the wheel (utilise other open source projects when appropriate).</li> </ul>"},{"location":"manifesto/#feature-guidelines","title":"Feature Guidelines","text":"<ul> <li>Features should be deliberately limited in the options available.</li> <li>The goal of limiting options is to reduce code complexity. If the option does   not add significant code complexity then it should added.</li> <li>The supported features and the options of those features should aim to cover   the majority of use cases.</li> <li>When a feature limits the available options, it should do so in a way that does   not overly restrict a project fork from adding that option.</li> <li>New code should conform to the conventions of the existing code base and written   to be easily understood.</li> <li>New code should have new tests (please).</li> </ul>"},{"location":"manifesto/#significant-opinionated-design-decisions","title":"Significant Opinionated Design Decisions","text":"<ul> <li>The only supported hypervisor is KVM managed by libvirt.</li> <li>Virtual networking is only implemented via VXLAN meshes.</li> <li>Single machine clusters should always be possible.</li> <li>Only the current Ubuntu LTS version and Debian supported by the main project   (pull requests to support other operating systems are encouraged).</li> </ul>"},{"location":"manifesto/#project-interaction-guidelines","title":"Project Interaction Guidelines","text":"<ul> <li>Always polite.</li> <li>Always generous.</li> <li>Being opinionated is encouraged (but gently).</li> <li>Updating the documentation is just as important as the code change itself.</li> <li>Developers who write tests are the most highly prized of all the developers.</li> </ul>"},{"location":"components/kerbside/","title":"Kerbside","text":"<p>Kerbside is a SPICE protocol native VDI proxy responsible for providing rich VDI experiences to users of Shaken Fist, oVirt, OpenStack, or any other cloud where the hypervisor is capable of providing SPICE consoles over the network.</p> <p>The SPICE protocol has existed for a long time, and still represents the richest and most performant option for remote desktops using Open Source technologies. Before Kerbside, consoles were generally provided by a HTML5 transcoded interface in a web client. Unfortunately, HTML5 interfaces do not support many of the more novel features of the SPICE protocol, nor do they support high resolution desktops. By avoiding transcoding to a HTML5 client, we avoid these problems.</p> <p>Novel features of SPICE include high resolution desktops, multi-screen desktops, USB device passthrough, sound, multiple user connections to a single console, adaptive compression, and more.</p>"},{"location":"components/kerbside/#kerbside-is-experimental","title":"Kerbside is experimental","text":"<p>Kerbside is currently considered experimental. While it works, it has not yet seen large scale deployment and it is likely that it will needed modifications as it is hardened for production use.</p>"},{"location":"components/kerbside/#kerbside-is-a-proxy-not-a-complete-user-interface","title":"Kerbside is a proxy, not a complete user interface","text":"<p>Whilst Kerbside presents a simple administrative interface over HTTP and has REST APIs for orchestrating consoles, it is not intended as a complete SPICE desktop VDI solution. It is intended that Kerbside itself is orchestrated by an external system. That is, in order for a desktop to be presented to a user the following steps need to occur:</p> <ul> <li> <p>The user requests a desktop via an external user interface that we call \"the   Broker\". In Shaken Fist's case the broker is embedded in Shaken Fist itself   and is initiated via a Shaken Fist REST API. In the OpenStack case this role   is likely performed by Horizon or Skyline, although this is not yet implemented.</p> </li> <li> <p>The cloud boots the instance that runs the desktop. The Broker waits for the   instance to be booted.</p> </li> <li> <p>The Broker requests a <code>.vv</code> virt-viewer compatible ini file from Kerbside, and   delivers that to the requesting user. The configuration file describes a   connection to Kerbside, along with short lived access token.</p> </li> <li> <p>The user opens the <code>.vv</code> file with a SPICE client such as <code>remote-viewer</code>.   <code>remote-viewer</code> connects to Kerbside.</p> </li> <li> <p>Kerbside uses the access token to determine which instance in the cloud is   the requested desktop and initiates a proxied connection to the hypervisor.</p> </li> <li> <p>The user then happily uses their SPICE console, largely unaware of these   various steps.</p> </li> </ul>"},{"location":"components/kerbside/#implementation-in-openstack","title":"Implementation in OpenStack","text":"<p>The Kerbside implementation in OpenStack is still experimental and has not yet landed upstream. There is a proposed Nova specification to add the APIs required to orchestrate the consoles, but it is not yet approved. Apart from the modifications to Nova's APIs there are some minor changes to the libvirt domain XML that must be made to expose full SPICE console support in virtual machines managed by OpenStack.</p> <p>Additionally, Kerbside needs to be deployed as a component of the OpenStack cluster in order to provide a safe mechanism for users to interact with their console. OpenStack is (wisely) unwilling to provide direct network connectivity from a client network to TCP ports on the hypervisor, and so Kerbside acts as an intermediary to protect those hypervisors. There is a sample implementation of Kerbside deployment using Kolla-Ansible in the Kerbside Patches repository.</p>"},{"location":"components/kerbside/#what-about-bumblebee","title":"What about Bumblebee?","text":"<p>The folks over at the NECTAR research cloud developed Bumblebee VDI, which is superficially similar to Kerbside in that it provides a mechanism to make it easier to obtain a virtual desktop as a user. The Kerbside description above would classify Bumblebee as a Broker to our model -- it orchestrates the creation and then access to virtual desktops for users. However, Bumblebee exclusive orchestrates HTML5 consoles using Apache Guacamole as its HTML5 proxy at the moment, so misses out on some of the richer features of SPICE and has the performance implications of a HTML5 desktop environment.</p>"},{"location":"components/overview/","title":"What are the components of a Shaken Fist cluster?","text":"<p>Shaken Fist is composed of a series of components. There is Shaken Fist itself, which provides the orchestration and APIs to handle compute and virtual networks. The majority of this website discusses Shaken Fist, and if it is not specified, then you should assume that Shaken Fist is the component providing functionality.</p> <p>Kerbside is a SPICE protocol native VDI proxy responsible for providing rich VDI experiences to users of Shaken Fist. You can read more about Kerbside at the page linked above.</p>"},{"location":"components/kerbside/config/","title":"Configuring Kerbside","text":"<p>The following options are provided by Kerbside.</p>"},{"location":"components/kerbside/config/#basic-settings","title":"Basic Settings","text":"Configuration option\u00a0 Type\u00a0 Description\u00a0 SOURCES_PATH\u00a0 String\u00a0 The path the console sources file (sources.yaml) resides at.\u00a0 SQL_URL\u00a0 String\u00a0 The sqlalchemy SQL connection URL for the VDI proxy database.\u00a0 CONSOLE_TOKEN_DURATION\u00a0 Integer\u00a0 (default 1)\u00a0 The number of minutes a console access token should be valid for.\u00a0 AUTH_SECRET_SEED\u00a0 String\u00a0 (no default)\u00a0 A random string used to hash the signatures on JWT authentication tokens. That is, knowledge of this string is required to sign a JWT. API_TOKEN_DURATION\u00a0 Integer\u00a0 (default 60)\u00a0 The number of minutes that a JWT is valid for after being issued. Importantly, Keystone credentials are only validated on JWT creation, so it is possible for a JWT to outlive the Keystone user access token it encapsulates."},{"location":"components/kerbside/config/#tls-settings","title":"TLS Settings","text":"Configuration option\u00a0 Type\u00a0 Description\u00a0 CACERT_PATH\u00a0 String\u00a0 The path to the TLS CA certificate.\u00a0 PROXY_HOST_SUBJECT\u00a0 String\u00a0 The TLS Host-Subject to use for the proxy TLS certificate.\u00a0 PROXY_HOST_CERT_PATH\u00a0 String\u00a0 The path to the TLS certificate for the proxy.\u00a0 \u00a0 PROXY_HOST_CERT_KEY_PATH\u00a0 String\u00a0 The path to the file containing the key for the proxy TLS certificate."},{"location":"components/kerbside/config/#keystone-settings","title":"Keystone Settings","text":"Configuration option\u00a0 Type\u00a0 Description\u00a0 KEYSTONE_AUTH_URL\u00a0 String\u00a0 (no default)\u00a0 The URL including scheme and port that is to be used to authenticate the Keystone service account for the proxy, and subsequently all proxy user authentications.\u00a0 \u00a0 KEYSTONE_SERVICE_AUTH_USER\u00a0 String\u00a0 (no default)\u00a0 \u00a0 The service account username.\u00a0 KEYSTONE_SERVICE_AUTH_PASSWORD\u00a0 String\u00a0 (no default)\u00a0 \u00a0 The password for the service account.\u00a0 KEYSTONE_SERVICE_AUTH_USER_DOMAIN_ID\u00a0 String\u00a0 (default \u201cdefault\u201d)\u00a0 \u00a0 The domain the service account resides in.\u00a0 KEYSTONE_SERVICE_AUTH_PROJECT\u00a0 String\u00a0 (default \u201cadmin\u201d)\u00a0 \u00a0 The project the service account resides in.\u00a0 KEYSTONE_SERVICE_AUTH_PROJECT_DOMAIN_ID\u00a0 String\u00a0 (default \u201cdefault\u201d)\u00a0 \u00a0 The project domain the service account resides in.\u00a0 KEYSTONE_ACCESS_GROUP\u00a0 String\u00a0 (default \u201ckerbside\u201d)\u00a0 The Keystone group that users wishing to access the VDI proxy administrative interface or REST API must be a member of."},{"location":"components/kerbside/config/#proxy-api-service","title":"Proxy API Service","text":"Configuration option\u00a0 Type\u00a0 Description\u00a0 API_PORT\u00a0 Integer\u00a0 (default 13002)\u00a0 The TCP port that the REST API and HTML administrative interface will listen on.\u00a0 API_TIMEOUT\u00a0 Integer\u00a0 (default 30)\u00a0 The maximum number of seconds an API request can take to execute before gunicorn will kill it. The VDI proxy has no long API requests, so this should not need tuning.\u00a0 \u00a0 API_COMMAND_LINE\u00a0 String\u00a0 The command line used to execute gunicorn to serve the REST API and HTML administrative interface.\u00a0 \u00a0 PID_FILE_LOCATION\u00a0 String\u00a0 (default /tmp/)\u00a0 \u00a0 The directory the gunicorn PID file is located in.\u00a0 PUBLIC_FQDN\u00a0 String\u00a0 The DNS name for the load balancers serving all Kerbside traffic. This needs to be configured to ensure DNS and the SSL certificates for the VDI proxy match or the certificates will be invalid.\u00a0 \u00a0 NODE_NAME\u00a0 String\u00a0 A unique name for each machine or container running the VDI proxy. This is used for logging purposes.\u00a0 \u00a0 VDI_ADDRESS\u00a0 String\u00a0 The IP the VDI proxy will bind to.\u00a0 VDI_SECURE_PORT\u00a0 Integer\u00a0 (defaults to 5898)\u00a0\u00a0 The port the VDI proxy will serve SPICE TLS SPICE sessions over.\u00a0 \u00a0 VDI_INSECURE_PORT Integer\u00a0 (defaults to 5988)\u00a0 The port the VDI proxy will serve insecure SPICE sessions over. These insecure sessions are only used to redirect the user to the secure port."},{"location":"components/kerbside/config/#traffic-inspection","title":"Traffic Inspection","text":"<p>Being able to inspect traffic being passed by the proxy is useful during both development and whilst  diagnosing issues in production but has obvious privacy concerns. The VDI proxy may be configured to log details of traffic for all sessions by setting the <code>KERBSIDE_TRAFFIC_INSPECTION</code> environment variable to \u201c1\u201d. This will write session traffic details to the directory configured by  <code>KERBSIDE_TRAFFIC_OUTPUT_PATH</code>, in a sub directory per session identifier. Additionally, more detailed information can be logged by also setting <code>KERBSIDE_TRAFFIC_INSPECTION_INTIMATE</code> to \u201c1\u201d.</p> <p>Traffic inspection is per proxy not per session and implies a restart of the proxy before it is enabled. This ensures that users are aware that traffic inspection has been enabled. If traffic inspection is enabled, audit messages are recorded per channel logged (as not all channels need to flow through the same proxy machine). Additionally, the display channel is altered to show a dashed red and yellow border to provide a visual warning that this inspection is occurring.</p> Configuration option\u00a0 Type\u00a0 Description\u00a0 TRAFFIC_INSPECTION\u00a0 Boolean\u00a0 (default False)\u00a0 Whether to log detailed traffic information. Defaults to false, but can be useful for debugging service issues in production.\u00a0 \u00a0 TRAFFIC_INSPECTION_INTIMATE\u00a0 Boolean\u00a0 (default False)\u00a0 If TRAFFIC_INSPECTION is true and this option is also set to true, then log intimate debug details of sessions including keystrokes and all display frames.\u00a0 \u00a0 TRAFFIC_OUTPUT_PATH\u00a0 String\u00a0 (default /tmp)\u00a0 Where to write traffic inspection logs to if enabled."},{"location":"components/kerbside/config/#logging-and-monitoring-settings","title":"Logging and Monitoring Settings","text":"<p>The VDI proxy provides Prometheus style metrics on port 9999 (configurable using the  <code>PROMETHEUS_METRICS_PORT</code> configuration option). These metric values are also be logged for later processing if desired. Values tracked include:  * Number of active console sessions.  * Number of active console channels.  * Bandwidth and latency information for each console channel.  * REST API request statuses as a metric with labels for each HTTP status code.  * REST API request response latency as a histogram per HTTP status code. </p> Configuration option\u00a0 Type\u00a0 Description\u00a0 LOG_OUTPUT_PATH\u00a0 String\u00a0 \u00a0 Where to write logs to. If stdout, then stdout is used, if blank syslog is used.\u00a0 LOG_OUTPUT_JSON\u00a0 Boolean\u00a0 (default False)\u00a0 If true, log entries are in JSON. LOG_VERBOSE\u00a0 Boolean\u00a0 (default False)\u00a0 Whether to log verbose debugging information.\u00a0 \u00a0 \u00a0 PROMETHEUS_METRICS_PORT\u00a0 Integer\u00a0 (default 13003)\u00a0 The TCP port that the prometheus metrics HTTP server will listen on."},{"location":"components/kerbside/console-sources/","title":"Console Sources","text":"<p>Kerbside can connect to the following platforms: * Shaken Fist * oVirt, an Open Source Red Hat supported virtualization system * OpenStack, an Open Source cloud compute platform</p> <p>The connection to each platform (a source of consoles, so \"console sources\") is defined in the <code>sources.yaml</code> configuration file in YAML format.</p> <p>Console sources are queried regularly (once a minute) for a list of consoles available. It is possible to have more than one console source for a given type as well, so for example the VDI proxy could be used to combine virtual machines from two OpenStack clusters together seamlessly.</p>"},{"location":"components/kerbside/console-sources/#shaken-fist","title":"Shaken Fist","text":"<p>The following options are used to configure a Shaken Fist console source (<code>type: shakenfist</code>).</p> Option Description source The name of the source type The type of the source: <code>shakenfist</code> url The API URL for the source username The Shaken Fist namespace to authenticate to. password The password to authenticate with ca_cert Optional: the SSL CA public key certificate to validate API and VDI connections against"},{"location":"components/kerbside/console-sources/#ovirt","title":"oVirt","text":"<p>The following options are used to configure an oVirt console source (<code>type: ovirt</code>).</p> Option Description source The name of the source type The type of the source: <code>ovirt</code> url The API URL for the source username The username to authenticate to the source as password The password to authenticate with ca_cert Optional: the SSL CA public key certificate to validate API and VDI connections against"},{"location":"components/kerbside/console-sources/#openstack","title":"OpenStack","text":"<p>The following options are used to configure an OpenStack console source (<code>type: openstack</code>).</p> Option Description source The name of the source type The type of the source: `openstack url The API URL for the source username The username to authenticate to the source as . In the case of Shaken Fist, which does not have usernames, this is interpreted by Shaken Fist as the namespace to authenticate to. password The password to authenticate with ca_cert Optional: the SSL CA public key certificate to validate API and subsequent VDI connections against project_name The OpenStack project name for the associated used user_domain_id The OpenStack user domain id project_domain_id The OpenStack project domain id flavors The list of the flavors to expose as a console."},{"location":"components/kerbside/console-sources/#example-sourcesyaml","title":"Example sources.yaml","text":"<p>An example follows: <pre><code>- source: sfmel \n  type: shakenfist \n  url: https://sfmel.example.org/api \n  username: sfvdi \n  password: \u2026omitted\u2026 \n  ca_cert: | \n    -----BEGIN CERTIFICATE----- \n    \u2026 \n    -----END CERTIFICATE----- \n\n- source: ovirt \n  type: ovirt \n  url: https://ovirt.example.org/ovirt-engine \n  username: Kerbside@internal \n  password: \u2026\n  ca_cert: | \n    -----BEGIN CERTIFICATE----- \n    \u2026 \n    -----END CERTIFICATE----- \n\n- source: kolla \n  type: openstack \n  url: http://kolla.example.org:5000 \n  username: admin \n  password: \u2026\n  project_name: admin \n  user_domain_id: default \n  project_domain_id: default \n  flavors: \n    - vdi \n    - othervdi \n</code></pre></p>"},{"location":"developer_guide/authentication/","title":"Authentication and Namespaces","text":"<p>Shaken Fist uses JWT tokens for authentication and access control. These tokens are created with a request to the REST API and then passed as part of subsequent calls in the form of a HTTP header on the request. The tokens can expire, in which case a caller needs to re-authenticate and then retry their request. The process to create and use a token is discussed further in the Authentication section below.</p> <p>Shaken Fist logically divides objects into \"namespaces\". These namespaces can be thought of as tenants, although there might be other reasons to divide resources into their own buckets -- for example the Shaken Fist CI system uses a namespace to store an archive of the images used for CI runs, and that namespace is referred to by the namespaces actually running tests. The process to create a namespace is discussed in the Creating namespaces section below.</p>"},{"location":"developer_guide/authentication/#namespaces","title":"Namespaces","text":"<p>All resources (instances, networks, network interfaces, and artifacts) are assigned to a namespace. Notably, blobs are not within namespaces and more than one artifact can refer to a given blob even if those artifacts are in different namespaces. It is assumed that knowing the UUID of a given blob implies that you can access it.</p> <p>All requests to Shaken Fist have a namespace context. The namespace \"system\" is reserved and is used for administrative actions. Please note that the authentication configuration created by the <code>getsf</code> installer is for the system namespace, and if used directly will result in instances and other objects being created in that namespace. While this is supported and will function as expected, it is probably undesirable for anything other than a single user installation.</p> <p>By default only requests in the system namespace are able to access resources in other (foreign) namespaces. Before Shaken Fist v0.7 this behavior was hard coded and not configurable. As of Shaken Fist v0.7, this is implemented in the form of \"trusts\", where every namespace is configured to \"trust\" the system namespace. This makes the resources visible to the system namespace. You cannot remove the trust of the system namespace from your namespaces. However, you can choose to trust additional namespaces, and this is done via the <code>sf-client namespace trust ...</code> series of commands and associated API calls.</p>"},{"location":"developer_guide/authentication/#authentication","title":"Authentication","text":"<p>When the <code>getsf</code> installer ran, it created two authentication artifacts on the primary node which are useful to get started with Shaken Fist. First off, there is <code>/etc/sf/sfrc</code>, which is a file you can source in your shell to provide authentication environment variables. These environment variables can be used by Shaken Fist command line clients, Ansible modules, and the Python API client implementation itself. An example <code>sfrc</code> looks like this:</p> <pre><code># Command line hinting\neval \"$(_SF_CLIENT_COMPLETE=bash_source sf-client)\"\n\n# Use the v3 etcd API\nexport ETCDCTL_API=3\n\n# Client auth\nexport SHAKENFIST_NAMESPACE=\"system\"\nexport SHAKENFIST_KEY=\"oisoSe7T\"\nexport SHAKENFIST_API_URL=\"https://shakenfist/api\"\n</code></pre> <p>The first two lines of the file enable tab completion for <code>sf-client</code> in a bash shell. The middle section defaults <code>etcd</code> to use the v3 API and can be ignored for now. The last three lines are the important authentication details:</p> <ul> <li>the namespace we want to use is called \"system\".</li> <li>our access key is \"oisoSe7T\".</li> <li>the URL the API exists at is \"https://shakenfist/api\"</li> </ul> <p><code>sfrc</code> is only useful to users of Unix-like shells, so there is also a JSON form of this configuration information, which is written by <code>getsf</code> at <code>/etc/sf/shakenfist.json</code>. Here's an example:</p> <pre><code>{\n    \"namespace\": \"system\",\n    \"key\": \"oisoSe7T\",\n    \"apiurl\": \"https://shakenfist/api\"\n}\n</code></pre> <p>The Shaken Fist command line clients, Ansible modules, and the Python API client will look for configuration in the following locations:</p> <ul> <li>environment variables.</li> <li><code>.shakenfist</code> in your home directory, that is <code>~/.shakenfist</code>.</li> <li><code>/etc/sf/shakenfist.json</code>.</li> </ul>"},{"location":"developer_guide/authentication/#creating-namespaces","title":"Creating namespaces","text":"<p>You can create your first namespace like this, assuming you are authenticated as the system namespace:</p> <pre><code>sf-client namespace create new-namespace\n</code></pre> <p>By default a new namespace has no access keys or trusts configured, and therefore is only accessible to users of the system namespace.</p>"},{"location":"developer_guide/authentication/#key-management","title":"Key management","text":"<p>Namespaces are accessed by providing a valid \"key\" for the namespace. While keys have names, they do not have to be usernames and passwords -- my mental model is more like API access tokens in something like GitHub than usernames and passwords. I tend to create a new key for each program which is interacting with the namespace, and then give it a descriptive name.</p> <p>You can create a new key like this:</p> <pre><code>sf-client namespace add-key namespace-name keyname key\n</code></pre> <p>There can be more than one key for a namespace. The key name is not used as part of the authentication process, and is largely used for key management (deleting the key) and logging which access token was used in the event logs.</p> Info <p>Please note the key prefix \"_service_key\" is reserved for internal use within Shaken Fist. This usage is discussed in the Inter-node Authentication section below.</p>"},{"location":"developer_guide/authentication/#authenticating-directly-to-the-rest-api","title":"Authenticating directly to the REST API","text":"<p>The authentication endpoint <code>/auth</code> is used to obtain a token to authenticate future API requests. For example, I can obtain an authentication token from the REST API using <code>curl</code> like this:</p> <pre><code>curl -X POST https://shakenfist/api/auth -d '{\"namespace\": \"system\", \"key\": \"oisoSe7T\"}'\n{\n    \"access_token\": \"eyJhbG...IkpXVCJ9.eyJmc...wwQ\",\n    \"token_type\": \"Bearer\",\n    \"expires_in\": 900\n}\n</code></pre> <p>That is, a HTTP POST request to the <code>/auth</code> endpoint for the REST API (in our case hosted at <code>https://shakenfist/api</code>) with a JSON body containing a dictionary of the namespace name and the key to use.</p> <p>In the response the <code>access_token</code> value of  <code>eyJhbG...IkpXVCJ9.eyJmc...wwQ</code> is our JWT token and has been truncated in this example for readability. Authentication tokens expire after a fixed period of time (nominally 15 minutes), but you will be informed that the token as expired by receiving a 401 Unauthorized response. If that occurs, simply create a new token as above and retry your request.</p> <p>Subsequent requests to the REST API pass the token via an <code>Authorization</code> HTTP header, and should request a <code>Content-Type</code> of <code>application/json</code>. For example, to list the namespaces in our deployment we would make a <code>curl</code> request like this:</p> <pre><code>curl -X GET https://shakenfist/api/auth/namespaces \\\n    -H 'Authorization: Bearer eyJhbG...IkpXVCJ9.eyJmc...wwQ' \\\n    -H 'Content-Type: application/json'\n[\n    {\n        \"name\": \"adhoc\",\n        \"state\": \"created\",\n        \"trust\": {\"full\": [\"system\"]}\n    }, {\n        \"name\": \"ci\",\n        \"state\": \"created\",\n        \"trust\": {\"full\": [\"system\"]}\n    }, {\n        \"name\": \"system\",\n        \"state\": \"created\",\n        \"trust\": {\"full\": [\"system\"]}\n    }\n]\n</code></pre> <p>The JSON response here has been formatted for readability.</p> Info <p>Note the word \"Bearer\" before the access token in the Authorization header.</p>"},{"location":"developer_guide/authentication/#contents-of-the-jwt-tokens","title":"Contents of the JWT tokens","text":"<p>JWT authentication tokens are base64 encoded parts separated by the <code>.</code> character. They are therefore trivial to decode. A decoded example (generated by the online decoder at https://jwt.io/) is:</p> <pre><code>{\n    \"alg\": \"HS256\",\n    \"typ\": \"JWT\"\n}\n.\n{\n    \"fresh\": false,\n    \"iat\": 1669786988,\n    \"jti\": \"906f4bfa-3218-4d07-a036-ac6b44ded67e\",\n    \"type\": \"access\",\n    \"sub\": [\n        \"system\",\n        \"deploy\"\n    ],\n    \"nbf\": 1669786988,\n    \"exp\": 1669787888,\n    \"iss\": \"shakenfist\",\n    \"nonce\": \"ByKNRUVBfMBoQC1Z\"\n}\n.\nHMACSHA256(\n    base64UrlEncode(header) + \".\" +\n    base64UrlEncode(payload),\n    your-256-bit-secret\n)\n</code></pre> <p>You can see here that Shaken Fist stores the authenticated namespace <code>system</code> and the key used to authenticate <code>deploy</code> under the <code>sub</code> key in this token. You should not assume that the content of JWT tokens produced by Shaken Fist are opaque to users.</p> <p>For releases prior to v0.7, the token was blindly trusted for authentication. From v0.7 we verify that the named key still exists in the namespace before authorizing API requests. This test is performed by updating a \"nonce\" value for a given key when the key is updated. The JWT token a caller is handed includes this nonce, and if the nonce we are handed on a request does not match the current value in the database the request is rejected.</p>"},{"location":"developer_guide/authentication/#inter-node-authentication","title":"Inter-node Authentication","text":"<p>Requests between Shaken Fist nodes use the same authentication system and REST API as external API requests. When a node makes an API request to another node, the originating node will create (or reuse) a \"service key\" specific to the namespace of the original request.</p> <p>When a request is made from the \"system\" namespace for a resource in a different namespace, the API request is made using the foreign namespace and the foreign namespace's service key.</p> <p>Service keys exist in the namespace's key data structures just as other keys do, and are therefore visible when you list keys. As of v0.7, service keys expire after five minutes, and are never reused. Before v0.7 service keys were always named \"_service_key\". From v0.7 service keys have a name of the form \"_service_key[a-zA-Z]+\".</p>"},{"location":"developer_guide/authentication/#key-storage","title":"Key Storage","text":"<p>Shaken Fist stores the access keys in <code>etcd</code>. The keys are stored as the base64 encoding of the key post salting and hashing. The python <code>bcrypt</code> library is used to perform salting, hashing, and key verification.</p>"},{"location":"developer_guide/ci_api_coverage/","title":"CI API Coverage","text":"<p>This document tracks the CI coverage for each of our public APIs. The intent to make it clear what is \"sufficiently tested\", and what needs further effort. This list is manually updated, so we'll need to show discipline in ensuring that we update it as we change APIs or CI.</p> <p>For this document we use the python API client as a model of what to cover, as its simpler to extract a list of calls from than the API implementation itself. We list whether we have CI which calls the API directly, CI which uses the python command line client to call the API, or both. The gold standard is both.</p>"},{"location":"developer_guide/ci_api_coverage/#get_instances","title":"get_instances","text":"<p>Whilst being implied by every test tearDown(), this call is explicitly used in:</p> <ul> <li>TestCirros.test_cirros_boot_no_network</li> <li>TestCirros.test_cirros_boot_network</li> <li>TestPlacement.test_local_placement_works</li> <li>TestPlacement.test_remote_placement_works</li> <li>TestSystemNamespace.test_system_namespace</li> <li>TestUbuntu.test_ubuntu_pings</li> </ul>"},{"location":"developer_guide/ci_api_coverage/#delete_all_instances","title":"delete_all_instances","text":"<p>Not tested.</p>"},{"location":"developer_guide/ci_api_coverage/#get_instance","title":"get_instance","text":"<p>All callers of await_instance_event call get_instance(). However, these more explicit tests exist as well:</p> <ul> <li>TestCacheImage.test_instance_invalid_image</li> </ul>"},{"location":"developer_guide/ci_api_coverage/#get_instance_interfaces","title":"get_instance_interfaces","text":"<ul> <li>TestMultipleNics.test_simple</li> <li>TestNetworking.test_virtual_networks_are_separate</li> <li>TestNetworking.test_overlapping_virtual_networks_are_separate</li> <li>TestNetworking.test_single_virtal_networks_work</li> <li>TestNetworking.test_specific_ip_request</li> <li>TestPlacement.test_local_placement_works</li> <li>TestPlacement.test_remote_placement_works</li> <li>TestStateChanges.test_lifecycle_events</li> <li>TestUbuntu.test_ubuntu_pings</li> </ul>"},{"location":"developer_guide/ci_api_coverage/#get_instance_metadata","title":"get_instance_metadata","text":"<ul> <li>TestInstanceMetadata.test_simple</li> </ul>"},{"location":"developer_guide/ci_api_coverage/#set_instance_metadata_item","title":"set_instance_metadata_item","text":"<ul> <li>TestInstanceMetadata.test_simple</li> </ul>"},{"location":"developer_guide/ci_api_coverage/#delete_instance_metadata_item","title":"delete_instance_metadata_item","text":"<p>Not tested.</p>"},{"location":"developer_guide/ci_api_coverage/#create_instance","title":"create_instance","text":"<p>Tested extensively in most other tests, so tests are not listed here.</p>"},{"location":"developer_guide/ci_api_coverage/#snapshot_instance","title":"snapshot_instance","text":"<ul> <li>TestSnapshots.test_single_disk_snapshots</li> <li>TestSnapshots.test_multiple_disk_snapshots</li> </ul>"},{"location":"developer_guide/ci_api_coverage/#get_instance_snapshots","title":"get_instance_snapshots","text":"<ul> <li>TestSnapshots.test_single_disk_snapshots</li> <li>TestSnapshots.test_multiple_disk_snapshots</li> </ul>"},{"location":"developer_guide/ci_api_coverage/#reboot_instance","title":"reboot_instance","text":"<ul> <li>TestStateChanges.test_lifecycle_events</li> </ul>"},{"location":"developer_guide/ci_api_coverage/#power_off_instance","title":"power_off_instance","text":"<ul> <li>TestStateChanges.test_lifecycle_events</li> </ul>"},{"location":"developer_guide/ci_api_coverage/#power_on_instance","title":"power_on_instance","text":"<ul> <li>TestStateChanges.test_lifecycle_events</li> </ul>"},{"location":"developer_guide/ci_api_coverage/#pause_instance","title":"pause_instance","text":"<ul> <li>TestStateChanges.test_lifecycle_events</li> </ul>"},{"location":"developer_guide/ci_api_coverage/#unpause_instance","title":"unpause_instance","text":"<ul> <li>TestStateChanges.test_lifecycle_events</li> </ul>"},{"location":"developer_guide/ci_api_coverage/#delete_instance","title":"delete_instance","text":"<p>Whilst being implied by every test tearDown(), this call is explicitly used in:</p> <ul> <li>TestCirros.test_cirros_boot_no_network</li> <li>TestCirros.test_cirros_boot_network</li> <li>TestPlacement.test_local_placement_works</li> <li>TestPlacement.test_remote_placement_works</li> <li>TestSnapshots.test_single_disk_snapshots</li> <li>TestSnapshots.test_multiple_disk_snapshots</li> <li>TestSystemNamespace.test_system_namespace</li> <li>TestUbuntu.test_ubuntu_pings</li> </ul>"},{"location":"developer_guide/ci_api_coverage/#get_instance_events","title":"get_instance_events","text":"<p>All callers of await_instance_event call get_instance(). However, more testing of this method is required.</p>"},{"location":"developer_guide/ci_api_coverage/#cache_image","title":"cache_image","text":"<ul> <li>TestImages.test_cache_image</li> </ul>"},{"location":"developer_guide/ci_api_coverage/#get_images","title":"get_images","text":"<p>(Formerly get_image_meta, old name to be removed in 0.5).</p> <ul> <li>TestImages.test_cache_image</li> </ul>"},{"location":"developer_guide/ci_api_coverage/#get_image_events","title":"get_image_events","text":"<p>Not tested.</p>"},{"location":"developer_guide/ci_api_coverage/#get_networks","title":"get_networks","text":"<p>Whilst being implied by every test tearDown(), this call is explicitly used in:</p> <ul> <li>TestSystemNamespace.test_system_namespace</li> </ul>"},{"location":"developer_guide/ci_api_coverage/#get_network","title":"get_network","text":"<p>Not tested.</p>"},{"location":"developer_guide/ci_api_coverage/#delete_network","title":"delete_network","text":"<p>Whilst being implied by every test tearDown(), this call is explicitly used in:</p> <ul> <li>TestSystemNamespace.test_system_namespace</li> </ul>"},{"location":"developer_guide/ci_api_coverage/#delete_all_networks","title":"delete_all_networks","text":"<p>Not tested.</p>"},{"location":"developer_guide/ci_api_coverage/#get_network_events","title":"get_network_events","text":"<p>Not tested.</p>"},{"location":"developer_guide/ci_api_coverage/#allocate_network","title":"allocate_network","text":"<p>Tested extensively in most other tests, so tests are not listed here.</p>"},{"location":"developer_guide/ci_api_coverage/#get_network_interfaces","title":"get_network_interfaces","text":"<p>Not tested.</p>"},{"location":"developer_guide/ci_api_coverage/#get_network_metadata","title":"get_network_metadata","text":"<p>Not tested.</p>"},{"location":"developer_guide/ci_api_coverage/#set_network_metadata_item","title":"set_network_metadata_item","text":"<p>Not tested.</p>"},{"location":"developer_guide/ci_api_coverage/#delete_network_metadata_item","title":"delete_network_metadata_item","text":"<p>Not tested.</p>"},{"location":"developer_guide/ci_api_coverage/#get_nodes","title":"get_nodes","text":"<p>Not tested.</p>"},{"location":"developer_guide/ci_api_coverage/#get_interface","title":"get_interface","text":"<p>Not tested.</p>"},{"location":"developer_guide/ci_api_coverage/#float_interface","title":"float_interface","text":"<p>Not tested.</p>"},{"location":"developer_guide/ci_api_coverage/#defloat_interface","title":"defloat_interface","text":"<p>Not tested.</p>"},{"location":"developer_guide/ci_api_coverage/#get_console_data","title":"get_console_data","text":"<ul> <li>TestConsoleLog.test_console_log</li> </ul>"},{"location":"developer_guide/ci_api_coverage/#get_namespaces","title":"get_namespaces","text":"<p>As well as being tested as a side effect of most other tests, there is the following explicit test:</p> <ul> <li>TestAuth.test_namespaces</li> </ul>"},{"location":"developer_guide/ci_api_coverage/#create_namespace","title":"create_namespace","text":"<p>As well as being tested as a side effect of most other tests, there is the following explicit test:</p> <ul> <li>TestAuth.test_namespaces</li> </ul>"},{"location":"developer_guide/ci_api_coverage/#delete_namespace","title":"delete_namespace","text":"<p>As well as being tested as a side effect of most other tests, there is the following explicit test:</p> <ul> <li>TestAuth.test_namespaces</li> </ul>"},{"location":"developer_guide/ci_api_coverage/#get_namespace_keynames","title":"get_namespace_keynames","text":"<p>Not tested.</p>"},{"location":"developer_guide/ci_api_coverage/#add_namespace_key","title":"add_namespace_key","text":"<ul> <li>TestAuth.test_namespaces</li> </ul>"},{"location":"developer_guide/ci_api_coverage/#delete_namespace_key","title":"delete_namespace_key","text":"<ul> <li>TestAuth.test_namespaces</li> </ul>"},{"location":"developer_guide/ci_api_coverage/#get_namespace_metadata","title":"get_namespace_metadata","text":"<p>Not tested.</p>"},{"location":"developer_guide/ci_api_coverage/#set_namespace_metadata_item","title":"set_namespace_metadata_item","text":"<p>Not tested.</p>"},{"location":"developer_guide/ci_api_coverage/#delete_namespace_metadata_item","title":"delete_namespace_metadata_item","text":"<p>Not tested.</p>"},{"location":"developer_guide/ci_api_coverage/#get_existing_locks","title":"get_existing_locks","text":"<p>Not tested.</p>"},{"location":"developer_guide/ci_api_coverage/#ping","title":"ping","text":"<p>Tested as a side effect of many other tests, but no explicit test.</p>"},{"location":"developer_guide/io_performance_tuning/","title":"IO performance tuning","text":"<p>This page documents experiments in tuning the IO performance of Shaken Fist. It explains how we've ended up with the options we use, and what other options we considered along the way. qemu has quite a helpful guide to performance options for IO tuning at https://git.qemu.org/?p=qemu.git;a=blob;f=docs/qcow2-cache.txt , but it does not provide concrete recommendations.</p>"},{"location":"developer_guide/io_performance_tuning/#before-tuning","title":"Before tuning","text":"<p>First off, here are some base line performance numbers before we did any tuning. All performance tests were on a Samsung Pro 980 with libvirt / kvm / qemu. All disks were a 100GB copy on write layer on top of a 30 GB virtual backing file, on an otherwise idle machine. The virtual machine had 16 vCPU and 32 GB RAM.</p> <p>In the interests of the comparisons below, the untuned cluster uses writethrough caching and a cluster size of 64K:</p> <pre><code>dd if=/dev/zero of=test1.img bs=1G count=50 oflag=dsync\n</code></pre> <p>All numbers are the first run (incurs new cluster allocation cost, see later in this document), and then the average of the fastest three of five subsequent runs.</p> <ul> <li>Raw NVMe disk: 1,229 MB/s</li> <li>Before tuning: 611 MB/s, 655 MB/s (689, 589, 524, 572, 689)</li> </ul> <pre><code>hdparm -Tt /dev/vda1\n</code></pre> <p>I have only recorded the buffered disk read value, as the other value is based on caching. I've used the same average of the fastest three from a run of five that I did above:</p> <ul> <li>Raw NVMe disk: 2,572 MB/s</li> <li>Before tuning: 1,283 MB/s (695.13, 967.22, 1142.13, 1310.75, 1396.96)</li> </ul> <p>Note that all experiments below are based on a single change compared to the starting state. So for example the cluster size change experiment used the default caching of writethrough.</p>"},{"location":"developer_guide/io_performance_tuning/#disk-cache-mode","title":"Disk cache mode","text":"<p>qemu supports a variety of disk caching modes for disks. https://documentation.suse.com/sles/11-SP4/html/SLES-kvm4zseries/cha-qemu-cachemodes.html is a good summary of the options, which are all exposed by libvirt. Modern libvirts default to writeback, which is equivalent to using a battery backed RAID controller in a physical machine. It therefore does assume a similar level of reliability from your hypervisor nodes.</p> <p>Within libvirt, the caching is specified using the cache attribute to the driver element. The libvirt documentation states:</p> <p>The optional cache attribute controls the cache mechanism, possible values are \"default\", \"none\", \"writethrough\", \"writeback\", \"directsync\" (like \"writethrough\", but it bypasses the host page cache) and \"unsafe\" (host may cache all disk io, and sync requests from guest are ignored). Since 0.6.0, \"directsync\" since 0.9.5, \"unsafe\" since 0.9.7.</p> <p>So for the libvirt.tmpl domain XML template within Shaken Fist, specifying a writethrough as a caching mode would look like this:</p> <pre><code>{%- for disk in disks %}\n{%- if disk.bus != 'nvme' %}\n&lt;disk type='{{disk.source_type}}' device='{{disk.present_as}}'&gt;\n  &lt;driver name='qemu' type='{{disk.type}}' cache='writethrough'/&gt;\n  {{disk.source}}\n  {{disk.backing}}\n  &lt;target dev='{{disk.device}}' bus='{{disk.bus}}'/&gt;\n&lt;/disk&gt;\n{%- endif %}\n{%- endfor %}\n</code></pre> <p>Some performance numbers:</p> <pre><code>dd if=/dev/zero of=test1.img bs=1G count=50 oflag=dsync\n</code></pre> <p>All numbers are the first run (incurs new cluster allocation cost, see later in this document), and then the average of the fastest three of five subsequent runs.</p> <ul> <li>Raw NVMe disk: 1,229 MB/s</li> <li>Cache none: 958 MB/s, 987 MB/s (948, 991, 1024, 866, 837)</li> <li>Cache writethrough: 499 MB/s, 656 MB/s (577, 735, 637, 596, 574)</li> <li>Cache writeback: 606 MB/s, 677 MB/s (686, 721, 589, 568, 625)</li> <li>Cache directsync: 626 MB/s, 823 MB/s (676, 938, 760, 771, 727)</li> <li>Cache unsafe: 857 MB/s, 1,012 MB/s (963, 1126, 948, 859, 840)</li> </ul> <pre><code>hdparm -Tt /dev/vda1\n</code></pre> <p>I have only recorded the buffered disk read value, as the other value is based on caching. I've used the same average of the fastest three from a run of five that I did above:</p> <ul> <li>Raw NVMe disk: 2,572 MB/s</li> <li>Cache none: 849 MB/s (535.09, 712.36, 791.02, 859.13, 899.20)</li> <li>Cache writethrough: 1,352 MB/s (598.37, 927.03, 1237.42, 1300.84, 1519.23)</li> <li>Cache writeback: 1,589.12 MB/s (756.97, 1244.58, 1433.67, 1639.21, 1694.48)</li> <li>Cache directsync: 1,038.69 MB/s (914.48, 1031.09, 1065.92, 755.77, 1019.06)</li> <li>Cache unsafe: 1,272 MB/s (656.32, 944.18, 1122.15, 1270.44, 1424.00)</li> </ul> <p>What cache modes a safe in terms of data integrity? This is what https://documentation.suse.com/sles/11-SP4/html/SLES-kvm4zseries/cha-qemu-cachemodes.html has to say:</p> <p>cache = writethrough, cache = none, cache=directsync: These are the safest modes, and considered equally safe, given that the guest operating system is \u201cmodern and well behaved\u201d, which means that it uses flushes as needed. If you have a suspect guest, use writethough, or directsync. Note that some file systems are not compatible with cache=none or cache=directsync, as they do not support O_DIRECT, which these cache modes relies on.</p> <p>Specifically, I don't think that Shaken Fist should use any unsafe caching mode, which eliminates the aptly named unsafe as an option.</p> <p>Recommendation: we should convert to using cache mode \"none\" for instances. It provides slower read performance, but much better write performance.</p>"},{"location":"developer_guide/io_performance_tuning/#cluster-size","title":"Cluster size","text":"<p>qcow2 defaults to a cluster size of 64KB, and the maximum is 2MB. The value must be a power of two. The balance here is that the cluster size is the unit of allocation of disk when the disk needs to grow -- so a large cluster size will cause an image to grow larger than it might otherwise, but 2MB doesn't seem like a large overhead. However, if you are using a copy on write layer and change one byte of a fully allocated cluster, a 2MB cluster size means that 2MB must be read from the backing file, the byte changed, and then that 2MB written to the copy on write layer. That IO cost can add up depending on your workload.</p> <p>https://www.ibm.com/cloud/blog/how-to-tune-qemu-l2-cache-size-and-qcow2-cluster-size has a good description of how the cluster size affects cache behaviour with qcow2, as a larger cluster size also implies that you're more likely to have in-memory cache hits and avoid extra IO operations looking up caches from disk. In the worst case, a single IO can incur the actual IO operations if the cache entries required are not currently in memory.</p> <p>Pleasingly, cluster size is an attribute of the qcow2 file, not the hypervisor configuration. This makes it easy for us to run benchmarks against without having to tweak the hypervisor too much.</p> <p>You tune cluster size like this:</p> <pre><code>qemu-img create -f qcow2 -o cluster_size=2M foo.qcow2 100G\n</code></pre> <p>First off, the backing image size changes as I change the cluster size. Remember that in a hypervisor environment where the backing image is shared between VMs, the cost of increased size here is reduced by the multiple users of th backing image.</p> <p>It should be noted that you can have a different cluster size in the copy on write layer compared to the backing image, but I have not tested that as I want to keep the number of permutations here manageable.</p> <p>Some performance numbers, noting that performance will vary based on the size of the disk -- that is, very large disks would benefit from higher cluster sizes. I have selected what I think is a representative size for a Shaken Fist instance in these test runs:</p> <pre><code>qemu-img convert -p -O qcow2 -o cluster_size=256K old.qcow2 new.qcow2\n</code></pre> <ul> <li>Cluster size 64 K: 672 MB</li> <li>Cluster size 128 K: 1.7 GB</li> <li>Cluster size 256 K: 1.7 GB</li> <li>Cluster size 512 K: 1.7 GB</li> <li>Cluster size 1,024 K: 1.7 GB</li> <li>Cluster size 2,048 K: 1.8 GB</li> </ul> <pre><code>dd if=/dev/zero of=test1.img bs=1G count=50 oflag=dsync\n</code></pre> <p>All numbers are the first run (incurs new cluster allocation cost), and then the average of the fastest three of five subsequent runs.</p> <ul> <li>Raw NVMe disk: 1,229 MB/s</li> <li>Cluster size 64 K: 611 MB/s, 655 MB/s (689, 589, 524, 572, 689)</li> <li>Cluster size 128 K: 631 MB/s, 654 MB/s (465, 701, 594, 531, 666)</li> <li>Cluster size 256 K: 630 MB/s, 651 MB/s (708, 667, 580, 539, 574)</li> <li>Cluster size 512 K: 630 MB/s, 643 MB/s (666, 680, 531, 584, 560)</li> <li>Cluster size 1,024 K: 632 MB/s, 631 MB/s (734, 605, 520, 555, 541)</li> <li>Cluster size 2,048 K: 648 MB/s, 704 MB/s (732, 731, 650, 559, 558)</li> </ul> <pre><code>hdparm -Tt /dev/vda1\n</code></pre> <p>I have only recorded the buffered disk read value, as the other value is based on caching. I've used the same average of the fastest three from a run of five that I did above:</p> <ul> <li>Raw NVMe disk: 2,572 MB/s</li> <li>Cluster size 64 K: 1,283 MB/s (695.13, 967.22, 1142.13, 1310.75, 1396.96)</li> <li>Cluster size 128 K: 2,742 MB/s (2618.60, 3080.81, 2500.19, 2526.23, 1740.01)</li> <li>Cluster size 256 K: 3,378 MB/s (1286.86, 2167.27, 2903.52, 3399.29, 3830.55)</li> <li>Cluster size 512 K: 2,575 MB/s (1011.34, 1543.60, 2126.33, 2605.66, 2992.87)</li> <li>Cluster size 1,024 K: 2,631 MB/s (2279.93, 2329.68, 2229.67, 2622.82, 2940.58)</li> <li>Cluster size 2,048 K: 2,402 MB/s (899.56, 1517.90, 1992.42, 2447.05, 2767.72)</li> </ul> <p>Recommendation: a cluster size of 2,048K will use marginally more RAM to store the caches, but improves disk performance significantly, especially for reads.</p>"},{"location":"developer_guide/io_performance_tuning/#final-performance","title":"Final performance","text":"<p>In the interests of gloating, here are our original performance numbers, compared to after tuning:</p> <pre><code>dd if=/dev/zero of=test1.img bs=1G count=50 oflag=dsync\n</code></pre> <p>All numbers are the first run (incurs new cluster allocation cost, see later in this document), and then the average of the fastest three of five subsequent runs.</p> <ul> <li>Raw NVMe disk: 1,229 MB/s</li> <li>Before tuning: 611 MB/s, 655 MB/s (689, 589, 524, 572, 689)</li> <li>After tuning: 992 MB/s, 991 MB/s (958, 1024, 906, 869, 838)</li> </ul> <pre><code>hdparm -Tt /dev/vda1\n</code></pre> <p>I've used the same average of the fastest three from a run of five that I did above:</p> <ul> <li>Raw NVMe disk: 2,572 MB/s</li> <li>Before tuning: 1,283 MB/s (695.13, 967.22, 1142.13, 1310.75, 1396.96)</li> <li>After tuning: 1,560 MB/s (717.71, 1120.44, 1394.56, 1516.47, 1770.01)</li> </ul>"},{"location":"developer_guide/release_process/","title":"Shaken Fist's release process","text":"<p>Shaken Fist is now split across a number of repositories to simplify development and usage. Unfortunately, that complicated the release process. This page documents the current release process although the reality is that only Michael can do a release right now because of the requirement to sign releases with his GPG key.</p>"},{"location":"developer_guide/release_process/#testing","title":"Testing","text":"<p>We only release things which have passed CI testing, and preferably have had a period running as the underlying cloud for the CI cluster as well. Sometimes in an emergency we will bend the rules for a hotfix, but we should try and avoid doing that.</p>"},{"location":"developer_guide/release_process/#for-reach-repository-to-be-released","title":"For reach repository to be released","text":"<p>Checkout the repository and ensure you're in the right branch. Then just run <code>release.sh</code> and follow the bounching ball.</p>"},{"location":"developer_guide/standards/","title":"Concepts and Standards","text":""},{"location":"developer_guide/standards/#ensuring-a-common-language-within-the-code-base","title":"Ensuring a Common Language within the code base","text":"<p>This document records the standards and common language used within the Shaken Fist software system.</p> <p>It should also record why the choice was made.</p> <p>(This is actually just notes to save our future selves from tripping over the same problems.)</p>"},{"location":"developer_guide/standards/#etcd-keys","title":"etcd keys","text":"<p>Key names in <code>etcd</code> should be in the singular, for example <code>/sf/namespace/</code> not <code>/sf/namespaces/</code> note that this is different than the REST API.</p>"},{"location":"developer_guide/standards/#memory","title":"Memory","text":"<p>Memory is measured in MiB in Shaken Fist. All references to memory size are stored and transmitted in MiB: Gigabytes can be too big if you want a lot of small machines. Kilobytes is just too many numbers to type. The <code>libvirt</code> API measures memory in KiB. Therefore, interactions with the library need to be careful to convert from MiB to KiB.</p>"},{"location":"developer_guide/state_machine/","title":"Shaken Fist's State Machine","text":"<p>Shaken Fist implements a state machine for each object type. This page documents the possible states for each object, and which transitions between states are valid.</p> <p>Shaken Fist rigidly enforces the state model defined for each object, and will raise an exception if an unexpected transition occurs. The state model for a given object is defined in the <code>state_targets</code> map in the object class for those keen on reading code.</p> <p>Objects marked as <code>deleted</code> are removed from etcd after sitting deleted for some period of time. This is called a \"hard deletion\" and the period of time is configured with the CLEANER_DELAY configuration option. Once an object is hard deleted it will no longer appear in any API request, as it no longer exists in the database. The exception is that it will still appear in relevant events that have not yet aged out.</p>"},{"location":"developer_guide/state_machine/#agent-operations","title":"Agent Operations","text":"<ul> <li><code>initial</code>: the first state for an agent operation. A UUID has been allocated,   and a placeholder database entry created.</li> <li><code>preflight</code>: some agent operations require additional queued steps such as   fetching <code>blob</code>s to the correct <code>node</code>. These operations will be in <code>preflight</code>   during this background work.</li> <li><code>queued</code>: awaiting execution on the <code>instance</code>.</li> <li><code>executing</code>: means the Agent Operation is now executing on the <code>instance</code>.</li> <li><code>complete</code>: the Agent Operation has finished executing on the <code>instance</code>.   Specifically, this means we have received a result from the agent for each   command. If the agent crashes or a command never returns, this means the Agent   Operation will never be marked as complete.</li> <li><code>deleted</code>: the Agent Operation has been deleted.</li> <li><code>error</code>: an error occurred while processing the Agent Operation.</li> </ul> <p>The following transitions are possible:</p> <pre><code>stateDiagram-v2\n  [*] --&gt; initial\n  [*] --&gt; error\n\n  initial --&gt; preflight\n  initial --&gt; queued\n  initial --&gt; deleted\n  initial --&gt; error\n\n  preflight --&gt; queued\n  preflight --&gt; deleted\n  preflight --&gt; error\n\n  queued --&gt; executing\n  queued --&gt; deleted\n  queued --&gt; error\n\n  executing --&gt; complete\n  executing --&gt; deleted\n  executing --&gt; error\n\n  complete --&gt; deleted\n\n  error --&gt; deleted\n\n  deleted --&gt; [*]</code></pre>"},{"location":"developer_guide/state_machine/#artifacts","title":"Artifacts","text":"<ul> <li><code>initial</code>: the first state for an artifact. A UUID has been allocated,   and a placeholder database entry created.</li> <li><code>created</code>: the artifact has at least one version.</li> <li><code>deleted</code>: the artifact has been deleted.</li> <li><code>error</code>: the artifact is in an error state.</li> </ul> <p>The following transitions are possible:</p> <pre><code>stateDiagram-v2\n  [*] --&gt; initial\n\n  initial --&gt; created\n  initial --&gt; deleted\n  initial --&gt; error\n\n  created --&gt; deleted\n  created --&gt; error\n\n  error --&gt; deleted\n\n  deleted --&gt; [*]</code></pre>"},{"location":"developer_guide/state_machine/#blobs","title":"Blobs","text":"<ul> <li><code>initial</code>: the first state for an blob. A UUID has been allocated,   and a placeholder database entry created.</li> <li><code>created</code>: the blob has data associated with it.</li> <li><code>deleted</code>: the blob has been deleted.</li> <li><code>error</code>: the blob is in an error state.</li> </ul> <p>The following transitions are possible:</p> <pre><code>stateDiagram-v2\n  [*] --&gt; initial\n\n  initial --&gt; created\n  initial --&gt; deleted\n  initial --&gt; error\n\n  created --&gt; deleted\n  created --&gt; error\n\n  error --&gt; deleted\n\n  deleted --&gt; [*]</code></pre>"},{"location":"developer_guide/state_machine/#instances","title":"Instances","text":"<ul> <li><code>initial</code>: this is the first state for an instance. A UUID has been allocated,   a placeholder database entry created, and a request to create the instance has   been queued.</li> <li><code>preflight</code>: the instance creation request has been dequeued and is being   validated against the current state of the cluster by the scheduler. At this   point any required resources (transfers of blobs inside the cluster and   fetching of images from outside the cluster) also occurs.</li> <li><code>creating</code>: the instance is being created on the <code>node</code>.</li> <li><code>created</code>: the instance is now running.</li> <li><code>deleted</code>: the instance is now deleted.</li> <li><code>error</code>: the instance is unable to be used.</li> </ul> <p>Any instance may enter the <code>error</code> state, which happens when something bad has happened. That process involves the instance being moved to a transition state named for the instance's previous state, so for example an instance which was <code>created</code> that went into Error would transition through <code>created-error</code>. This is done because the <code>error</code> transition is a queue job and happens sometime later. Instances in the <code>error</code> state are not removed like those in the <code>deleted</code> state, as we assume a caller must acknowledge an error occurred. To remove them, delete the instance in <code>error</code> state.</p> <p>The following transitions are possible (note that hyphens have been replaced with underscores in some state names due to limitations in the diagram renderer):</p> <pre><code>stateDiagram-v2\n  [*] --&gt; initial\n  [*] --&gt; error\n\n  initial --&gt; preflight\n  initial --&gt; delete_wait\n  initial --&gt; deleted\n  initial --&gt; initial_error\n\n  preflight --&gt; creating\n  preflight --&gt; delete_wait\n  preflight --&gt; deleted\n  preflight --&gt; preflight_error\n\n  creating --&gt; created\n  creating --&gt; delete_wait\n  creating --&gt; deleted\n  creating --&gt; creating_error\n\n  created --&gt; delete_wait\n  created --&gt; deleted\n  created --&gt; created_error\n\n  initial_error --&gt; error\n  preflight_error --&gt; error\n  creating_error --&gt; error\n  created_error --&gt; error\n  delete_wait_error --&gt; error\n\n  error --&gt; delete_wait\n  error --&gt; deleted\n\n  delete_wait --&gt; deleted\n  delete_wait --&gt; delete_wait_error\n\n  deleted --&gt; [*]</code></pre>"},{"location":"developer_guide/state_machine/#namespaces","title":"Namespaces","text":"<ul> <li><code>created</code>: the namespace exists.</li> <li><code>deleted</code>: the namespace has been deleted.</li> </ul> <p>The following transitions are possible:</p> <pre><code>stateDiagram-v2\n  [*] --&gt; created\n  created --&gt; deleted\n  deleted --&gt; [*]</code></pre>"},{"location":"developer_guide/state_machine/#networks","title":"Networks","text":"<ul> <li><code>initial</code>: first state for a network. A UUID has been allocated, database entry   created, and a request to create the network on the <code>networknode</code> has been queued.</li> <li><code>created</code>: the network has been created on the <code>networknode</code>.</li> <li><code>delete-wait</code>: the network has been scheduled for deletion. Waiting for   instances on the network to be deleted.</li> <li><code>deleted</code>: the network is now deleted.</li> <li><code>error</code>: the network has encountered an error and cannot be used.</li> </ul> <p>A network is regarded as \"dead\" when it is in state <code>deleted</code>, <code>delete-wait</code> or <code>error</code>.</p> <p>The following transitions are possible (note that hyphens have been replaced with underscores in some state names due to limitations in the diagram renderer):</p> <pre><code>stateDiagram-v2\n  [*] --&gt; initial\n\n  initial --&gt; created\n  initial --&gt; deleted\n  initial --&gt; error\n\n  created --&gt; deleted\n  created --&gt; delete_wait\n  created --&gt; error\n\n  delete_wait --&gt; deleted\n  delete_wait --&gt; error\n\n  error --&gt; deleted\n\n  deleted --&gt; [*]</code></pre>"},{"location":"developer_guide/state_machine/#network-interfaces","title":"Network Interfaces","text":"<ul> <li><code>initial</code>: the first state for a network interface. A UUID has been allocated,   and a placeholder database entry created.</li> <li><code>created</code>: the network interface has data associated with it.</li> <li><code>deleted</code>: the network interface has been deleted.</li> <li><code>error</code>: the network interface is in an error state.</li> </ul> <p>The following transitions are possible:</p> <pre><code>stateDiagram-v2\n  [*] --&gt; initial\n\n  initial --&gt; created\n  initial --&gt; deleted\n  initial --&gt; error\n\n  created --&gt; deleted\n  created --&gt; error\n\n  error --&gt; deleted\n\n  deleted --&gt; [*]</code></pre>"},{"location":"developer_guide/state_machine/#nodes","title":"Nodes","text":"<ul> <li><code>created</code>: on first check in, a node is created in the \"created\" state.</li> <li><code>stopping</code>: the node is gracefully shutting down.</li> <li><code>stopped</code>: the node has gracefully shut down.</li> <li><code>deleted</code>: the node was manually evacuated and removed. Note that the <code>node</code>   object is the only object type to never hard delete, although a <code>node</code> cannot   be undeleted.</li> <li><code>missing</code>: the node has not checked in within the NODE_CHECKIN_MAXIMUM deadline.</li> <li><code>error</code>: the node has not check in for ten times NODE_CHECKIN_MAXIMUM, and all   instances on this node have been declared to be in an error state. The <code>node</code>   object is the only object which can return from an <code>error</code> state to other states.</li> </ul> <p>The following transitions are possible:</p> <pre><code>stateDiagram-v2\n  [*] --&gt; created\n  [*] --&gt; error\n  [*] --&gt; missing\n\n  created --&gt; deleted\n  created --&gt; error\n  created --&gt; missing\n  created --&gt; stopping\n\n  stopping --&gt; stopped\n  stopping --&gt; deleted\n  stopping --&gt; error\n  stopping --&gt; created\n\n  stopped --&gt; created\n  stopped --&gt; deleted\n  stopped --&gt; error\n\n  error --&gt; created\n  error --&gt; deleted\n\n  missing --&gt; created\n  missing --&gt; deleted\n  missing --&gt; error</code></pre>"},{"location":"developer_guide/state_machine/#upload","title":"Upload","text":"<ul> <li><code>created</code>: the upload has data associated with it.</li> <li><code>deleted</code>: the network interface has been deleted.</li> </ul> <p>The following transitions are possible:</p> <pre><code>stateDiagram-v2\n  [*] --&gt; created\n  created --&gt; deleted\n  deleted --&gt; [*]</code></pre>"},{"location":"developer_guide/updating_docs/","title":"Updating These Docs","text":"<p>Built using MkDocs: https://www.mkdocs.org/ Theme: https://squidfunk.github.io/mkdocs-material/customization/ </p>"},{"location":"developer_guide/updating_docs/#setup","title":"Setup","text":"<p>Install mkdocs and the material theme  <pre><code>pip install mkdocs-material\n</code></pre></p>"},{"location":"developer_guide/updating_docs/#viewing-locally","title":"Viewing Locally","text":"<p>Start the live web-server with <pre><code>mkdocs serve\n</code></pre> View at http://localhost:8000</p>"},{"location":"developer_guide/updating_docs/#deploying-to-github-pages","title":"Deploying to GitHub Pages","text":"<p>Build and deploy with <pre><code>mkdocs gh-deploy\n</code></pre> This will push to the <code>gh-pages</code> branch of the current git remote.</p>"},{"location":"developer_guide/updating_docs/#navigation-bar","title":"Navigation Bar","text":"<p>The navigation bar is configured via the <code>mkdocs.yml</code> file in the repository root.</p>"},{"location":"developer_guide/workflow/","title":"Development Workflow","text":""},{"location":"developer_guide/workflow/#short-lesson","title":"Short Lesson","text":"<p>The majority of teams using git have a work flow that looks similar to the four well known work flows:</p> <ul> <li>Git Flow</li> <li>GitHub Flow</li> <li>GitLab Flow</li> <li>Trunk Based Development</li> </ul>"},{"location":"developer_guide/workflow/#git-development-the-shaken-fist-way","title":"Git Development - the Shaken Fist Way","text":"<p>The Shaken Fist developers have chosen Trunk Based Development with some minor tweaks.</p>"},{"location":"developer_guide/workflow/#branch-types","title":"Branch Types","text":"<ol> <li> <p>Branch <code>develop</code></p> <ul> <li>This is the development trunk and has largely replaced <code>master</code> in most of our respositories.</li> <li>All <code>feature</code> branches are branched from <code>develop</code> and merged to <code>develop</code>.</li> <li>New releases are cut from the <code>develop</code> branch when we decide its time to bump the major release number.</li> <li>The <code>develop</code> branch has automated nightly CI tests, and failures create GitHub issues which must be regularly triaged. That is, CI failures on <code>develop</code> are exceptional and should not be accepted as flakey tests or \"situation normal\". CI failures are labelled as <code>ci-failure</code> in GitHub issues.</li> </ul> </li> <li> <p>Feature branches</p> <ul> <li>Short-lived, generally a few days although sometimes much longer for complicated things.</li> <li>Normally only one developer.</li> <li>When presented to the team, it is expected to pass the linter, unit tests, and CI tests.</li> <li>It is normal that other team members suggest changes / improvements before merging.</li> </ul> </li> <li> <p>Branches <code>vX.X-release</code></p> <ul> <li>Created from <code>develop</code> when a new major release is first cut. Patches and minor releases for that major version are then cut from this branch.</li> <li>Commits to this branch are cherry-picks from <code>develop</code> except in exceptional circumstances (for example the code to be changed no longer existing on <code>develop</code>).</li> <li>It is not expected that many commits are made to this branch.</li> <li>If many commits are required to a release branch then this indicates the need for another release.</li> <li>\"Recent\" release branches has automated nightly CI tests, and failures create GitHub issues which must be regularly triaged. That is, CI failures on recent releases are exceptional and should not be accepted as flakey tests or \"situation normal\". CI failures are labelled as <code>ci-failure</code> in GitHub issues. For now, this is treated as all releases from v0.6 onwards, although that will likely change at some point.</li> </ul> </li> </ol>"},{"location":"developer_guide/workflow/#process","title":"Process","text":""},{"location":"developer_guide/workflow/#bug-fix-branches","title":"Bug fix branches","text":"<ul> <li>Bug fix branches have a prefix consisting of the GitHub issue number and the word \"bug\", for example \"bug-XXX\".</li> <li>You commit should include the text <code>Fixes #XXX</code> where XXX is the GitHub issue number for the bug. It is possible to fix more than one GitHub issue in a single commit.</li> </ul>"},{"location":"developer_guide/workflow/#feature-branches","title":"Feature branches","text":"<ul> <li>Feature branches should be named \"feature-branch-XXX\" where XXX is a short description of the feature.</li> <li>The feature branch developers should squash commits to remove WIP commits before creating a Pull Request, but it is acceptable to have a series of incremental changes building up to a complete feature in the feature branch at merge time.</li> <li>It is preferable that each remaining commit passes unit testing and CI, but the final state that is merged must pass unit tests and CI.</li> </ul>"},{"location":"developer_guide/workflow/#merging","title":"Merging","text":"<ul> <li>Commits are not squashed when merged to <code>develop</code>.</li> <li>Not squashing commits maintains history of multiple issues being solved.</li> <li>Pull Request related commits remain grouped and can be understood as a single merge</li> </ul>"},{"location":"developer_guide/workflow/#minimal-backports","title":"Minimal backports","text":"<p>Only necessary bug fixes are cherry-picked from <code>master</code> to an existing release branch.</p>"},{"location":"developer_guide/api_reference/admin/","title":"Admin (/admin/)","text":""},{"location":"developer_guide/api_reference/admin/#locks","title":"Locks","text":"<p>As discussed in the operator guide, you can query what locks exist in a Shaken Fist cluster, as well as who is currently holding those locks (machine and process id).</p> REST API calls <ul> <li>GET /admin/locks: List locks currently held in the cluster.</li> </ul> Python API client: list cluster locks <pre><code>from shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nlocks = sf_client.get_existing_locks()\n\nprint('lock,pid,node,operation')\nfor ref, meta in locks.items():\n    print('%s,%s,%s,%s' % (ref, meta['pid'], meta['node'], meta.get('operation')))\n</code></pre> <pre><code>$ python3 example.py\nlock,pid,node,operation\n/sflocks/sf/network/d2950d74-50c7-4790-a985-c43d9eb9bad9,2834066,sf-3,Network ensure mesh\n</code></pre>"},{"location":"developer_guide/api_reference/agentoperations/","title":"Agent Operations (/agentoperations/)","text":"<p>Since v0.7, when an instance is running the Shaken Fist agent, you can queue agent operations to run on that instance. These operations consist of a series of commands which are executed in return, with results for each being gathered as they execute. In general the API for agent operations is instance-centric -- you lookup the agent operations an instance has seen, and then can request further information about the agent operation directly. There is currently no way to search for an agent operation outside the context of its parent instance.</p> <p>For information on how to create an agent operation for an instance, refer to the instances API documentation on creating agent operations. For information on how to list the agent operations for a given instance, refer to the instances API documentation on listing agent operations.</p> REST API calls <ul> <li>GET /agentoperations/{operation_uuid}: Lookup a specific agent operation.</li> <li>DELETE /agentoperations/{operation_uuid}: Delete a specific agent operation.</li> </ul> Python API client: lookup an agent operation by uuid <pre><code>import json\nfrom shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nagentop = sf_client.get_agent_operation('5a00d6f3-19b6-42bc-b1df-ddc4e5a299e9')\nprint(json.dumps(agentop, indent=4, sort_keys=True))\n</code></pre> <p>Which returns something like:</p> <pre><code>{\n\"commands\": [\n{\n\"block-for-result\": true,\n\"command\": \"execute\",\n\"commandline\": \"cat /tmp/README.md\"\n}\n],\n\"instance_uuid\": \"a771fb13-aaad-4cb6-a86b-7ee51e7bacc6\",\n\"metadata\": {},\n\"namespace\": \"vdi\",\n\"results\": {\n\"0\": {\n\"command-line\": \"cat /tmp/README.md\",\n\"result\": true,\n\"return-code\": 0,\n\"stderr\": \"\",\n\"stdout\": \"...\"\n}\n},\n\"state\": \"complete\",\n\"uuid\": \"5a00d6f3-19b6-42bc-b1df-ddc4e5a299e9\",\n\"version\": 1\n}\n</code></pre> Python API client: delete an agent operation by uuid <pre><code>import json\nfrom shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nagentop = sf_client.delete_agent_operation('5a00d6f3-19b6-42bc-b1df-ddc4e5a299e9')\n</code></pre>"},{"location":"developer_guide/api_reference/artifacts/","title":"Artifacts (/artifacts/)","text":"<p>The general usage of artifacts is documented in the user guide. This page documents the API flow interacting with artifacts, as well as the multi-step process involved with uploading or downloading an artifact.</p> Note <p>For a detailed reference on the state machine for artifacts, see the developer documentation on object states.</p>"},{"location":"developer_guide/api_reference/artifacts/#fetching-a-remote-url-as-an-image-artifact","title":"Fetching a remote URL as an image artifact","text":"<p>As discussed in the user guide, remote URLs can be stored within a Shaken Fist cluster as artifacts of type image. These artifacts are often used as the template for disks attached to instances and are the equivalent to AWS AMIs or OpenStack images in Glance.</p> REST API calls <ul> <li>POST /artifacts: Fetch an image artifact into the cluster.</li> </ul> Python API client: cache an artifact <p>Note this API call is asynchronous and therefore returns immediately. Use artifact version information and events to determine if a new version was fetched and if that fetch is complete.</p> <pre><code>from shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nsf_client.cache_artifact('https://images.shakenfist.com/debian:11/latest.qcow2')\n</code></pre>"},{"location":"developer_guide/api_reference/artifacts/#fetching-information-about-an-artifact","title":"Fetching information about an artifact","text":"<p>As expected, you can use a GET REST API call to fetch information about all artifacts in a namespace, or a specific artifact for more detailed information. Artifacts also track \"events\" (see the user guide for a general introduction to the Shaken Fist event system).</p> REST API calls <ul> <li>GET /artifacts: List artifacts for a namespace.</li> <li>GET /artifacts/{artifact_ref}: Get information about a specific artifact.</li> <li>GET /artifacts/{artifact_ref}/events: Fetch events for a specific artifact.</li> </ul> Python API client: list artifacts <p>Note this API call is asynchronous and therefore returns immediately. Use artifact version information and events to determine if a new version was fetched and if that fetch is complete.</p> <pre><code>from shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nartifacts = sf_client.get_artifacts()\n\nprint('uuid,namespace,type,source_url,versions,state,shared')\nfor meta in artifacts:\n    versions = '%d of %d' % (len(meta.get('blobs', [])),\n                             meta.get('index', 'unknown'))\n    print('%s,%s,%s,%s,%s,%s,%s' % (\n          meta.get('uuid', ''), meta.get('namespace', ''),\n          meta.get('artifact_type', ''),\n          meta.get('source_url', ''), versions,\n          meta.get('state', ''), meta.get('shared', False)))\n</code></pre> <pre><code>$ python3 example.py\nuuid,namespace,type,source_url,versions,state,shared\n05e841a7-7e13-4df6-8c04-8932b98885bd,system,image,sf://upload/system/centos-9-stream,1 of 1,created,False\n1646bc22-674b-4a46-97e5-f767a6e82d1c,system,image,debian:11,3 of 9,created,False\n...\n</code></pre> Python API client: get information about a specific artifact <pre><code>import json\nfrom shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nartifact = sf_client.get_artifact('05e841a7-7e13-4df6-8c04-8932b98885bd')\nprint(json.dumps(artifact, indent=4, sort_keys=True))\n</code></pre> <pre><code>{\n\"artifact_type\": \"image\",\n\"blob_uuid\": \"8fa321aa-1e05-43c9-ade1-36d45940d6bd\",\n\"blobs\": {\n\"1\": {\n\"depends_on\": null,\n\"instances\": [],\n\"reference_count\": 2,\n\"size\": 960546304,\n\"uuid\": \"8fa321aa-1e05-43c9-ade1-36d45940d6bd\"\n}\n},\n\"index\": 1,\n\"max_versions\": 3,\n\"metadata\": {},\n\"namespace\": \"system\",\n\"shared\": false,\n\"source_url\": \"sf://upload/system/centos-9-stream\",\n\"state\": \"created\",\n\"uuid\": \"05e841a7-7e13-4df6-8c04-8932b98885bd\",\n\"version\": 6\n}\n</code></pre> Python API client: list events for an artifact <pre><code>import json\nfrom shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nevents = sf_client.get_artifact_events('05e841a7-7e13-4df6-8c04-8932b98885bd')\nprint(json.dumps(events, indent=4, sort_keys=True))\n</code></pre> <p>Note that events are returned in reverse chronological order and are limited to the 100 most recent events.</p> <pre><code>[\n...\n{\n\"duration\": null,\n\"extra\": {},\n\"fqdn\": \"sf-3\",\n\"message\": \"artifact fetch complete\",\n\"timestamp\": 1684718452.2673004,\n\"type\": \"audit\"\n},\n...\n]\n</code></pre>"},{"location":"developer_guide/api_reference/artifacts/#deleting-artifacts","title":"Deleting artifacts","text":"<p>Artifacts may be deleted individually, or an entire namespace at a time.</p> REST API calls <ul> <li>DELETE /artifacts: Delete all artifacts within a specific namespace.</li> <li>DELETE /artifacts/{artifact_ref}: Delete a specific artifact.</li> </ul> Python API client: delete a single artifact <pre><code>from shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nsf_client.delete_artifact('05e841a7-7e13-4df6-8c04-8932b98885bd')\n</code></pre> Python API client: delete all artifacts in a namespace <pre><code>from shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nsf_client.delete_all_artifacts('mynamespace')\n</code></pre>"},{"location":"developer_guide/api_reference/artifacts/#uploads","title":"Uploads","text":"<p>Artifact uploads normally require multiple HTTP requests in order to complete. This is because artifacts are often very large, and the REST API wants to allow you to continue an upload even if a single HTTP session fails or times out. This is implemented by creating an upload object, POSTing data to that object repeatedly, and then converting that upload object to an artifact.</p> <p>Upload objects which have not have data posted to them in a long time (currently 24 hours) are automatically removed.</p> <p>You create an upload by POST'ing to <code>/upload</code>. This will create a new upload object and return you a JSON representation of that object. The JSON includes the UUID, node the upload is stored on, and when it was created.</p> <p>Then repeatedly POST binary data to <code>/upload/...uuid...</code>. This binary data is blindly appended to your upload object. Do not encode the data with base64 or similar. Each call will return the new size of the object.</p> <p>If necessary, you can also truncate an upload object to a specified size, for example if you are unsure that a POST operation completed correctly. You do this by sending a POST to <code>/upload/...uuid.../truncate/...desired.length...</code>.</p> <p>Once your upload is complete, you convert it to an artifact by calling <code>/artifacts/upload/...name...</code> to convert it to an artifact.</p> <p>There is one final optimization to uploads, which is implemented in the python API and command line clients. If before upload you calculate a sha512 of the object to be uploaded, you can then search for that checksum with the <code>/blob_checksums/sha512/...hash...</code> endpoint. If a blob is returned then you don't need to actually upload and can instead pass that blob uuid (with a POST argument named <code>blob_uuid</code>) instead of an upload uuid to the <code>/artifacts/upload/...name...</code> endpoint. See the swagger documentation for more details.</p> Note <p>For a detailed reference on the state machine for uploads, see the developer documentation on object states.</p> REST API calls <ul> <li>POST /upload: Create a new upload.</li> <li>POST /upload/{upload_uuid}: Append a new chunk to an already existing upload.</li> <li>POST /upload/{upload_uuid}/truncate: Truncate an upload to a specific index. This can be useful as a retry operation in the case of a transmission error.</li> <li>GET /artifacts: List artifacts.</li> <li>POST /artifacts/upload/{artifact_name}: Convert a completed upload into an artifact.</li> </ul> Python API client: create an upload, transfer data, and convert to an artifact <pre><code>from shakenfist_client import apiclient\nimport time\n\nsf_client = apiclient.Client()\nupload = sf_client.create_upload()\n\nbuffer_size = 4096\ntotal = 0\nretries = 0\nwith open('/tmp/input', 'rb') as f:\n    d = f.read(buffer_size)\n    while d:\n        start_time = time.time()\n        try:\n            remote_total = sf_client.send_upload(upload['uuid'], d)\n            retries = 0\n        except apiclient.APIException as e:\n            retries += 1\n\n            if retries &gt; 5:\n                print('Repeated failures, aborting')\n                raise e\n\n            print('Upload error, retrying...')\n            sf_client.truncate_upload(upload['uuid'], total)\n            f.seek(total)\n            buffer_size = 4096\n            d = f.read(buffer_size)\n            continue\n\n        # We aim for each chunk to take three seconds to transfer. This is\n        # partially because of the API timeout on the other end, but also\n        # so that uploads don't appear to stall over very slow networks.\n        # However, the buffer size must also always be between 4kb and 4mb.\n        elapsed = time.time() - start_time\n        buffer_size = int(buffer_size * 3.0 / elapsed)\n        buffer_size = max(4 * 1024, buffer_size)\n        buffer_size = min(2 * 1024 * 1024, buffer_size)\n\n        sent = len(d)\n        total += sent\n\n        if total != remote_total:\n            print('Remote side has %d, we have sent %d!'\n                  % (remote_total, total))\n            sys.exit(1)\n\n        d = f.read(buffer_size)\n\n    print('Creating artifact')\n    artifact = sf_client.upload_artifact('example', upload['uuid'])\n    print('Created artifact %s' % artifact['uuid'])\n</code></pre> <pre><code>$ python3 example.py\nCreating artifact\nCreated artifact 2d9c1d4c-3436-4ea8-9b60-833fe791eece\n$ sf-client artifact show 2d9c1d4c-3436-4ea8-9b60-833fe791eece\nuuid                     : 2d9c1d4c-3436-4ea8-9b60-833fe791eece\nnamespace                : system\ntype                     : image\nstate                    : created\nsource url               : sf://upload/system/example\ncurrent version blob uuid: 36e846f6-ae20-46e9-8377-1c123f22b610\nnumber of versions       : 1\nmaximum versions         : 3\nshared                   : False\n\nVersions:\n    1  : blob 36e846f6-ae20-46e9-8377-1c123f22b610 is 1.3MB\n$ sf-client artifact delete 2d9c1d4c-3436-4ea8-9b60-833fe791eece\n</code></pre>"},{"location":"developer_guide/api_reference/artifacts/#using-an-already-existing-blob-as-a-new-version-of-an-artifact","title":"Using an already existing blob as a new version of an artifact","text":"<p>Label artifacts are effectively a sequence of already existing blobs which have been categorized in some manner. For example, you might have a CI system producing golden images for a system, but then use a label artifact to indicate the most recent version of the golden image which has passed acceptance testing. You therefore can apply an existing blob (the version of the golden image you tested in our example), to an artifact as a new version.</p>"},{"location":"developer_guide/api_reference/artifacts/#removing-a-specific-version-from-an-artifact","title":"Removing a specific version from an artifact","text":"<p>It is also possible that a bad version of an artifact exists -- possibly because the system that creates the new versions experienced an error. You can therefore remove a specific version of an artifact as well.</p> REST API calls <ul> <li>DELETE /artifacts/{artifact_ref}/versions/{version_id}: Remove a specified version from an artifact.</li> </ul> Python API client: delete a specific version of an artifact <pre><code>from shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nsf_client.delete_artifact_version('2d9c1d4c-3436-4ea8-9b60-833fe791eece', 1)\n</code></pre>"},{"location":"developer_guide/api_reference/artifacts/#setting-the-maximum-number-of-versions-of-an-artifact","title":"Setting the maximum number of versions of an artifact","text":"<p>You can configure the number of versions a given artifact will store. The default value is the ARTIFACT_MAX_VERSIONS_DEFAULT configuration variable, but that may be overridden on a per-artifact basis.</p> REST API calls <ul> <li>POST /artifacts/{artifact_ref}/versions: Set the maximum number of versions of an artifact to store.</li> </ul> Python API client: delete a specific version of an artifact <pre><code>from shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nsf_client.set_artifact_max_versions('2d9c1d4c-3436-4ea8-9b60-833fe791eece', 7)\n</code></pre>"},{"location":"developer_guide/api_reference/artifacts/#downloads","title":"Downloads","text":"<p>Artifact downloads are implemented as fetching the data for the desired blob. You therefore must first lookup the versions for a given artifact and select a version that you wish to download. You can then fetch the data for the relevant blob by calling <code>/blobs/...uuid.../data</code> this call takes an optional query parameter of <code>offset</code>, which specifies how many bytes into the blob to start returning data from. This allows recommencing failed downloads.</p> REST API calls <ul> <li>GET /artifacts/{artifact_ref}/versions: List version blobs for a given artifact.</li> </ul> Python API client: list versions of an artifact <pre><code>import json\nfrom shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nvers = sf_client.get_artifact_versions('2d9c1d4c-3436-4ea8-9b60-833fe791eece')\nprint(json.dumps(vers, indent=4, sort_keys=True))\n</code></pre>"},{"location":"developer_guide/api_reference/artifacts/#sharing-and-unsharing","title":"Sharing and unsharing","text":"<p>As described in the operator guide, artifacts in the system namespace can be shared with all other namespaces. This is desirable for commonly used \"official\" images which many users will want to use.</p> REST API calls <ul> <li>POST /artifacts/{artifact_ref}/share: Share an artifact.</li> <li>POST /artifacts/{artifact_ref}/unshare: Unshare an artifact.</li> </ul> Python API client: share an artifact <pre><code>from shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nsf_client.share_artifact('2d9c1d4c-3436-4ea8-9b60-833fe791eece')\n</code></pre> Python API client: unshare an artifact <pre><code>from shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nsf_client.unshare_artifact('2d9c1d4c-3436-4ea8-9b60-833fe791eece')\n</code></pre>"},{"location":"developer_guide/api_reference/artifacts/#metadata","title":"Metadata","text":"<p>All objects exposed by the REST API may have metadata associated with them. This metadata is for storing values that are of interest to the owner of the resources, not Shaken Fist. Shaken Fist does not attempt to interpret these values at all, with the exception of the instance affinity metadata values. The metadata store is in the form of a key value store, and a general introduction is available in the user guide.</p> REST API calls <ul> <li>GET \u200b/artifacts\u200b/{artifact_ref}\u200b/metadata: Get metadata for an artifact.</li> <li>POST /artifacts/{artifact_ref}/metadata: Create a new metadata key for an artifact.</li> <li>DELETE /artifacts/{artifact_ref}/metadata/{key}: Delete a specific metadata key for an artifact.</li> <li>PUT /artifacts/{artifact_ref}/metadata/{key}: Update an existing metadata key for an artifact.</li> </ul> Python API client: set metadata on an artifact <pre><code>from shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nsf_client.set_artifact_metadata_item(img_uuid, 'foo', 'bar')\n</code></pre> Python API client: get metadata for an artifact <pre><code>import json\nfrom shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nmd = sf_client.get_artifact_metadata(img_uuid)\nprint(json.dumps(md, indent=4, sort_keys=True))\n</code></pre> Python API client: delete metadata for an artifact <pre><code>import json\nfrom shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nsf_client.delete_artifact_metadata_item(img_uuid, 'foo')\n</code></pre>"},{"location":"developer_guide/api_reference/authentication/","title":"Authentication (/auth/)","text":""},{"location":"developer_guide/api_reference/authentication/#create-an-api-access-token","title":"Create an API access token","text":"<p>Access to the REST API is granted via an access token. These tokens expire, so you may also have to request new tokens for long lived applications from time to time. You will receive a HTTP 401 status code if an access token has expired.</p> Note <p>For further details of the authentication scheme, see the developer guide.</p> REST API calls <ul> <li>POST /auth: Create an access token.</li> </ul> Python API client: creating an access token <p>The Python API client handles creating access tokens and refreshing them for you, so not specific action is required for this API call. The following code implies creation of an access token:</p> <pre><code>from shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\n</code></pre> curl: creating an access token <pre><code>$ curl -X POST https://shakenfist/api/auth -d '{\"namespace\": \"system\", \"key\": \"oisoSe7T\"}'\n{\n\"access_token\": \"eyJhbG...IkpXVCJ9.eyJmc...wwQ\",\n    \"token_type\": \"Bearer\",\n    \"expires_in\": 900\n}\n</code></pre> <p>This token is then used by passing it as a HTTP Authorization header with \"Bearer \" prepended:</p> <pre><code>$ curl -X GET https://shakenfist/api/auth/namespaces \\\n-H 'Authorization: Bearer eyJhbG...IkpXVCJ9.eyJmc...wwQ' \\\n-H 'Content-Type: application/json'\n[\n{\n\"name\": \"adhoc\",\n        \"state\": \"created\",\n        \"trust\": {\"full\": [\"system\"]}\n}, {\n\"name\": \"ci\",\n        \"state\": \"created\",\n        \"trust\": {\"full\": [\"system\"]}\n}, {\n\"name\": \"system\",\n        \"state\": \"created\",\n        \"trust\": {\"full\": [\"system\"]}\n}\n]\n</code></pre>"},{"location":"developer_guide/api_reference/authentication/#namespaces","title":"Namespaces","text":"<p>Resources in a Shaken Fist cluster are divided up into logical groupings called namespaces. All namespaces have equal permissions, except for the <code>system</code> namespace, which is used for administrative tasks.</p> Note <p>For a detailed reference on the state machine for namespaces, see the developer documentation on object states.</p> REST API calls <ul> <li>GET /auth/namespaces: List all namespaces visible to your currently authenticated namespace.</li> <li>POST /auth/namespaces: Create a namespace, if you have permissions to do so.</li> <li>DELETE /auth/namespaces/{namespace}: Delete a namespace.</li> <li>GET /auth/namespaces/{namespace}: Get details of a single namespace.</li> </ul> Python API client: list namespaces <p>This example lists all namespaces visible to the caller:</p> <pre><code>import json\nfrom shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nns = sf_client.get_namespaces()\nprint(json.dumps(ns, indent=4, sort_keys=True))\n</code></pre> <p>Which returns something like:</p> <pre><code>[\n{\n\"keys\": [\n\"jenkins\"\n],\n\"metadata\": {},\n\"name\": \"ci\",\n\"state\": \"created\",\n\"trust\": {\n\"full\": [\n\"system\"\n]\n},\n\"version\": 5\n},\n...\n]\n</code></pre> Python API client: create a namespace <p>This example creates a new namespace, which is only possible if you are currently authenticated as the <code>system</code> namespace:</p> <pre><code>import json\nfrom shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nns = sf_client.create_namespace('demo')\nprint(json.dumps(ns, indent=4, sort_keys=True))\n</code></pre> <p>Which returns something like:</p> <pre><code>{\n\"keys\": [],\n\"metadata\": {},\n\"name\": \"demo\",\n\"state\": \"created\",\n\"trust\": {\n\"full\": [\n\"system\"\n]\n},\n\"version\": 5\n}\n</code></pre> Python API client: delete a namespace <p>This example deletes a namespace, which is only possible if you are currently authenticated as the <code>system</code> namespace:</p> <pre><code>import json\nfrom shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nns = sf_client.delete_namespace('demo')\nprint(json.dumps(ns, indent=4, sort_keys=True))\n</code></pre> <p>The call does not return anything.</p> Python API client: get details of a single namespace <pre><code>import json\nfrom shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nns = sf_client.get_namespace('demo')\nprint(json.dumps(ns, indent=4, sort_keys=True))\n</code></pre> <p>Which returns something like:</p> <pre><code>{\n\"keys\": [],\n\"metadata\": {},\n\"name\": \"demo\",\n\"state\": \"created\",\n\"trust\": {\n\"full\": [\n\"system\"\n]\n},\n\"version\": 5\n}\n</code></pre>"},{"location":"developer_guide/api_reference/authentication/#namespace-keys","title":"Namespace keys","text":"<p>Callers authenticate to a namespace by providing a key to a call to <code>/auth/</code> as discussed above. The calls discussed in this section relate to the management of the keys used to authenticate to a namespace.</p> REST API calls <ul> <li>GET /auth/namespaces/{namespace}/keys: List all authentication keys for a given namespace.</li> <li>POST /auth/namespaces/{namespace}/keys: Create a new key for a namespace.</li> <li>DELETE /auth/namespaces/{namespace}/keys/{key_name}: Delete a specific key for a namespace.</li> <li>PUT /auth/namespaces/{namespace}/keys/{key_name}: Update a key for a namespace.</li> </ul> Python API client: list all keys for a namespace <p>This example lists all the keys in a namespace:</p> <pre><code>from shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nkeys = sf_client.get_namespace_keynames('ci')\nprint(keys)\n</code></pre> <p>Which returns something like:</p> <pre><code>['jenkins']\n</code></pre> Python API client: create a new key for a namespace <p>This example adds a key to a namespace and then lists all keys:</p> <pre><code>from shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nsf_client.add_namespace_key('ci', 'newkey', 'thesecretvalue')\n\n# Fetch the list of keys to make sure the new one exists\nkeys = sf_client.get_namespace_keynames('ci')\nprint(keys)\n</code></pre> <p>Which returns something like:</p> <pre><code>['jenkins', 'newkey']\n</code></pre> Python API client: remove a specific key from a namespace <p>This example deletes a key from the namespace and then lists all keys:</p> <pre><code>from shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nsf_client.delete_namespace_key('ci', 'newkey')\n\n# Fetch the list of keys to make sure the new one exists\nkeys = sf_client.get_namespace_keynames('ci')\nprint(keys)\n</code></pre> <p>Which returns something like:</p> <pre><code>['jenkins']\n</code></pre> Python API client: update the secret portion of an existing namespace key <p>This example updates the secret portion of an existing namespace key to a new value:</p> <pre><code>from shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nsf_client.update_namespace_key('ci', 'newkey', 'newsecret')\n</code></pre>"},{"location":"developer_guide/api_reference/authentication/#metadata","title":"Metadata","text":"<p>All objects exposed by the REST API may have metadata associated with them. This metadata is for storing values that are of interest to the owner of the resources, not Shaken Fist. Shaken Fist does not attempt to interpret these values at all, with the exception of the instance affinity metadata values. The metadata store is in the form of a key value store, and a general introduction is available in the user guide.</p> REST API calls <ul> <li>GET \u200b/namespaces/{namespace}\u200b/metadata: Get metadata for a namespace.</li> <li>POST /namespaces/{namespace}/metadata: Create a new metadata key for a namespace.</li> <li>DELETE /namespaces/{namespace}/metadata/{key}: Delete a specific metadata key for a namespace.</li> <li>PUT /namespaces/{namespace}/metadata/{key}: Update an existing metadata key for a namespace.</li> </ul> Python API client: set metadata on a namespace <pre><code>from shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nsf_client.set_artifact_metadata_item(img_uuid, 'foo', 'bar')\n</code></pre> Python API client: get metadata for a namespace <pre><code>import json\nfrom shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nmd = sf_client.get_artifact_metadata(img_uuid)\nprint(json.dumps(md, indent=4, sort_keys=True))\n</code></pre> Python API client: delete metadata for a namespace <pre><code>import json\nfrom shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nsf_client.delete_artifact_metadata_item(img_uuid, 'foo')\n</code></pre>"},{"location":"developer_guide/api_reference/blob_checksums/","title":"Blob Checksums (/blob_checksums/)","text":"<p>Blob checksums are documented as part of blobs.</p>"},{"location":"developer_guide/api_reference/blobs/","title":"Blobs (/blobs/)","text":"<p>In general you interact with blobs as attributes of other objects -- blobs being the most obvious example. However, there is limited support in the REST API for interacting directly with blobs as well. Blobs are also considered a special case in that they are not namespaced like most other objects. That is, possession of the UUID of a blob is considered evidence that you should have access to it. This is because blobs can be shared between objects if the data for those objects is currently the identical. This is also why only administrators can list all blobs in a given Shaken Fist cluster.</p> Note <p>For a detailed reference on the state machine for blobs, see the developer documentation on object states.</p>"},{"location":"developer_guide/api_reference/blobs/#fetching-information-about-a-blob","title":"Fetching information about a blob","text":"<p>If you know the UUID of a blob, then you can GET information about that blob from the REST API, as well as fetching the actual data the blob is storing as well.</p> REST API calls <ul> <li>GET /blobs: List all blobs in a cluster. You must be an administrator to make this call.</li> <li>GET /blobs/{blob_uuid}: Get information about a specific blob.</li> <li>GET /blobs/{blob_uuid}/data: Get the stored data for a specific blob.</li> <li>GET /blob_checksums/sha512/{hash}: Find a blob with this hash.</li> </ul> Python API client: get a specific blob <pre><code>import json\nfrom shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nb = sf_client.get_blob('578da8b6-eb98-4e10-bb36-e4d4d763d312')\nprint(json.dumps(b, indent=4, sort_keys=True))\n</code></pre> Python API client: download the data for a specific blob <p>This example requires retry logic to handle the HTTP connection dropping while transferring large files.</p> <pre><code>import http\nfrom shakenfist_client import apiclient\nimport requests\nimport sys\nimport urllib3\n\nsf_client = apiclient.Client()\n\ntotal = 0\nconnection_failures = 0\ndone = False\n\nwith open('output', 'wb') as f:\n    while not done:\n        bytes_in_attempt = 0\n\n        try:\n            for chunk in sf_client.get_blob_data(\n                    '578da8b6-eb98-4e10-bb36-e4d4d763d312', offset=total):\n                received = len(chunk)\n                f.write(chunk)\n                bytes_in_attempt += received\n                total += received\n\n            done = True\n\n        except urllib3.exceptions.NewConnectionError as e:\n            connection_failures += 1\n            if connection_failures &gt; 2:\n                print('HTTP connection repeatedly failed: %s' % e)\n                sys.exit(1)\n\n        except (ConnectionResetError, http.client.IncompleteRead,\n                urllib3.exceptions.ProtocolError,\n                requests.exceptions.ChunkedEncodingError) as e:\n            # An API error (or timeout) occurred. Retry unless we got nothing.\n            if bytes_in_attempt == 0:\n                print('HTTP connection dropped without transferring data: %s' % e)\n                sys.exit(1)\n</code></pre> Python API client: search for a blob by sha512 hash <p>Note that this call is not supported by older versions of the Shaken Fist REST API.</p> <pre><code>import hashlib\nimport json\nfrom shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nif not sf_client.check_capability('blob-search-by-hash'):\n    print('Searching by hash is not supported')\nelse:\n    sha512_hash = hashlib.sha512()\n    with open('input', 'rb') as f:\n        d = f.read(4096)\n        while d:\n            sha512_hash.update(d)\n            d = f.read(4096)\n\n    print('Searching for a pre-existing blob with this hash...')\n    b = sf_client.get_blob_by_sha512(sha512_hash.hexdigest())\n    if not b:\n        print('No matching blob found')\n    else:\n        print('Blob %s is a match' % b['uuid'])\n</code></pre>"},{"location":"developer_guide/api_reference/blobs/#metadata","title":"Metadata","text":"<p>All objects exposed by the REST API may have metadata associated with them. This metadata is for storing values that are of interest to the owner of the resources, not Shaken Fist. Shaken Fist does not attempt to interpret these values at all, with the exception of the instance affinity metadata values. The metadata store is in the form of a key value store, and a general introduction is available in the user guide.</p> REST API calls <ul> <li>GET \u200b/blobs\u200b/{blob_uuid}\u200b/metadata: Get metadata for a blob.</li> <li>POST /blobs/{blob_uuid}/metadata: Create a new metadata key for a blob.</li> <li>DELETE /blobs/{blob_uuid}/metadata/{key}: Delete a specific metadata key for a blob.</li> <li>PUT /blobs/{blob_uuid}/metadata/{key}: Update an existing metadata key for a blob.</li> </ul> Python API client: set metadata on a blob <pre><code>from shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nsf_client.set_blob_metadata_item(blob_uuid, 'foo', 'bar')\n</code></pre> Python API client: get metadata for a blob <pre><code>import json\nfrom shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nmd = sf_client.get_blob_metadata(blob_uuid)\nprint(json.dumps(md, indent=4, sort_keys=True))\n</code></pre> Python API client: delete metadata for a blob <pre><code>import json\nfrom shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nsf_client.delete_blob_metadata_item(blob_uuid, 'foo')\n</code></pre>"},{"location":"developer_guide/api_reference/instances/","title":"Instances (/instances/)","text":"<p>Instances sit at the core of Shaken Fist's functionality, and are the component which ties most of the other concepts in the API together. Therefore, they are also the most complicated part of Shaken Fist to explain. This description is broken into basic functionality -- showing information about instances -- and then moves onto more advanced topics like creation, deletion, and other lifecycle events.</p> Note <p>For a detailed reference on the state machine for instances, see the developer documentation on object states.</p>"},{"location":"developer_guide/api_reference/instances/#fetching-information-about-an-instance","title":"Fetching information about an instance","text":"<p>There are two main ways to fetch information about instances -- you can list all instances visible to your authenticated namespace, or you can collect information about a specific instance by providing its UUID or name.</p> Info <p>Note that the amount of information visible in an instance response will change over the lifecycle of the instance -- for example when you first request the instance be created versus when the instance has had its disk specification calculated.</p> REST API calls <ul> <li>GET /instances: List all instances visible to your authenticated namespace.</li> <li>GET /instances/{instance_ref}: Get information about a specific instance.</li> </ul> Python API client: get all visible instances <pre><code>import json\nfrom shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\ninstances = sf_client.get_instances()\nprint(json.dumps(instances, indent=4, sort_keys=True))\n</code></pre> Python API client: get information about a specific instance <pre><code>import json\nfrom shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\ni = sf_client.get_instance('317e9b70-8e26-46af-a1c4-76931c0da5a9')\nprint(json.dumps(i, indent=4, sort_keys=True))\n</code></pre>"},{"location":"developer_guide/api_reference/instances/#instance-creation","title":"Instance creation","text":"<p>Instance creation is by far the most complicated call in Shaken Fist in terms of the arguments that it takes. The code in the Python command line client is helpful if you need a fully worked example of every possible permutation. The OpenAPI documentation at https://openapi.shakenfist.com/#/instances/post_instances provides comprehensive and up to date documentation on all the arguments to the creation call.</p> <p>The instance creation API call also takes three data structures: the <code>diskspec</code>; the <code>networkspec</code>; and the <code>videospec</code>. These structures are not well documented in the OpenAPI interface, so are documented here instead.</p>"},{"location":"developer_guide/api_reference/instances/#diskspec","title":"diskspec","text":"<p>A <code>diskspec</code> consists of the following fields as a JSON dictionary:</p> <ul> <li>size (integer): the size of the disk in gigabytes.</li> <li>base (string): the base image for the disk. This can be a variety of URL-like strings,   as documented on the artifacts page in the user guide.   For a blank disk, omit this value.</li> <li>bus (enum): the hardware bus the disk device should be attached to on the instance.   In general you shouldn't care about this and can omit this value. However, in   some cases, such as unmodified Microsoft Windows images it is required. The options   available here are: sata; scsi; usb; virtio (the default); and nvme. While ide   was previously supported, that support was removed in v0.7 due to extremely   poor performance.</li> <li>type (enum): the type of device. The default is \"disk\", but in some cases you might   want \"cdrom\".</li> </ul> <p>A full example of a <code>diskspec</code> is therefore:</p> <pre><code>{\n    'size': 20,\n    'base': 'debian:11',\n    'bus': None,\n    'type': None\n}\n</code></pre>"},{"location":"developer_guide/api_reference/instances/#networkspec","title":"networkspec","text":"<p>Similarly, a <code>networkspec</code> consists of the following fields in a JSON dictionary:</p> <ul> <li>network_uuid (uuid): the UUID of the network the interface should exist on.</li> <li>macaddress (string): the MAC address of the interface. Omit this value to be allocated   a MAC address automatically.</li> <li>address (string): the IPv4 address to assign to the interface. Omit this value to be   allocated a random address.</li> <li>model (enum): the model of the network interface card. In general you should not have   to set this, although it can matter in some cases, such as unmodified Microsoft   Windows images. The options include: i82551; i82557b; i82559er; ne2k_pci; pcnet;   rtl8139; e1000; and virtio (the default).</li> <li>float (boolean): whether to associate a floating IP with this interface to enable external   accessibility to the instance. Note that you can float and unfloat an interface   after instance creation if desired.</li> </ul>"},{"location":"developer_guide/api_reference/instances/#videospec","title":"videospec","text":"<p>A <code>videospec</code> differs from a <code>diskspec</code> and a <code>networkspec</code> in that it is not passed as a list. You only have one <code>videospec</code> per instance. Once again, a <code>videospec</code> is a JSON dictionary with the following fields:</p> <ul> <li>model (enum): the model of the video card to attach to the instance. Possible   options include: vga; cirrus (the default); and qxl.</li> <li>memory (integer): the amount of video RAM the video card should have, in   kibibytes (blocks of 1024 bytes).</li> <li>vdi (string): the VDI protocol to use. Options are \"vnc\", \"spice\" (the default), or   \"spiceconcurrent\". spice and spiceconcurrent are the same except that spiceconcurrent   allows limited multi-user sessions, with subsequent sessions not experiencing   full VDI functionality.</li> </ul> REST API calls <ul> <li>POST /instances/: Create an instance.</li> </ul> Python API client: create and then delete a simple instance <pre><code>from shakenfist_client import apiclient\nimport time\n\nsf_client = apiclient.Client()\ni = sf_client.create_instance(\n    'example', 1, 1024, None,\n    [{\n        'size': 20,\n        'base': 'debian:11',\n        'bus': None,\n        'type': 'disk'\n    }],\n    None, None)\n\ntime.sleep(30)\n\ni = sf_client.delete_instance(i['uuid'])\n</code></pre>"},{"location":"developer_guide/api_reference/instances/#adding-network-interfaces-after-instance-creation","title":"Adding network interfaces after instance creation","text":"<p>As of Shaken Fist v0.8, it is also possible to add network interfaces to an existing instance, assuming that your guest operating system supports device hot plugging (all modern Linux versions do).</p> REST API calls <ul> <li>POST /instances/{instance_ref}/interfaces</li> </ul> Python API client: hot plug a network interface <p>Note that this example assumes the instance is running an image with the Shaken Fist in guest agent installed.</p> <p>```python from shakenfist_client import apiclient</p> <p>sf_client = apiclient.Client()</p>"},{"location":"developer_guide/api_reference/instances/#create-a-network-to-hot-plug-to","title":"Create a network to hot plug to","text":"<p>hotnet = sf_client.allocate_network('10.0.0.0/24', True, True, 'hotplug')</p> <p>...</p>"},{"location":"developer_guide/api_reference/instances/#hot-plug-the-interface-in","title":"Hot plug the interface in","text":"<p>netdesc = {     'network_uuid': hotnet['uuid'],     'address': '10.0.0.5',     'macaddress': '02:00:00:ea:3a:28' } sf_client.add_instance_interface(inst['uuid'], netdesc)</p>"},{"location":"developer_guide/api_reference/instances/#other-instance-lifecycle-operations","title":"Other instance lifecycle operations","text":"<p>A variety of other lifecycle operations are available on instances, including deletion, and power management.</p> <p>The power management actions available are:</p> <ul> <li>soft reboot: gracefully request a reboot from the instance operating system   via ACPI. This is not guaranteed to actually work, but if it does is much less   likely to cause disk corruption on the instance.</li> <li>hard reboot: the equivalent of holding the reset switch down on a physical machine   until it reboots without operating system involvement.</li> <li>power on: turn the instance on, as if the power switch was pressed. Since v0.8   power on operations have the side effect of creating the config drive if one is   specified by the instance configuration. That is, you can recreate the config   drive by powering the instance off and then on again.</li> <li>power off: turn the instance immediately off, as if the power switch was held   down on a physical machine.</li> <li>pause: suspend execution of the instance, but leave it hot in RAM ready to   restart.</li> <li>unpause: unsuspend execution of the instance.</li> </ul> REST API calls <ul> <li>DELETE /instances/{instance_ref}: Delete an instance.</li> <li>DELETE /instances/: Delete all instances in a namespace.</li> <li>POST \u200b/instances\u200b/{instance_ref}\u200b/rebootsoft: Soft (ACPI) reboot the instance.</li> <li>POST \u200b/instances\u200b/{instance_ref}\u200b/reboothard: Hard (reset switch) reboot the instance.</li> <li>POST /instances/{instance_ref}/poweron: Power the instance on.</li> <li>POST /instances/{instance_ref}/poweroff: Power the instance off, as if holding the power switch down.</li> <li>POST /instances/{instance_ref}/pause: Pause an instance.</li> <li>POST /instances/{instance_ref}/unpause: Unpause an instance.</li> </ul> Python API client: create and then delete a simple instance <pre><code>from shakenfist_client import apiclient\nimport time\n\nsf_client = apiclient.Client()\ni = sf_client.create_instance(\n    'example', 1, 1024, None,\n    [{\n        'size': 20,\n        'base': 'debian:11',\n        'bus': None,\n        'type': 'disk'\n    }],\n    None, None)\n\ntime.sleep(30)\n\ni = sf_client.delete_instance(i['uuid'])\n</code></pre> Python API client: attempt a soft reboot, and hard reboot if required <p>Note that this example assumes the instance is running an image with the Shaken Fist in guest agent installed.</p> <pre><code>import time\nfrom shakenfist_client import apiclient\nimport sys\n\nsf_client = apiclient.Client()\ni = sf_client.create_instance(\n    'example', 1, 1024, None,\n    [{\n        'size': 20,\n        'base': 'debian:11',\n        'bus': None,\n        'type': 'disk'\n    }],\n    None, None, side_channels=['sf-agent'])\n\n# Wait for the instance to be created, or error out. Use instance events to\n# provide status updates during boot.\nwhile i['state'] not in ['created', 'error']:\n    events = sf_client.get_instance_events(i['uuid'])\n    print('Waiting for the instance to start: %s' % events[0]['message'])\n    time.sleep(5)\n    i = sf_client.get_instance(i['uuid'])\n\n# Check the instance is created correctly\nif i['state'] != 'created':\n    print('Instance is not in a created state!')\n    sys.exit(1)\nprint('Instance is created')\n\n# Wait for the agent to report the reboot time\nwhile not i['agent_system_boot_time']:\n    print('Waiting for agent to start: %s' % i['agent_state'])\n    time.sleep(20)\n    i = sf_client.get_instance(i['uuid'])\n\ninitial_boot = i['agent_system_boot_time']\nprint('Instance booted at %d' % initial_boot)\n\n# Now try to soft reboot the instance, wait up to 60 seconds for a reboot to\n# be detected\nsf_client.reboot_instance(i['uuid'], hard=False)\nprint('Soft rebooting instance')\ntime.sleep(60)\ni = sf_client.get_instance(i['uuid'])\n\n# Wait for the agent to report the reboot time again\nwhile not i['agent_system_boot_time']:\n    print('Waiting for agent to start: %s' % i['agent_state'])\n    time.sleep(20)\n    i = sf_client.get_instance(i['uuid'])\n\nif i['agent_system_boot_time'] != initial_boot:\n    print('Boot time changed from %d to %s'\n        % (initial_boot, i['agent_system_boot_time']))\n\nelse:\n    # We failed to soft reboot, let's hard reboot instead\n    sf_client.reboot_instance(i['uuid'], hard=True)\n    print('Instance did not reboot, hard rebooting')\n</code></pre> <p>Sample output:</p> <pre><code>$ python3 example.py\nWaiting for the instance to start: schedule complete\nInstance is created\nWaiting for agent to start: not ready (no contact)\nWaiting for agent to start: not ready (no contact)\nWaiting for agent to start: not ready (no contact)\nInstance booted at 1684404969\nSoft rebooting instance\nBoot time changed from 1684404969 to 1684405036.0\n</code></pre> Python API client: power off and then on an instance <pre><code>import time\nfrom shakenfist_client import apiclient\nimport sys\n\nsf_client = apiclient.Client()\ni = sf_client.create_instance(\n        'example', 1, 1024, None,\n        [{\n            'size': 20,\n            'base': 'debian:11',\n            'bus': None,\n            'type': 'disk'\n        }],\n        None, None)\n\n# Wait for the instance to be created, or error out. Use instance events to\n# provide status updates during boot.\nwhile i['state'] not in ['created', 'error']:\n    events = sf_client.get_instance_events(i['uuid'])\n    print('Waiting for the instance to start: %s' % events[0]['message'])\n    time.sleep(5)\n    i = sf_client.get_instance(i['uuid'])\n\n# Check the instance is created correctly\nif i['state'] != 'created':\n    print('Instance is not in a created state!')\n    sys.exit(1)\nprint('Instance is created')\n\n# Check the instance is created correctly\nif i['power_state'] != 'on':\n    print('Instance is not in powered on state!')\n    sys.exit(1)\n\n# Power the instance off\nsf_client.power_off_instance(i['uuid'])\nwhile i['power_state'] != 'off':\n    print('Waiting for the instance to power off')\n    time.sleep(5)\n    i = sf_client.get_instance(i['uuid'])\n\ntime.sleep(30)\n\n# Power the instance on\nsf_client.power_on_instance(i['uuid'])\nwhile i['power_state'] != 'on':\n    print('Waiting for the instance to power on')\n    time.sleep(5)\n    i = sf_client.get_instance(i['uuid'])\n\nprint('Done')\n</code></pre> <pre><code>Waiting for the instance to start: set attribute\nInstance is created\nWaiting for the instance to power off\nWaiting for the instance to power on\nDone\n</code></pre> Python API client: pause and unpause an instance <pre><code>import time\nfrom shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nsf_client.pause_instance('foo')\n\ntime.sleep(30)\n\nsf_client.unpause_instance('foo')\n</code></pre>"},{"location":"developer_guide/api_reference/instances/#other-instance-information","title":"Other instance information","text":"<p>We can also request other information for an instance. For example, we can list the instance's network interfaces, or the events for the instance. See the user guide for a general introduction to the Shaken Fist event system.</p> REST API calls <ul> <li>GET /instances/{instance_ref}/interfaces: Request information on the instance's network interfaces, if any.</li> <li>GET /instances/{instance_ref}/events: Fetch events for a specific instance.</li> </ul> Python API client: list network interfaces for an instance <p>Note that the interface details for an instance wont be populated until the instance has started being created on the hypervisor node. Specifically, this can be some time later if an image needs to be fetched from the Internet and transcoded. Therefore in this example we wait for the instance to be created before displaying interface details.</p> <pre><code>import json\nfrom shakenfist_client import apiclient\nimport time\n\nsf_client = apiclient.Client()\ni = sf_client.create_instance(\n        'example', 1, 1024, None,\n        [{\n            'size': 20,\n            'base': 'debian:11',\n            'bus': None,\n            'type': 'disk'\n        }],\n        None, None)\n\n# Wait for the instance to be created, or error out. Use instance events to\n# provide status updates during boot.\nwhile i['state'] not in ['created', 'error']:\n    events = sf_client.get_instance_events(i['uuid'])\n    print('Waiting for the instance to start: %s' % events[0]['message'])\n    time.sleep(5)\n    i = sf_client.get_instance(i['uuid'])\n\n# Check the instance is created correctly\nif i['state'] != 'created':\n    print('Instance is not in a created state!')\n    sys.exit(1)\nprint('Instance is created')\n\n# Fetch and display interface details\nifaces = sf_client.get_instance_interfaces(i['uuid'])[0]\nprint(json.dumps(ifaces, indent=4, sort_keys=True))\n</code></pre> <pre><code>$ python3 example.py\nWaiting for the instance to start: Fetching required blob ffdfce7f-728e-4b76-83c2-304e252f98b1, 30% complete\nInstance is created\n[\n{\n\"floating\": null,\n        \"instance_uuid\": \"d512e9f5-98d6-4c36-8520-33b6fc6de15f\",\n        \"ipv4\": \"10.0.0.6\",\n        \"macaddr\": \"02:00:00:73:18:66\",\n        \"metadata\": {},\n        \"model\": \"virtio\",\n        \"network_uuid\": \"6aaaf243-0406-41a1-aa13-5d79a0b8672d\",\n        \"order\": 0,\n        \"state\": \"created\",\n        \"uuid\": \"b1981e81-b37a-4176-ba37-b61bc7208012\",\n        \"version\": 3\n}\n]\n</code></pre> Python API client: list events for an instance <pre><code>import json\nfrom shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\ninterfaces = sf_client.get_instance_events('c0d52a77-0f8a-4f19-bec7-0c05efb03cb4')\nprint(json.dumps(interfaces, indent=4, sort_keys=True))\n</code></pre> <p>Note that events are returned in reverse chronological order and are limited to the 100 most recent events.</p> <pre><code>[\n...\n{\n\"duration\": null,\n\"extra\": {\n\"cpu usage\": {\n\"cpu time ns\": 357485828000,\n\"system time ns\": 66297716000,\n\"user time ns\": 291188112000\n},\n\"disk usage\": {\n\"vda\": {\n\"actual bytes on disk\": 956301312,\n\"errors\": -1,\n\"read bytes\": 406776320,\n\"read requests\": 12225,\n\"write bytes\": 2105954304,\n\"write requests\": 3657\n},\n\"vdb\": {\n\"actual bytes on disk\": 102400,\n\"errors\": -1,\n\"read bytes\": 279552,\n\"read requests\": 74,\n\"write bytes\": 0,\n\"write requests\": 0\n}\n},\n\"network usage\": {\n\"02:00:00:1d:24:ae\": {\n\"read bytes\": 147084732,\n\"read drops\": 0,\n\"read errors\": 0,\n\"read packets\": 16484,\n\"write bytes\": 2166754,\n\"write drops\": 0,\n\"write errors\": 0,\n\"write packets\": 13144\n}\n}\n},\n\"fqdn\": \"sf-2\",\n\"message\": \"usage\",\n\"timestamp\": 1685229509.9592097,\n\"type\": \"usage\"\n},\n...\n]\n</code></pre>"},{"location":"developer_guide/api_reference/instances/#out-of-band-interactions-with-instances","title":"Out-of-band interactions with instances","text":"<p>Shaken Fist supports three types of instance consoles, which provide out-of-band management of instances -- that is, the instance does not need to have functioning networking for these consoles to work. You can read a general introduction of Shaken Fist's console functionality in the user guide. This page focuses on the API calls which are used to implement the console functionality in the Shaken Fist client.</p> <ul> <li>Read only console: to download the most recent portion of the read only text   serial console, or clear the console, use the   <code>/instances/{instance_ref}/consoledata</code> API calls below.</li> <li>Interactive serial console: lookup the console port from the instance details   fetch (as described above), and then connect to that port on the hypervisor   node with a TCP client such as telnet.</li> <li>Interactive VDI console: lookup the VDI console port from the instance details   fetch (as described above), and then connect to that port on the hypervisor   with the correct client (currently one of VNC or SPICE). Alternatively, use   the <code>/instances/{instance_ref}/vdiconsolehelper</code> API call described below to   download a <code>virt-viewer</code> configuration file and then connect with <code>virt-viewer</code>.   See the example below for more details.</li> </ul> REST API calls <ul> <li>GET /instances/{instance_ref}/consoledata: Fetch read only serial console data for an instance</li> <li>DELETE /instances/{instance_ref}/consoledata: Clear the read only serial console for an instance.</li> <li>GET /instances/{instance_ref}/vdiconsolehelper: Generate and return a <code>virt-viewer</code> configuration file for connecting to the interactive VDI console for the instance (if configured).</li> </ul> Python API client: connect seamlessly to a VDI console using virt-viewer <pre><code>import os\nfrom shakenfist_client import apiclient\nimport subprocess\nimport tempfile\nimport time\n\nsf_client = apiclient.Client()\ni = sf_client.create_instance(\n        'example', 1, 1024, None,\n        [{\n            'size': 20,\n            'base': 'debian:11',\n            'bus': None,\n            'type': 'disk'\n        }],\n        None, None)\n\n# Wait for the instance to be created, or error out. Use instance events to\n# provide status updates during boot.\nwhile i['state'] not in ['created', 'error']:\n    events = sf_client.get_instance_events(i['uuid'])\n    print('Waiting for the instance to start: %s' % events[0]['message'])\n    time.sleep(5)\n    i = sf_client.get_instance(i['uuid'])\n\n# Check the instance is created correctly\nif i['state'] != 'created':\n    print('Instance is not in a created state!')\n    sys.exit(1)\nprint('Instance is created')\n\n# We don't use NamedTemporaryFile as a context manager as the .vv file\n# will also attempt to clean up the file.\n(temp_handle, temp_name) = tempfile.mkstemp()\nos.close(temp_handle)\ntry:\n    with open(temp_name, 'w') as f:\n        f.write(sf_client.get_vdi_console_helper(i['uuid']))\n\n    p = subprocess.run('remote-viewer %s' % temp_name, shell=True)\n    print('Remote viewer process exited with %d return code' % p.returncode)\nfinally:\n    if os.path.exists(temp_name):\n        os.unlink(temp_name)\n</code></pre>"},{"location":"developer_guide/api_reference/instances/#executing-commands-within-an-instance","title":"Executing commands within an instance","text":"<p>Since v0.7, assuming a given instance has the Shaken Fist agent installed and running, and was created with a <code>sf-agent</code> side channel, you can use the Shaken Fist agent to move data into and out of the instance and execute commands without the instance needing to have working networking configured. You can read more about the exact requirements for agent connectivity in the API reference guide for agent operations.</p> <p>Agent Operations are not created directly -- they are a side effect of a call to one of the API methods below, which create an Agent Operation so the caller can track the state of their request. At the time of writing, you can perform the following operations via the agent:</p> <ul> <li>copy the contents of a blob into an instance and change its file permissions.   The python API client has a helper to upload the file into a blob before copying   to the instance.</li> <li>execute a command and return its results (exit code, stdout, stderr).</li> <li>get the contents of a file within an instance into a blob.</li> </ul> REST API calls <ul> <li>POST \u200b/instances\u200b/{instance_ref}\u200b/agent\u200b/execute: execute a command within an instance and return results.</li> <li>POST /instances/{instance_ref}/agent/put: copy a blob into an instance at the specified location with the specified permissions.</li> </ul> Python API client: execute a command on an instance <pre><code>import json\nfrom shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nagentop = sf_client.instance_execute('...uuid...', 'cat /etc/os-release')\nprint(json.dumps(agentop, indent=4, sort_keys=True))\n</code></pre> <p>Which would return something along the lines of:</p> <pre><code>{\n\"commands\": [\n{\n\"block-for-result\": true,\n\"command\": \"execute\",\n\"commandline\": \"cat /etc/os-release\"\n}\n],\n\"instance_uuid\": \"a771fb13-aaad-4cb6-a86b-7ee51e7bacc6\",\n\"metadata\": {},\n\"namespace\": \"vdi\",\n\"results\": {\n\"0\": {\n\"command-line\": \"cat /etc/os-release\",\n\"result\": true,\n\"return-code\": 0,\n\"stderr\": \"\",\n\"stdout\": \"PRETTY_NAME=\\\"Debian GNU/Linux 11 (bullseye)\\\"...\"\n}\n},\n\"state\": \"complete\",\n\"uuid\": \"93fb538c-84f5-4ff8-83ba-2be5f5f92954\",\n\"version\": 1\n}\n</code></pre> Python API client: put a file onto an instance via a blob <pre><code>import os\nfrom shakenfist_client import apiclient\nfrom shakenfist_client import util\n\nsf_client = apiclient.Client()\nif not sf_client.check_capability('blob-search-by-hash'):\n    blob = None\nelse:\n    # We can cheat here -- if we already have a blob in the cluster with the\n    # checksum of the file we're uploading, we can skip the upload entirely and\n    # just reuse that blob.\n    blob = util.checksum_with_progress(sf_client, 'README.md')\n\nif not blob:\n    artifact = util.upload_artifact_with_progress(\n        sf_client, 'upload-to-instance', 'README.md', None)\nelse:\n    print('Recycling existing blob')\n    artifact = sf_client.blob_artifact(\n        'upload-to-instnace', blob['uuid'], source_url=None)\nprint('Created artifact %s' % artifact['uuid'])\n\nst = os.stat('README.md')\nsf_client.instance_put_blob(\n        '...instance_ref...', artifact['blob_uuid'], '/tmp/README.md', st.st_mode)\n</code></pre> <p>Which would return something along the lines of:</p> <pre><code>$ python3 /tmp/demo.py\nCalculate checksum: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 805/805 [00:00&lt;00:00, 13.0MB/s]\nSearching for a pre-existing blob with this hash...\nRecycling existing blob\nCreated artifact 3c0a6a83-e9df-46f0-b9a3-819eb16bea23\n</code></pre> Python API client: get a file from an instance via a blob <pre><code>from shakenfist_client import apiclient\nimport sys\n\nsf_client = apiclient.Client()\nop = sf_client.instance_get('...instance_ref...', '/tmp/README.md')\nif '0' not in op.get('results', {}):\n    print('Results not available.')\n    sys.exit(1)\n\nblob_uuid = op['results']['0'].get('content_blob')\nif not blob_uuid:\n    print('Results did not include content')\n    sys.exit(1)\n\nwith open('/tmp/README.md', 'wb') as f:\n    for chunk in sf_client.get_blob_data(blob_uuid):\n        f.write(chunk)\n</code></pre>"},{"location":"developer_guide/api_reference/instances/#fetching-information-about-an-instances-agent-operations","title":"Fetching information about an Instance's Agent Operations","text":"<p>Additionally, you can list the agent operations for a given instance.</p> REST API calls <ul> <li>GET /instances/{instance_ref}/agentoperations: List all agent operations for an instance.</li> </ul> Python API client: get all agent operations for a specific instance <p>The instance here had the following command line commands run before this sample script was run:</p> <pre><code>$ sf-client instance upload ...uuid... README.md /tmp/README.md\n$ sf-client --simple instance execute ...uuid... \"cat /tmp/README.md\"\n</code></pre> <pre><code>import json\nfrom shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nagentops = sf_client.get_instance_agentoperations('...uuid...', all=True)\nprint(json.dumps(agentops, indent=4, sort_keys=True))\n</code></pre> <p>Note the <code>all</code> argument here. By default you are only returned agent operations which are queued to execute. To see all agent operations including those which have completed execution, pass <code>all=True</code>. This script outputs:</p> <pre><code>[\n{\n\"commands\": [\n{\n\"blob_uuid\": \"09306f15-b1b3-4850-afb4-f4179559fa7f\",\n\"command\": \"put-blob\",\n\"path\": \"/tmp/README.md\"\n},\n{\n\"command\": \"chmod\",\n\"mode\": 33188,\n\"path\": \"/tmp/README.md\"\n}\n],\n\"instance_uuid\": \"a771fb13-aaad-4cb6-a86b-7ee51e7bacc6\",\n\"metadata\": {},\n\"namespace\": \"vdi\",\n\"results\": {\n\"0\": {\n\"path\": \"/tmp/README.md\"\n},\n\"1\": {\n\"path\": \"/tmp/README.md\"\n}\n},\n\"state\": \"complete\",\n\"uuid\": \"343049d7-da2a-46f2-bb5c-edb783ec1fb9\",\n\"version\": 1\n},\n{\n\"commands\": [\n{\n\"block-for-result\": true,\n\"command\": \"execute\",\n\"commandline\": \"cat /tmp/README.md\"\n}\n],\n\"instance_uuid\": \"a771fb13-aaad-4cb6-a86b-7ee51e7bacc6\",\n\"metadata\": {},\n\"namespace\": \"vdi\",\n\"results\": {\n\"0\": {\n\"command-line\": \"cat /tmp/README.md\",\n\"result\": true,\n\"return-code\": 0,\n\"stderr\": \"\",\n\"stdout\": \"...content of file...\"\n}\n},\n\"state\": \"complete\",\n\"uuid\": \"5a00d6f3-19b6-42bc-b1df-ddc4e5a299e9\",\n\"version\": 1\n}\n]\n</code></pre>"},{"location":"developer_guide/api_reference/instances/#console-screen-captures","title":"Console screen captures","text":"<p>Since v0.8, Shaken Fist has provided an API for collecting screen captures of the instance console. This works for either serial consoles or graphical consoles, its literally the same was whatever would have been displayed on the monitor if the instance was a physical machine.</p> REST API calls <ul> <li>GET \u200b/instances\u200b/{instance_ref}\u200b/screenshot: Collect a screenshot for an instance.</li> </ul> <p>This API call returns a blob UUID, you then need to collect the contents of the blob using the GET /blobs/{blob_uuid}/data API call. The python Shaken Fist API client perfoms both operations for you and returns an iterator of binary chunks ready for you to process or write to a file.</p> Python API client: collect a screenshot for an instance an instance <pre><code>from shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nwith open(destination, 'wb') as f:\n    for chunk in sf_client.get_screenshot(instance_ref):\n        f.write(chunk)\n</code></pre>"},{"location":"developer_guide/api_reference/instances/#metadata","title":"Metadata","text":"<p>All objects exposed by the REST API may have metadata associated with them. This metadata is for storing values that are of interest to the owner of the resources, not Shaken Fist. Shaken Fist does not attempt to interpret these values at all, with the exception of the instance affinity metadata values. The metadata store is in the form of a key value store, and a general introduction is available in the user guide.</p> Info <p>Note that for affinity metadata to be processed by the scheduler, it must be present in the instance create API call, which is why that call takes a metadata argument. Adding affinity metadata after instance creation will not affect the placement of that instance, but would affect the placement of future instances.</p> REST API calls <ul> <li>GET \u200b/instances\u200b/{instance_ref}\u200b/metadata: Get metadata for an instance.</li> <li>POST /instances/{instance_ref}/metadata: Create a new metadata key for an instance.</li> <li>DELETE /instances/{instance_ref}/metadata/{key}: Delete a specific metadata key for an instance.</li> <li>PUT /instances/{instance_ref}/metadata/{key}: Update an existing metadata key for an instance.</li> </ul> Python API client: set metadata on an instance <pre><code>from shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nsf_client.set_instance_metadata_item(instance_uuid, 'foo', 'bar')\n</code></pre> Python API client: get metadata for an instance <pre><code>import json\nfrom shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nmd = sf_client.get_instance_metadata(instance_uuid)\nprint(json.dumps(md, indent=4, sort_keys=True))\n</code></pre> Python API client: delete metadata for an instance <pre><code>import json\nfrom shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nsf_client.delete_instance_metadata_item(instance_uuid, 'foo')\n</code></pre>"},{"location":"developer_guide/api_reference/interfaces/","title":"Network Interfaces (/interfaces/)","text":"<p>Network Interfaces (known as just \"interfaces\" in the REST API), are the object which ties an instance to the networks it is present on. There is a 1:1 mapping between network interface objects and NICs inside an instance, such that an instance with multiple interfaces on the same network would have two network interface objects associated with it.</p> <p>To lookup the network interfaces for an instance, use the GET /instances/{instance_ref}/interfaces API call as documented in the instance documentation.</p> Note <p>For a detailed reference on the state machine for network interfaces, see the developer documentation on object states.</p>"},{"location":"developer_guide/api_reference/interfaces/#fetching-information-about-a-network-interface","title":"Fetching information about a network interface","text":"<p>As with other objects in the Shaken Fist REST API, you can fetch the details for a network interface from the REST API.</p> REST API calls <ul> <li>GET /interfaces/{interface_uuid}: Get information about a specific network interface.</li> </ul> Python API client: fetch interface details <pre><code>import json\nfrom shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\niface = sf_client.get_interface('b1981e81-b37a-4176-ba37-b61bc7208012')\nprint(json.dumps(iface, indent=4, sort_keys=True))\n</code></pre> Python API client: fetch details for a network interface associated with an instance <p>Note that the interface details for an instance wont be populated until the instance has started being created on the hypervisor node. Specifically, this can be some time later if an image needs to be fetched from the Internet and transcoded. Therefore in this example we wait for the instance to be created before displaying interface details.</p> <pre><code>import json\nfrom shakenfist_client import apiclient\nimport time\n\nsf_client = apiclient.Client()\ni = sf_client.create_instance(\n        'example', 1, 1024, None,\n        [{\n            'size': 20,\n            'base': 'debian:11',\n            'bus': None,\n            'type': 'disk'\n        }],\n        None, None)\n\n# Wait for the instance to be created, or error out. Use instance events to\n# provide status updates during boot.\nwhile i['state'] not in ['created', 'error']:\n    events = sf_client.get_instance_events(i['uuid'])\n    print('Waiting for the instance to start: %s' % events[0]['message'])\n    time.sleep(5)\n    i = sf_client.get_instance(i['uuid'])\n\n# Check the instance is created correctly\nif i['state'] != 'created':\n    print('Instance is not in a created state!')\n    sys.exit(1)\nprint('Instance is created')\n\n# Fetch and display interface details\nifaces = sf_client.get_instance_interfaces(i['uuid'])[0]\nprint(json.dumps(ifaces, indent=4, sort_keys=True))\n</code></pre> <pre><code>$ python3 example.py\nWaiting for the instance to start: Fetching required blob ffdfce7f-728e-4b76-83c2-304e252f98b1, 30% complete\nInstance is created\n[\n{\n\"floating\": null,\n        \"instance_uuid\": \"d512e9f5-98d6-4c36-8520-33b6fc6de15f\",\n        \"ipv4\": \"10.0.0.6\",\n        \"macaddr\": \"02:00:00:73:18:66\",\n        \"metadata\": {},\n        \"model\": \"virtio\",\n        \"network_uuid\": \"6aaaf243-0406-41a1-aa13-5d79a0b8672d\",\n        \"order\": 0,\n        \"state\": \"created\",\n        \"uuid\": \"b1981e81-b37a-4176-ba37-b61bc7208012\",\n        \"version\": 3\n}\n]\n</code></pre>"},{"location":"developer_guide/api_reference/interfaces/#floating-network-interfaces","title":"Floating network interfaces","text":"<p>Network interfaces by default have an address on the private IP range of the network they belong to. This is sufficient to access resources outside the Shaken Fist cluster, as long as the network has <code>provide_nat</code> enabled when created. However, a network interface is not accessible from outside the Shaken Fist cluster in this state.</p> <p>To make a network interface accessible to clients outside the Shaken Fist cluster, you \"float\" the interface. This assigns an address from the cluster's <code>floating</code> network, which is then DNAT'ed to the private IP address of the interface. As an instance it is not possible to see your floating address from inside the instance, as the network address translation has already occurred when the packets reach the instance.</p> REST API calls <ul> <li>POST /interfaces/{interface_uuid}/float: Add a floating address to a network interface to make it externally accessible.</li> <li>POST /interfaces/{interface_uuid}/defloat: Remove a floating address from a network interface, thus making the interface not externally accessible.</li> </ul> Python API client: float a network interface <p>A request to float an interface is an asynchronous operation, so we must make the request and then poll to learn our external address.</p> <pre><code>import json\nfrom shakenfist_client import apiclient\nimport time\n\nsf_client = apiclient.Client()\nsf_client.float_interface('b1981e81-b37a-4176-ba37-b61bc7208012')\n\niface = sf_client.get_interface('b1981e81-b37a-4176-ba37-b61bc7208012')\nwhile not iface.get('floating'):\n    print('Waiting...')\n    time.sleep(5)\n    iface = sf_client.get_interface('b1981e81-b37a-4176-ba37-b61bc7208012')\n\nprint('The interface is externally accessible at %s' % iface['floating'])\n</code></pre> <pre><code>$ python3 example.py\nThe interface is externally accessible at 192.168.10.5\n</code></pre> Python API client: defloat a network interface <pre><code>import json\nfrom shakenfist_client import apiclient\nimport time\n\nsf_client = apiclient.Client()\nsf_client.defloat_interface('b1981e81-b37a-4176-ba37-b61bc7208012')\n</code></pre>"},{"location":"developer_guide/api_reference/interfaces/#metadata","title":"Metadata","text":"<p>All objects exposed by the REST API may have metadata associated with them. This metadata is for storing values that are of interest to the owner of the resources, not Shaken Fist. Shaken Fist does not attempt to interpret these values at all, with the exception of the instance affinity metadata values. The metadata store is in the form of a key value store, and a general introduction is available in the user guide.</p> REST API calls <ul> <li>GET \u200b/interfaces\u200b/{interface_uuid}\u200b/metadata: Get metadata for an interface.</li> <li>POST /interfaces/{interface_uuid}/metadata: Create a new metadata key for an interface.</li> <li>DELETE /interfaces/{interface_uuid}/metadata/{key}: Delete a specific metadata key for an interface.</li> <li>PUT /interfaces/{interface_uuid}/metadata/{key}: Update an existing metadata key for an interface.</li> </ul> Python API client: set metadata on an interface <pre><code>from shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nsf_client.set_interface_metadata_item(img_uuid, 'foo', 'bar')\n</code></pre> Python API client: get metadata for an interface <pre><code>import json\nfrom shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nmd = sf_client.get_interface_metadata(img_uuid)\nprint(json.dumps(md, indent=4, sort_keys=True))\n</code></pre> Python API client: delete metadata for an interface <pre><code>import json\nfrom shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nsf_client.delete_interface_metadata_item(img_uuid, 'foo')\n</code></pre>"},{"location":"developer_guide/api_reference/label/","title":"Label (/label/)","text":"<p>Most interactions with labels will be to treat them as artifacts, which are documented elsewhere. However, there are a small number of label specific calls which are documented here. For a general introduction to labels, see the artifacts section of the user guide.</p> REST API calls <ul> <li>GET /label/{label_name}: Search for a label by name.</li> <li>POST /label/{label_name}: Update the current blob for a label.</li> <li>DELETE /label/{label_name}: Delete a label by name.</li> </ul> Python API client: update a label <p>A common pattern is to use generic upstream Shaken Fist images as source image, which you then customize and test. Once testing has passed you add the tested version of a label which tracks \"blessed\" production images.</p> <pre><code>import json\nfrom shakenfist_client import apiclient\nimport time\n\nsf_client = apiclient.Client()\n\n# Download a copy of Debian 11 and wait for the download to complete\nsf_client.cache_artifact('debian:11')\na = sf_client.get_artifact('debian:11')\n\nwhile not a.get('blobs'):\n    print('Waiting for first blob...')\n    time.sleep(30)\n    a = sf_client.get_artifact('debian:11')\n\nblob_index = sorted(a['blobs'].keys())[-1]\nblob_uuid = a['blobs'][blob_index]['uuid']\n\nprint('The most recent blob UUID is %s' % blob_uuid)\n\n# Let's assume we've now tested this version and want to \"bless\" it as the\n# version we trust for production workloads. We would then add that blob as the\n# new version of our production label like this:\nprod = sf_client.update_label('debian-11-production', blob_uuid)\n\nprint()\nprint('The label artifact is now:')\nprint(json.dumps(prod, indent=4, sort_keys=True))\n</code></pre> <pre><code>$ python3 example.py\nThe most recent blob UUID is ffdfce7f-728e-4b76-83c2-304e252f98b1\n\nThe label artifact is now:\n{\n\"artifact_type\": \"label\",\n    \"blob_uuid\": \"ffdfce7f-728e-4b76-83c2-304e252f98b1\",\n    \"blobs\": {\n\"1\": {\n\"depends_on\": null,\n            \"instances\": [\n\"d512e9f5-98d6-4c36-8520-33b6fc6de15f\"\n],\n            \"reference_count\": 2,\n            \"size\": 403007488,\n            \"uuid\": \"ffdfce7f-728e-4b76-83c2-304e252f98b1\"\n}\n},\n    \"index\": 1,\n    \"max_versions\": 3,\n    \"metadata\": {},\n    \"namespace\": \"system\",\n    \"shared\": false,\n    \"source_url\": \"sf://label/system/debian-11-production\",\n    \"state\": \"created\",\n    \"uuid\": \"c9428ea2-a3fa-40cf-9668-61be99bb370a\",\n    \"version\": 6\n}\n</code></pre>"},{"location":"developer_guide/api_reference/networks/","title":"Networks (/networks/)","text":"<p>Networks exist so that instances can have connectivity to other instances, or services outside the Shaken Fist cluster. Networks are implemented as a VXLAN mesh between the hypervisor nodes which host the instances on that network, and the network node. The network node exists on every VXLAN mesh, and provides services to the network such as DHCP, ping, and egress NAT. If a floating IP is assigned to a network interface or a routed IP to a network, then that is also implemented on the network node.</p> Note <p>It is not required that an instance be on any networks. However, this is by far the most common deployment pattern.</p> <p>For a detailed reference on the state machine for networks, see the developer documentation on object states.</p> <p>For a detailed overview of how networks are constructed on the network node and hypervisors, see the operator guide networking overview.</p>"},{"location":"developer_guide/api_reference/networks/#network-lifecycle","title":"Network lifecycle","text":"REST API calls <ul> <li>POST /networks: Create a network.</li> <li>DELETE /networks: Delete all networks in a given namespace.</li> <li>DELETE /networks/networks/{network_ref}: Delete a specific network.</li> <li>GET /networks: List the networks visible to the currently authenticated namespace.</li> <li>GET /networks/{network_ref}: Get details of a single network</li> </ul> Python API client: create a network <pre><code>import json\nfrom shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nn = sf_client.allocate_network('10.0.0.0/24', True, True, 'example')\nprint(json.dumps(n, indent=4, sort_keys=True))\n</code></pre> <pre><code>{\n\"floating_gateway\": \"192.168.10.16\",\n\"metadata\": {},\n\"name\": \"example\",\n\"namespace\": \"system\",\n\"netblock\": \"10.0.0.0/24\",\n\"provide_dhcp\": true,\n\"provide_nat\": true,\n\"provide_dns\": false,\n\"state\": \"created\",\n\"uuid\": \"1e9222c5-2d11-4ada-b258-ed1838bd774b\",\n\"version\": 4,\n\"vxid\": 4882442\n}\n</code></pre> Python API client: delete a network <pre><code>import json\nfrom shakenfist_client import apiclient\nimport time\n\nsf_client = apiclient.Client()\nn = sf_client.allocate_network('10.0.0.0/24', True, True, 'example')\n\nn = sf_client.delete_network(n['uuid'])\nwhile n['state'] != 'deleted':\n    print('Waiting...')\n    time.sleep(1)\n    n = sf_client.get_network(n['uuid'])\n\nprint(json.dumps(n, indent=4, sort_keys=True))\n</code></pre> <pre><code>$ python3 example.py\nWaiting...\n{\n\"floating_gateway\": null,\n    \"metadata\": {},\n    \"name\": \"example\",\n    \"namespace\": \"system\",\n    \"netblock\": \"10.0.0.0/24\",\n    \"provide_dhcp\": true,\n    \"provide_nat\": true,\n    \"provide_dns\": false,\n    \"state\": \"deleted\",\n    \"uuid\": \"d56ae6e4-2592-43cd-b614-2dc7ca04970a\",\n    \"version\": 4,\n    \"vxid\": 15408371\n}\n</code></pre> Python API client: get a single network <pre><code>from shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nn = sf_client.get_network('...uuid...')\n</code></pre> Python API client: list networks <pre><code>import json\nfrom shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nnets = sf_client.get_networks()\nprint(json.dumps(nets, indent=4, sort_keys=True))\n</code></pre> <pre><code>[\n{\n\"name\": \"sfcbr-7YWeQo4BoqLjASDd\",\n\"namespace\": \"sfcbr-7YWeQo4BoqLjASDd\",\n\"netblock\": \"10.0.0.0/24\",\n\"provide_dhcp\": true,\n\"provide_nat\": true,\n\"provide_dns\": false,\n\"state\": \"created\",\n\"uuid\": \"759b742d-6140-475e-9553-ac120b56c1ef\",\n\"vxlan_id\": 0\n}\n]\n</code></pre>"},{"location":"developer_guide/api_reference/networks/#other-network-information","title":"Other network information","text":"<p>We can also request other information for a network. For example, we can list the networks's network interfaces, or the events for the network. See the user guide for a general introduction to the Shaken Fist event system.</p> REST API calls <ul> <li>GET /networks/{network_ref}/events: Fetch events for a network.</li> <li>GET /networks/{network_ref}/interfaces: Get the network interfaces present on a network.</li> <li>GET /networks/{network_ref}/ping/{address}: Ping an address on a network from the network node.</li> </ul> Python API client: list events for a network <pre><code>import json\nfrom shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nevents = sf_client.get_network_events('e0c2ee96-2b61-4d58-abd4-2cdef522b7a6')\nprint(json.dumps(events, indent=4, sort_keys=True))\n</code></pre> <p>Note that events are returned in reverse chronological order and are limited to the 100 most recent events.</p> <pre><code>[\n...\n{\n\"duration\": null,\n\"extra\": {\n\"rx\": {\n\"bytes\": 2146364,\n\"dropped\": 0,\n\"errors\": 0,\n\"multicast\": 0,\n\"over_errors\": 0,\n\"packets\": 13127\n},\n\"tx\": {\n\"bytes\": 152367092,\n\"carrier_errors\": 0,\n\"collisions\": 0,\n\"dropped\": 0,\n\"errors\": 0,\n\"packets\": 96644\n}\n},\n\"fqdn\": \"sf-1\",\n\"message\": \"usage\",\n\"timestamp\": 1685229103.9690208,\n\"type\": \"usage\"\n},\n...\n]\n</code></pre> Python API client: list interfaces on a network <pre><code>import json\nfrom shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nevents = sf_client.get_network_interfaces('91b88200-ab4c-4ac4-9709-459504d1da0a')\nprint(json.dumps(events, indent=4, sort_keys=True))\n</code></pre> <pre><code>[\n{\n\"floating\": \"192.168.10.84\",\n\"instance_uuid\": \"fffaa23b-c38b-484b-b58e-22eedc6ba94f\",\n\"ipv4\": \"10.0.0.20\",\n\"macaddr\": \"02:00:00:19:e4:b4\",\n\"metadata\": {},\n\"model\": \"virtio\",\n\"network_uuid\": \"91b88200-ab4c-4ac4-9709-459504d1da0a\",\n\"order\": 0,\n\"state\": \"created\",\n\"uuid\": \"24e636b4-b60c-4fcc-89d3-e717667a8c83\",\n\"version\": 3\n},\n{\n\"floating\": null,\n\"instance_uuid\": \"1762820a-1e44-41b3-9174-44412481d873\",\n\"ipv4\": \"10.0.0.57\",\n\"macaddr\": \"02:00:00:4b:dc:5f\",\n\"metadata\": {},\n\"model\": \"virtio\",\n\"network_uuid\": \"91b88200-ab4c-4ac4-9709-459504d1da0a\",\n\"order\": 0,\n\"state\": \"created\",\n\"uuid\": \"0c790a6e-a4de-4518-84e7-11d1421cd4df\",\n\"version\": 3\n}\n]\n</code></pre> Python API client: ping an address on a network. <pre><code>import json\nfrom shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nevents = sf_client.ping('55ea5f3b-d671-4d7f-9b8c-1e8f217a74f4', '10.0.0.187')\nprint(json.dumps(events, indent=4, sort_keys=True))\n</code></pre> <pre><code>{\n\"stderr\": [\n\"\"\n],\n\"stdout\": [\n\"PING 10.0.0.187 (10.0.0.187) 56(84) bytes of data.\",\n\"64 bytes from 10.0.0.187: icmp_seq=1 ttl=64 time=0.393 ms\",\n\"64 bytes from 10.0.0.187: icmp_seq=2 ttl=64 time=0.273 ms\",\n\"64 bytes from 10.0.0.187: icmp_seq=3 ttl=64 time=0.227 ms\",\n\"64 bytes from 10.0.0.187: icmp_seq=4 ttl=64 time=0.252 ms\",\n\"64 bytes from 10.0.0.187: icmp_seq=5 ttl=64 time=0.269 ms\",\n\"64 bytes from 10.0.0.187: icmp_seq=6 ttl=64 time=0.252 ms\",\n\"64 bytes from 10.0.0.187: icmp_seq=7 ttl=64 time=0.228 ms\",\n\"64 bytes from 10.0.0.187: icmp_seq=8 ttl=64 time=0.265 ms\",\n\"64 bytes from 10.0.0.187: icmp_seq=9 ttl=64 time=0.246 ms\",\n\"64 bytes from 10.0.0.187: icmp_seq=10 ttl=64 time=0.257 ms\",\n\"\",\n\"--- 10.0.0.187 ping statistics ---\",\n\"10 packets transmitted, 10 received, 0% packet loss, time 9213ms\",\n\"rtt min/avg/max/mdev = 0.227/0.266/0.393/0.044 ms\",\n\"\"\n]\n}\n</code></pre>"},{"location":"developer_guide/api_reference/networks/#listing-network-address-usage","title":"Listing network address usage","text":"<p>Each network is associated with a single IP address block which is used to allocate addresses for that network. You can view the state of allocations on that address block using the REST API.</p> REST API calls <ul> <li>GET \u200b/networks\u200b/{network_ref}\u200b/addresses: list address allocations for a given network.</li> </ul> Python API client: list address allocations for a network <pre><code>import ipaddress\nfrom shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\naddresses = sf_client.get_network_addresses(network_ref)\n\ninfo_by_addr = {}\nfor addr in addresses:\n    info_by_addr[int(ipaddress.IPv4Address(addr['address']))] = addr\n\nprint('address,type,user,comment')\nfor addr in sorted(info_by_addr.keys()):\n    if not info_by_addr[addr]['user']:\n        user = ''\n    elif type(info_by_addr[addr]['user']) is list:\n        user = ' '.join(info_by_addr[addr]['user'])\n    else:\n        user = info_by_addr[addr]['user']\n\n    print('%s,%s,%s,%s'\n          % (info_by_addr[addr]['address'],\n             info_by_addr[addr]['type'],\n             ' '.join(info_by_addr[addr]['user']),\n             info_by_addr[addr]['comment']))\n</code></pre>"},{"location":"developer_guide/api_reference/networks/#routed-ips","title":"Routed IPs","text":"<p>Unlikely floating IPs, which are associated with a network interface, routed IPs are associated with a network -- its up to the virtual network to decide who will answer for that address via ARP responses. The API calls for routed IPs are therefore documented here instead of on the network interfaces page.</p> REST API calls <ul> <li>POST /networks/{network_ref}/route: route an address to this network.</li> <li>DELETE \u200b/networks\u200b/{network_ref}\u200b/route\u200b/{address}: unroute an address.</li> </ul> Python API client: add a routed address <pre><code>from shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nrouted = sf_client.route_network_address(network_ref)\n</code></pre> Python API client: remove a routed address <pre><code>from shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nsf_client.unroute_network_address(network_ref, address)\n</code></pre>"},{"location":"developer_guide/api_reference/networks/#metadata","title":"Metadata","text":"<p>All objects exposed by the REST API may have metadata associated with them. This metadata is for storing values that are of interest to the owner of the resources, not Shaken Fist. Shaken Fist does not attempt to interpret these values at all, with the exception of the instance affinity metadata values. The metadata store is in the form of a key value store, and a general introduction is available in the user guide.</p> REST API calls <ul> <li>GET \u200b/networks/{network_ref}\u200b/metadata: Get metadata for a network.</li> <li>POST /networks/{network_ref}/metadata: Create a new metadata key for a network.</li> <li>DELETE /networks/{network_ref}/metadata/{key}: Delete a specific metadata key for a network.</li> <li>PUT /networks/{network_ref}/metadata/{key}: Update an existing metadata key for a network.</li> </ul> Python API client: set metadata on a network <pre><code>from shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nsf_client.set_network_metadata_item(net_uuid, 'foo', 'bar')\n</code></pre> Python API client: get metadata for a network <pre><code>import json\nfrom shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nmd = sf_client.get_network_metadata(net_uuid)\nprint(json.dumps(md, indent=4, sort_keys=True))\n</code></pre> Python API client: delete metadata for a network <pre><code>import json\nfrom shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nsf_client.delete_network_metadata_item(net_uuid, 'foo')\n</code></pre>"},{"location":"developer_guide/api_reference/nodes/","title":"Nodes (/nodes/)","text":"<p>Nodes are how Shaken Fist models the hypervisors that actually run your virtual machines. They're a little unusual, as we use the host name to track the object instead of an assigned UUID. Nodes are an administrative-only object, not available to other users of Shaken Fist.</p> Note <p>For a detailed reference on the state machine for nodes, see the developer documentation on object states.</p>"},{"location":"developer_guide/api_reference/nodes/#node-lifecycle","title":"Node lifecycle","text":"<p>Nodes cannot be created via the API, instead nodes are created by installing Shaken Fist on a machine and having that machine join a Shaken Fist cluster. However, you can delete a node via API and that will cause the machine to delete all the instances running and stop accepting new work.</p> REST API calls <ul> <li>GET /nodes: List all nodes in the cluster, including deleted nodes.</li> <li>DELETE /nodes/{node}: Delete a node.</li> <li>GET /nodes/{node}: Get information about a single node.</li> </ul> Python API client: get details for a node <pre><code>import json\nfrom shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nn = sf_client.get_node('sf-1')\nprint(json.dumps(n, indent=4, sort_keys=True))\n</code></pre> Python API client: list all nodes <pre><code>import json\nfrom shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nn = sf_client.get_nodes()\nprint(json.dumps(n, indent=4, sort_keys=True))\n</code></pre>"},{"location":"developer_guide/api_reference/nodes/#other-network-information","title":"Other network information","text":"<p>We can also request other information for a network. For example, we can list the nodes's network interfaces, or the events for the network. See the user guide for a general introduction to the Shaken Fist event system.</p> REST API calls <ul> <li>GET /nodes/{node}/events: Fetch events for a node.</li> </ul> Python API client: list events for a node <pre><code>import json\nfrom shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nevents = sf_client.get_node_events('sf-1')\nprint(json.dumps(events, indent=4, sort_keys=True))\n</code></pre> <p>Note that events are returned in reverse chronological order and are limited to the 100 most recent events.</p> <pre><code>[\n...\n{\n\"duration\": null,\n\"extra\": {\n\"cpu_available\": 12,\n\"cpu_load_1\": 2.0,\n\"cpu_load_15\": 1.85,\n\"cpu_load_5\": 1.87,\n\"cpu_max\": 12,\n\"cpu_max_per_instance\": 16,\n\"cpu_total_instance_cpu_time\": 235110000000,\n\"cpu_total_instance_vcpus\": 1,\n\"disk_free\": 376334815232,\n...\n},\n\"fqdn\": \"sf-1\",\n\"message\": \"updated node resources and package versions\",\n\"timestamp\": 1685475323.252612,\n\"type\": \"resources\"\n},\n...\n]\n</code></pre>"},{"location":"developer_guide/api_reference/nodes/#metadata","title":"Metadata","text":"<p>All objects exposed by the REST API may have metadata associated with them. This metadata is for storing values that are of interest to the owner of the resources, not Shaken Fist. Shaken Fist does not attempt to interpret these values at all, with the exception of the instance affinity metadata values. The metadata store is in the form of a key value store, and a general introduction is available in the user guide.</p> REST API calls <ul> <li>GET \u200b/nodes/{node}\u200b/metadata: Get metadata for a node.</li> <li>POST /nodes/{node}/metadata: Create a new metadata key for a node.</li> <li>DELETE /nodes/{node}/metadata/{key}: Delete a specific metadata key for a node.</li> <li>PUT /nodes/{node}/metadata/{key}: Update an existing metadata key for a node.</li> </ul> Python API client: set metadata on a node <pre><code>from shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nsf_client.set_node_metadata_item(net_uuid, 'foo', 'bar')\n</code></pre> Python API client: get metadata for a node <pre><code>import json\nfrom shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nmd = sf_client.get_node_metadata(net_uuid)\nprint(json.dumps(md, indent=4, sort_keys=True))\n</code></pre> Python API client: delete metadata for a node <pre><code>import json\nfrom shakenfist_client import apiclient\n\nsf_client = apiclient.Client()\nsf_client.delete_node_metadata_item(net_uuid, 'foo')\n</code></pre>"},{"location":"developer_guide/api_reference/upload/","title":"Upload (/upload)","text":"<p>Uploads are documented as part of the artifacts API reference documentation.</p>"},{"location":"operator_guide/artifacts/","title":"Artifacts","text":""},{"location":"operator_guide/artifacts/#checksums","title":"Checksums","text":"<p>As of Shaken Fist v0.7, blob replicas are regularly checksummed to verify that data loss has not occurred. The following events imply a checksum operation:</p> <ul> <li>snapshotting an NVRAM template.</li> <li>creation of a new blob replica by transfer of a blob from another machine in   the cluster (the destination is checksummed to verify the transfer).</li> <li>transcode of a blob into a new format (the new format is stored as a   separate blob).</li> <li>conversion of an upload to an artifact.</li> </ul> <p>The following events should imply an artifact checksum, but we found that performance suffered too much for very large blobs:</p> <ul> <li>download of a new blob from an external source (artifact fetch for example).</li> <li>snapshotting a disk.</li> </ul> <p>Additionally, all blob replicas are regularly checksummed and compared with what the record in etcd believes the correct value should be. These comparisons are rate limited, but should happen with a maximum frequency of CHECKSUM_VERIFICATION_FREQUENCY seconds, which defaults to every 24 hours. It is possible if you have a large number of blob replicas on a given node that the node will be unable to keep up with checksum operations.</p> <p>If a blob replica fails the checksum verification, CHECKSUM_ENFORCEMENT is set to True and is not in use on that node, then the replica is deleted and the cluster will re-replicate the blob as required. If the blob replica is in use, there isn't much Shaken Fist can do without disturbing running instances, so the error is logged and then ignored for now.</p> <p>Checksums are also used when a new version of an artifact is created. If the checksum of the previous version is the same as the checksum for the proposed new version, the proposed new version is skipped. Artifact uploads from v0.7 can also skip actual upload of the contents of the artifact if there is already a blob in the cluster with a matching checksum.</p>"},{"location":"operator_guide/artifacts/#sharing-artifacts","title":"Sharing artifacts","text":"<p>Artifacts in the system namespace can be shared with all other namespaces. Artifacts shared like this appear to the other namespaces as if they are local to the other namespace, although non-system namespaces should not be able to update such an artifact. This is useful if you have official or commonly used images which you want to provide all users of a cluster -- for example an official CentOS image that many users will want.</p> Info <p>Another option for sharing artifacts is the \"trusts\" relationship between two namespaces, which is discussed in the authentication section of the operator guide.</p> <p>To share an artifact, use the command line client like this:</p> <p><code>sf-client artifact share ...uuid...</code></p> <p>To unshare an artifact, do this:</p> <p><code>sf-client artifact unshare ...uuid...</code></p>"},{"location":"operator_guide/authentication/","title":"Authentication","text":"Info <p>For a detailed discussion of how Shaken Fist authentication works, please see the discussion in the developer guide.</p>"},{"location":"operator_guide/authentication/#trusts","title":"Trusts","text":"Info <p>Trusts are a newer way of sharing between namespaces with granular control. If you instead are interested in making artifacts available to all users of a Shaken Fist cluster, then you should also consider artifact sharing, which is discussed in the artifacts section of the operators guide.</p> <p>The system namespace is special in a Shaken Fist cluster in that it can see objects in all other namespaces. That is, if you are authenticated as the system namespace and list instances, you get not only the instances in the system namespace, but also all those in other namespaces. The same is true for other namespaced objects such as networks and artifacts.</p> <p>In older versions of Shaken Fist this behavior was hard coded, but as of Shaken Fist v0.7 this is now implemented more flexibly. The system namespace must still be able to see every other namespace, but you can also create a \"trust\" relationship between two arbitrary namespaces to achieve the same result on a smaller scale. In fact, the system namespace is now simply a default trust that all other namespaces have a relationship with.</p> <p>The Shaken Fist CI system uses these trusts for base images for CI runs. Each night we rebuild a series of base test images -- Debian 10, Debian 11, Ubuntu 20.04 and so on. Each Shaken Fist CI job is run in its own namespace, so we needed a place to store these base images, as well as a mechanism for other CI jobs to be able to see them.</p> <p>What we implemented was:</p> <ul> <li>a namespace to store the base images (we called it <code>ci-images</code>).</li> <li>when our CI conductor creates a new CI runner and associated namespace, it   creates a trust between that ephemeral namespace and the <code>ci-images</code> namespace.</li> <li>jobs to create new images build them in their local namespace, and then \"gift\"   them to the <code>ci-images</code> namespace via a label.</li> <li>jobs which need to boot a test image can now see the images from the <code>ci-images</code>   namespace by virtue of this trust relationship.</li> </ul>"},{"location":"operator_guide/installation/","title":"Installing Shaken Fist","text":"<p>The purpose of this guide is to walk you through a Shaken Fist installation. Shaken Fist will work just fine on a single machine, although its also happy to run on clusters of machines. We'll discuss the general guidance for install options as we go.</p> <p>Shaken Fist only supports Ubuntu 22.04, Ubuntu 24.04, Debian 11, and Debian 12, so if you're running on localhost that implies that you must be running a recent Ubuntu or Debian on your development machine. Note as well that the deployer installs software and changes the configuration of your networking, so be careful when running it on machines you are fond of. Bug reports are welcome if you have any issues, and may be filed at https://github.com/shakenfist/shakenfist/issues</p> Note <p>Debian 10 support was dropped in v0.8, as supporting older versions of ansible became burdensome. Ubuntu 22.04 and Debian 12 support was added in v0.8.</p> <p>Each machine in the cluster should match this description:</p> <ul> <li>Have virtualization extensions enabled in the BIOS.</li> <li>Have jumbo frames enabled on the switch for the \"mesh interface\" for installations of more than one machine. Shaken Fist can optionally run internal traffic such as etcd and virtual network meshes on a separate interface to traffic egressing the cluster. Whichever interface you specify as being used for virtual network mesh traffic must have jumbo frames enabled for the virtual networks to function correctly.</li> <li>Have at least 1 gigabit connectivity on the \"mesh interface\". This is a requirement of etcd.</li> <li>Have a cloudadmin account setup with passwordless sudo, and a ssh key in its authorized_keys file. This is an ansible requirement, although the exact username is configurable in the SSH_USER variable.</li> </ul> <p>We now have a fancy helper to help you install your first cluster, so let's give that a go:</p> <pre><code>curl https://raw.githubusercontent.com/shakenfist/shakenfist/develop/deploy/getsf -o getsf\nchmod ugo+rx getsf\nsudo ./getsf\n</code></pre> <p>This script will then walk you through the installation steps, asking questions as you go. The script leaves you with an installer configuration at <code>/root/sf-deploy</code>, which is the basis for later upgrades and cluster expansions.</p> <p>You can script the answers to <code>getsf</code> by setting environment variables. For example:</p> <pre><code>export GETSF_FLOATING_BLOCK=192.168.10.0/24\nexport GETSF_DEPLOY_NAME=bonkerslab\nexport GETSF_RELEASE=pre-release\nexport GETSF_NODES=localhost\nexport GETSF_WARNING=yes\nsudo --preserve-env ./getsf\n</code></pre>"},{"location":"operator_guide/installation/#notes-for-multi-node-installations","title":"Notes for multi-node installations","text":"<p>Not every node needs to be an etcd_master. I'd select three in most situations. One node must be marked as the primary node, and one must be marked as the network node. It is not currently supported having more than one of each of those node types.</p> <ul> <li>The primary node runs an apache load balancer across the API servers in the cluster, and therefore needs to be accessable to your users on HTTP and HTTPS.</li> <li>The network node is the ingress and egress point for all virtual networks, and is where floating IPs live, so it needs to be setup as the gateway fro your floating IP block.</li> </ul> <p>Some of the considerations here can be subtle. Please reach out if you need a hand.</p> <p><code>getsf</code> writes a configuration file called <code>sf-deploy</code>. For a more complicated installation, <code>sf-deploy</code> might like this:</p> <pre><code>#!/bin/bash\n\nexport ADMIN_PASSWORD=engeeF1o\nexport FLOATING_IP_BLOCK=\"192.168.10.0/24\"\nexport DEPLOY_NAME=\"bonkerslab\"\nexport SSH_USER=\"cloudadmin\"\nexport SSH_KEY_FILENAME=\"/root/.ssh/id_rsa\"\n\nexport KSM_ENABLED=1\n\n# Topology is in JSON\nread -r -d '' TOPOLOGY &lt;&lt;'EOF'\n[\n  {\n    \"name\": \"sf-primary\",\n    \"node_egress_ip\": \"192.168.1.50\",\n    \"node_egress_nic\": \"enp0s31f6\",\n    \"node_mesh_ip\": \"192.168.21.50\",\n    \"node_mesh_nic\": \"enp0s31f6:1\",\n    \"primary_node\": true,\n    \"api_url\": \"https://...your...install...here.com/api\"\n  },\n  {\n    \"name\": \"sf-1\",\n    \"node_egress_ip\": \"192.168.1.51\",\n    \"node_egress_nic\": \"enp5s0\",\n    \"node_mesh_ip\": \"192.168.21.51\",\n    \"node_mesh_nic\": \"eno1\",\n    \"etcd_master\": true,\n    \"network_node\": true,\n    \"hypervisor\": true\n  },\n  {\n    \"name\": \"sf-2\",\n    \"node_egress_ip\": \"192.168.1.52\",\n    \"node_egress_nic\": \"enp5s0\",\n    \"node_mesh_ip\": \"192.168.21.52\",\n    \"node_mesh_nic\": \"eno1\",\n    \"etcd_master\": true,\n    \"hypervisor\": true\n  },\n  {\n    \"name\": \"sf-3\",\n    \"node_egress_ip\": \"192.168.1.53\",\n    \"node_egress_nic\": \"enp5s0\",\n    \"node_mesh_ip\": \"192.168.21.53\",\n    \"node_mesh_nic\": \"eno1\",\n    \"etcd_master\": true,\n    \"hypervisor\": true\n  },\n]\nEOF\nexport TOPOLOGY\n\n/srv/shakenfist/venv/share/shakenfist/installer/install\n</code></pre>"},{"location":"operator_guide/installation/#your-first-instance","title":"Your first instance","text":"<p>Before you can start your first instance you'll need to authenticate to Shaken Fist, and create a network. Shaken Fist's python api client (as used by the command line client) looks for authentication details in the following locations:</p> <ul> <li>Command line flags</li> <li>Environment variables (prefixed with SHAKENFIST_)</li> <li>~/.shakenfist, a JSON formatted configuration file</li> <li>/etc/sf/shakenfist.json, the same file as above, but global</li> </ul> <p>By default the installer creates /etc/sf/sfrc, which sets the required environment variables to authenticate. It is customized per installation, setting the following variables:</p> <ul> <li>SHAKENFIST_NAMESPACE, the namespace to create resources in</li> <li>SHAKENFIST_KEY, an authentication key for that namespace</li> <li>SHAKENFIST_API_URL, a URL to the Shaken Fist API server</li> </ul> <p>Before interacting with Shaken Fist, we need to source the rc file.</p> <pre><code>. /etc/sf/sfrc\n</code></pre> <p>Instances must be launched attached to a network.</p> <p>Create your first network: <pre><code>sf-client network create mynet 192.168.42.0/24\n</code></pre></p> <p>You can get help for the command line client by running <code>`sf-client --help</code>. The above command creates a new network called \"mynet\", with the IP block 192.168.42.0/24. You will receive some descriptive output back:</p> <pre><code>$ sf-client network create mynet 192.168.42.0/24\nuuid            : 16baa325-5adf-473f-8e7a-75710a822d45\nname            : mynet\nvxlan id        : 2\nnetblock        : 192.168.42.0/24\nprovide dhcp    : True\nprovide nat     : True\nfloating gateway: None\nnamespace       : system\nstate           : initial\n\nMetadata:\n</code></pre> <p>The UUID is important, as that is how we will refer to the network elsewhere. Let's now create a simple first instance (you'll need to change this to use your actual network UUID):</p> <pre><code>$ sf-client instance create myvm 1 1024 -d 8@cirros -n 16baa325-5adf-473f-8e7a-75710a822d45\nuuid        : c6c4ba94-ed34-497d-8964-c223489dee3e\nname        : myvm\nnamespace   : system\ncpus        : 1\nmemory      : 1024\ndisk spec   : type=disk   bus=None  size=8   base=cirros\nvideo       : model=cirrus  memory=16384\nnode        : marvin\npower state : on\nstate       : created\nconsole port: 31839\nvdi port    : 34442\n\nssh key     : None\nuser data   : None\n\nMetadata:\n\nInterfaces:\n\n    uuid    : e56b3c7b-8056-4645-b5b5-1779721ff21d\n    network : 16baa325-5adf-473f-8e7a-75710a822d45\n    macaddr : ae:15:4d:9c:d8:c0\n    order   : 0\nipv4    : 192.168.42.76\n    floating: None\n    model   : virtio\n</code></pre> <p>Probably the easiest way to interact with this instance is to connect to its console port, which is the serial console of the instance over telnet. In the case above, that is available on port 31829 on localhost (my laptop is called marvin).</p>"},{"location":"operator_guide/installation/#other-caveats","title":"Other caveats","text":"<p>The installer will also enforce the following sanity checks:</p> <ul> <li>That KVM will operate on your machines. This is generally fine unless you're using virtual machines at which point nested virtualization needs to be enabled.</li> <li>That your network interface MTU is greater than 2,000 bytes. This is required because the VXLAN mesh our virtual networks use add overhead to packets and a standard MTU of 1500 bytes for the physical network will result in packets being fragmented too frequently on the virtual networks. You can set a higher MTU if you desire, I generally select 9,000 bytes.</li> </ul>"},{"location":"operator_guide/installation/#deployment-variables","title":"Deployment variables","text":"Option Description ADMIN_PASSWORD The admin password for the cloud once installed DNS_SERVER The DNS server to configure instances with via DHCP. Defaults to 8.8.8.8 HTTP_PROXY A URL for a HTTP proxy to use for image downloads. For example http://localhost:3128 INCLUDE_TRACEBACKS Whether to include tracebacks in server 500 errors. Never set this to true in production! FLOATING_IP_BLOCK The IP range to use for the floating network KSM_ENABLED Set to 1 to enable KSM, 0 to disable DEPLOY_NAME The name of the deployment to use as an external label for prometheus TOPOLOGY The topology of the cluster, as described above SSH_KEY_FILENAME The path to a ssh private key file to use for authentication. It is assumed that the public key is at <code>${SSH_KEY_FILENAME}.pub</code>. SSH_USER The username to ssh as."},{"location":"operator_guide/locks/","title":"Locks","text":"<p>Shaken Fist uses etcd for distributed locking. All locks are written into etcd with the <code>/sflocks</code> key prefix. Locks are effectively leases on a key within etcd, where the key contains metadata about the lock being held. This means its easy to determine who else is holding a lock if you see contention issues within your cluster.</p> <p>The easiest way to do this is with the <code>sf-client admin lock list</code> command, which will list all locks currently held in the cluster. For example, here's a relatively idle cluster:</p> <pre><code>$ sf-client admin lock list\n+----------------------+-------+------+---------------------+\n|         lock         |  pid  | node |      operation      |\n+----------------------+-------+------+---------------------+\n| /sflocks/sf/cluster/ | 26407 | sf-7 | Cluster maintenance |\n+----------------------+-------+------+---------------------+\n</code></pre>"},{"location":"operator_guide/power_states/","title":"Instance power states","text":"<p>Shaken Fist version 0.2.1 introduced power states for instances. Before this, you could power on or off an instance, or pause it, but you couldn't tell what power state the instance was actually in. That was pretty confusing and was therefore treated as a bug.</p> <p>The following power states are implemented:</p> <ul> <li>on: the instance is running</li> <li>off: the instance is not running</li> <li>paused: the instance is paused</li> <li>crashed: the instance is crashed according to the hypervisor. Instances in this power state will also be in an instance state of \"error\".</li> </ul> <p>There are additionally a set of \"transition states\" which are used to indicate that you have requested a change of state that might not yet have completed. These are:</p> <ul> <li>transition-to-on</li> <li>transition-to-off</li> <li>transition-to-paused</li> </ul> <p>We're hoping to not have to implement a transition-to-crashed state, but you never know.</p>"},{"location":"operator_guide/python_versions/","title":"Supported python versions","text":"<p>The versions of python we support are driven by the versions packaged in our supported operating systems. For Shaken Fist itself, we support:</p> <ul> <li>Ubuntu 22.04: 3.10</li> <li>Ubuntu 24.04: 3.12</li> <li>Debian 11: 3.9</li> <li>Debian 12: 3.11</li> </ul> <p>We therefore support Python 3.9 and above for server side software.</p> <p>For client side software we are significantly more liberal. At the moment we build guest images for the following Linux distributions:</p> <ul> <li>CentOS 8-stream: 3.9</li> <li>CentOS 9-stream: 3.11</li> <li>Debian 11: 3.9</li> <li>Debian 12: 3.11</li> <li>Fedora 38: 3.12</li> <li>Fedora 39: 3.12</li> <li>Ubuntu 20.04: 3.8</li> <li>Ubuntu 22.04: 3.10</li> <li>Ubuntu 24.04: 3.12</li> </ul> <p>We therefore support Python 3.8 and above in client code such as the Shaken Fist client and in-guest agent.</p>"},{"location":"operator_guide/upgrades/","title":"Upgrades","text":"<p>Shaken Fist supports online upgrades natively -- when an object is read from etcd that is an old version, the object is upgraded silently to the newest version. If all nodes in your cluster are running a version of Shaken Fist which supports this newest version, the upgraded object is then written back to etcd. If not all nodes in the cluster support the new version, the new version is simply used in memory by the node which did the upgrade. This means it is safe to perform a rollout across a cluster without downtime, although you might see small transient failures such as single API requests failing as processes restart.</p> <p>You should note however that \"all nodes\" includes nodes in non-running states such as ERROR and MISSING. The only state which is excluded from the check is DELETED. Therefore, in order for online upgrades to work correctly, it is important that you delete nodes in an ERROR or MISSING state that you are confident will not return to the cluster. This is because nodes can return from ERROR or MISSING at the end of planned maintenance, and might be running and older version of Shaken Fist upon their return than other members of the cluster.</p>"},{"location":"operator_guide/upgrades/#upgrade-process","title":"Upgrade process","text":"<p>First off, upgrade the python packages in each node's virtualenv manually. This is explicitly a non-goal of our installer tooling as we believe different deployments will have different strategies for performing this step. Naively, a good first approach is simple to run this command on each node:</p> <pre><code>sudo /srv/shakenfist/venv/bin/pip install --upgrade shakenfist\n</code></pre> <p>Which will pull in all the relevant other python packages it requires.</p> <p>Then simply re-run <code>getsf</code> as you did when you first installed and the cluster will upgrade.</p>"},{"location":"operator_guide/networking/overview/","title":"Explaining Shaken Fist networking","text":"<p>Shaken Fist networking is complicated, but not as complicated as OpenStack Neutron -- its more like the old OpenStack Compute nova-network implementation if you're looking for a mental model. Let's work through some examples to explain what it is doing.</p>"},{"location":"operator_guide/networking/overview/#single-node-install-no-networks-or-instances","title":"Single node install, no networks or instances","text":"<pre><code>debian@test:~$ ip a\n1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000\nlink/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n    inet 127.0.0.1/8 scope host lo\n       valid_lft forever preferred_lft forever\n2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 8950 qdisc pfifo_fast state UP group default qlen 1000\nlink/ether 02:00:00:00:0e:a3 brd ff:ff:ff:ff:ff:ff\n    altname enp0s11\n    altname ens11\n    inet 10.0.0.74/24 brd 10.0.0.255 scope global eth0\n       valid_lft forever preferred_lft forever\n3: egr-br-eth0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN group default qlen 1000\nlink/ether f6:d1:c6:05:15:fd brd ff:ff:ff:ff:ff:ff\n    inet 192.168.15.1/24 scope global egr-br-eth0\n       valid_lft forever preferred_lft forever\n</code></pre> <p>Explaining this:</p> <ul> <li><code>lo</code> is the loopback interface, and not relevant here.</li> <li><code>eth0</code> is the primary interface for the machine, and <code>10.0.0.74</code> is the IP   address of the machine.</li> <li><code>egr-br-eth0</code> is a linux bridge that is currently empty and has the IP   <code>192.168.15.1</code>, which is the first IP on this cluster's floating network.   Networks will get attached</li> </ul>"},{"location":"operator_guide/networking/overview/#single-node-install-one-network-and-no-instances","title":"Single node install, one network and no instances","text":"<p>Let's make a network, but not put any instances on it yet:</p> <pre><code>debian@test:~$ sf-client network create demo 172.16.0.0/24\nuuid            : 17be6538-8f96-4ccb-b71e-a7e3022fead3\nname            : demo\nvxlan id        : 14823439\nnetblock        : 172.16.0.0/24\nprovide dhcp    : True\nprovide nat     : True\nfloating gateway: 192.168.15.194\nnamespace       : system\nstate           : created\n\nMetadata:\n\ndebian@test:~$ ip a\n1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000\nlink/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n    inet 127.0.0.1/8 scope host lo\n       valid_lft forever preferred_lft forever\n2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 8950 qdisc pfifo_fast state UP group default qlen 1000\nlink/ether 02:00:00:00:0e:a3 brd ff:ff:ff:ff:ff:ff\n    altname enp0s11\n    altname ens11\n    inet 10.0.0.74/24 brd 10.0.0.255 scope global eth0\n       valid_lft forever preferred_lft forever\n3: egr-br-eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 1000\nlink/ether f6:d1:c6:05:15:fd brd ff:ff:ff:ff:ff:ff\n    inet 192.168.15.1/24 scope global egr-br-eth0\n       valid_lft forever preferred_lft forever\n10: vxlan-e2300f: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 8900 qdisc noqueue master br-vxlan-e2300f state UNKNOWN group default qlen 1000\nlink/ether 6a:c0:ee:6f:83:6f brd ff:ff:ff:ff:ff:ff\n11: br-vxlan-e2300f: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 8900 qdisc noqueue state UP group default qlen 1000\nlink/ether 8a:a6:8d:31:c9:09 brd ff:ff:ff:ff:ff:ff\n13: veth-e2300f-o@if12: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 8900 qdisc noqueue master br-vxlan-e2300f state UP group default qlen 1000\nlink/ether 6e:34:bc:25:68:c2 brd ff:ff:ff:ff:ff:ff link-netns 17be6538-8f96-4ccb-b71e-a7e3022fead3\n15: egr-e2300f-o@if14: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master egr-br-eth0 state UP group default qlen 1000\nlink/ether 5a:9c:f3:eb:2f:bc brd ff:ff:ff:ff:ff:ff link-netns 17be6538-8f96-4ccb-b71e-a7e3022fead3\n</code></pre> <p>Here, we allocated a network, which was assigned VXLAN id 14823439 (<code>e2300f</code> in hexadecimal). That created a VXLAN interface named <code>vxlan-e2300f</code> on the machine, which is where other machines in a multinode cluster would attach for the VXLAN mesh which forms our virtual network. <code>br-vxlan-e2300f</code> is a linux bridge used to attach the local network namespace for this network to the VXLAN interface. That is, the members of the bridge look like this:</p> <pre><code>debian@test:~$ sudo brctl show br-vxlan-e2300f\nbridge name         bridge id           STP enabled     interfaces\nbr-vxlan-e2300f     8000.8aa68d31c909   no              veth-e2300f-o\n                                                        vxlan-e2300f\n</code></pre> <p>Similarly, the egress bridge <code>egr-br-eth0</code> now contains a veth as well:</p> <pre><code>debian@test:~$ sudo brctl show egr-br-eth0\nbridge name         bridge id           STP enabled     interfaces\negr-br-eth0         8000.f6d1c60515fd   no              egr-e2300f-o\n</code></pre> <p>And there is a linux network namespace named with the UUID of the network:</p> <pre><code>debian@test:~$ ls /var/run/netns/\n17be6538-8f96-4ccb-b71e-a7e3022fead3\n</code></pre> <p>That linux network namespace contains the other ends of the veths:</p> <pre><code>debian@test:~$ sudo ip netns exec 17be6538-8f96-4ccb-b71e-a7e3022fead3 ip a\n1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN group default qlen 1000\nlink/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n12: veth-e2300f-i@if13: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 1000\nlink/ether 36:da:87:ea:ce:16 brd ff:ff:ff:ff:ff:ff link-netnsid 0\ninet 172.16.0.1/24 scope global veth-e2300f-i\n       valid_lft forever preferred_lft forever\n    inet6 fe80::34da:87ff:feea:ce16/64 scope link\n       valid_lft forever preferred_lft forever\n14: egr-e2300f-i@if15: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 1000\nlink/ether d2:b0:c8:31:f4:83 brd ff:ff:ff:ff:ff:ff link-netnsid 0\ninet 192.168.15.194/24 scope global egr-e2300f-i\n       valid_lft forever preferred_lft forever\n    inet6 fe80::d0b0:c8ff:fe31:f483/64 scope link\n       valid_lft forever preferred_lft forever\n</code></pre> <p>This network namespace exists to contain a <code>dnsmasq</code> process providing DHCP to the virtual network, as well as to contain routing and iptables rules for mangling traffic into and out of the virtual network.</p> <p>Specifically, NAT for traffic from the virtual network to the outside world is implemented with routing and iptables like this:</p> <pre><code>debian@test:~$ sudo ip netns exec 17be6538-8f96-4ccb-b71e-a7e3022fead3 ip route\ndefault via 192.168.15.1 dev egr-e2300f-i\n172.16.0.0/24 dev veth-e2300f-i proto kernel scope link src 172.16.0.1\n192.168.15.0/24 dev egr-e2300f-i proto kernel scope link src 192.168.15.194\n\ndebian@test:~$ sudo ip netns exec 17be6538-8f96-4ccb-b71e-a7e3022fead3 iptables -L -t nat\nChain PREROUTING (policy ACCEPT)\ntarget     prot opt source               destination\n\nChain INPUT (policy ACCEPT)\ntarget     prot opt source               destination\n\nChain OUTPUT (policy ACCEPT)\ntarget     prot opt source               destination\n\nChain POSTROUTING (policy ACCEPT)\ntarget     prot opt source               destination\nMASQUERADE  all  --  172.16.0.0/24        anywhere\n</code></pre> <p>So, the default route is via the egress veth at <code>egr-e2300f-i</code> (inside the namespace), which comes out on <code>egr-br-eth0</code> (outside the namespace) to be routed as normal. Traffic to other machines participating in this virtual network (that is, with the same VXLAN id configured), is routed to <code>veth-e2300f-i</code> (inside the namespace) which comes out on the <code>br-vxlan-e2300f</code> (outside the namespace) bridge which is wired to the linux kernel VXLAN interface at <code>vxlan-e2300f</code>. Finally, traffic to other floating IPs on <code>192.168.15.0/24</code> is routed to the egress bridge as well.</p> <p>The iptables <code>MASQUERADE</code> entry is there to convert internal addresses to the external <code>192.168.15.194</code> \"floating gateway\" address so instances can talk outside their virtual network.</p> <p>Perhaps a diagram would help!</p> <p></p>"},{"location":"operator_guide/networking/overview/#single-node-install-one-network-and-one-instance-with-no-floating-ip","title":"Single node install, one network and one instance with no floating IP","text":"<p>Now let's create a single instance on that network, with the instance specifically not having a floating IP:</p> <pre><code>debian@test:~$ sf-client instance create demo 1 1024 -d 10@debian:11 -n demo\nuuid          : 3b9c13ee-405f-4195-b904-cffb34e022d3\n...\n\nInterfaces:\n\n    uuid    : afc470fb-8348-4711-8c16-be4c4662d705\n    network : 17be6538-8f96-4ccb-b71e-a7e3022fead3\n    macaddr : 02:00:00:bd:cd:9b\n    order   : 0\nipv4    : 172.16.0.232\n    floating: None\n    model   : virtio\n...\n</code></pre> <p>There is only one new outer network interface created by adding the instance:</p> <pre><code>debian@test:~$ ip a\n...\n16: vnet0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 8900 qdisc noqueue master br-vxlan-e2300f state UNKNOWN group default qlen 1000\nlink/ether fe:00:00:bd:cd:9b brd ff:ff:ff:ff:ff:ff\n</code></pre> <p><code>vnet0</code> is a libvirt construct to attach the virtual machine's network interface to the host OS. We attach that interface to the bridge that is the virtual network for this machine, in this case <code>br-vxlan-e2300f</code>:</p> <pre><code>debian@test:~$ sudo brctl show br-vxlan-e2300f\nbridge name         bridge id           STP enabled     interfaces\nbr-vxlan-e2300f     8000.8aa68d31c909   no              veth-e2300f-o\n                                                        vnet0\n                                                        vxlan-e2300f\n</code></pre> <p>There are no changes to the inside of the network namespace for this VM -- the <code>dnsmasq</code> process for example is already connected to the virtual network by virtue of the <code>veth-e2300f</code> pair and can therefore provide DHCP to the instance.</p> <p>Again perhaps a diagram will help:</p> <p></p> <p>This instance is not accessible from outside our virtual network as it does not have a floating IP. It can however talk to the outside world because our virtual network has NAT enabled. This is done by routing the traffic from <code>vnet0</code> to the virtual network's network namespace, where the iptables <code>MASQUERADE</code> rule will then NAT the traffic out.</p> <p>We can show this NAT traffic like this:</p> <p></p>"},{"location":"operator_guide/networking/overview/#single-node-install-one-network-and-one-instance-with-no-floating-ip_1","title":"Single node install, one network and one instance with no floating IP","text":"<p>Let's add a second instance, but this time with a floating IP associated with it:</p> <pre><code>debian@test:~$ sf-client instance create floatingdemo 1 1024 -d 10@debian:11 -f demo\nuuid          : 08c0ae07-6a4b-4f63-9d50-a172039091a0\n...\n\nInterfaces:\n\n    uuid    : a4cfa174-cce9-4cda-907a-b90d7f54efd1\n    network : 17be6538-8f96-4ccb-b71e-a7e3022fead3\n    macaddr : 02:00:00:c7:f9:cc\n    order   : 0\nipv4    : 172.16.0.37\n    floating: 192.168.15.29\n    model   : virtio\n...\n</code></pre> <p>Again we add a <code>vnet</code> device via libvirt:</p> <pre><code>debian@test:~$ ip a\n...\n17: vnet1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 8900 qdisc noqueue master br-vxlan-e2300f state UNKNOWN group default qlen 1000\nlink/ether fe:00:00:c7:f9:cc brd ff:ff:ff:ff:ff:ff\n19: flt-c0a80f1d-o@if18: &lt;BROADCAST,MULTICAST&gt; mtu 8900 qdisc noop state DOWN group default qlen 1000\nlink/ether aa:5c:1c:0c:7c:f6 brd ff:ff:ff:ff:ff:ff link-netns 17be6538-8f96-4ccb-b71e-a7e3022fead3\n</code></pre> <p>But we've also added another veth pair, this time named <code>flt-c0a80f1d-o</code> on the outside of the network namespace. You can see in the instance details above that the floating IP associated with this instance is <code>192.168.15.29</code>, which just so happens to be <code>c0a80f1d</code> in hexadecimal. So this veth is how floating IP traffic is delivered to an instance.</p> <p>Here's another diagram showing the new setup:</p> <p></p> <p>Its important to note that traffic from the instance still goes via the NAT route shown above, while traffic to the instance via the floating IP uses this veth. Replies to floating IP requests return via this veth as well though.</p> <p>The instance isn't aware of its floating IP at an operating system level at all. That is, inside the network namespace the veth attaches to, we do DNAT to mangle the traffic to the instance:</p> <pre><code>debian@test:~$ sudo ip netns exec 17be6538-8f96-4ccb-b71e-a7e3022fead3 iptables -L -t nat\nChain PREROUTING (policy ACCEPT)\ntarget     prot opt source               destination\nDNAT       all  --  anywhere             192.168.15.29        to:172.16.0.37\n\nChain INPUT (policy ACCEPT)\ntarget     prot opt source               destination\n\nChain OUTPUT (policy ACCEPT)\ntarget     prot opt source               destination\n\nChain POSTROUTING (policy ACCEPT)\ntarget     prot opt source               destination\nMASQUERADE  all  --  172.16.0.0/24        anywhere\n</code></pre> <p>So our floating IP of <code>192.168.15.29</code> is DNAT'ed to the instance's IP of <code>172.16.0.37</code>. This means floating IP traffic \"bounces\" off the network namespace. To make that work, the inside of the veth is configured with the floating IP:</p> <pre><code>debian@test:~$ sudo ip netns exec 17be6538-8f96-4ccb-b71e-a7e3022fead3 ip a\n...\n18: flt-c0a80f1d-i@if19: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN group default qlen 1000\nlink/ether fe:cb:4c:4a:17:ef brd ff:ff:ff:ff:ff:ff link-netnsid 0\ninet 192.168.15.29/32 scope global flt-c0a80f1d-i\n       valid_lft forever preferred_lft forever\n</code></pre> <p>Note the <code>/32</code> netmask for that address assignment. Notably, the routing table for the outer linux still looks like this:</p> <pre><code>debian@test:~$ ip route\ndefault via 10.0.0.1 dev eth0\n10.0.0.0/24 dev eth0 proto kernel scope link src 10.0.0.74\n192.168.15.0/24 dev egr-br-eth0 proto kernel scope link src 192.168.15.1\n</code></pre> <p>The outer linux knows to route the floating IP down that veth because of this address assigned on the inside of the namespace.</p> <p>Let's have a final diagram showing how a packet for a floating IP gets to its instance:</p> <p></p>"},{"location":"operator_guide/networking/overview/#multiple-nodes","title":"Multiple nodes","text":"<p>Its actually a relatively small step from the above to multiple hypervisor nodes, as additional nodes don't have the network namespace or the veths -- those exist only on the network node (node 1 in our example).</p> <p></p>"},{"location":"operator_guide/networking/overview/#routed-ips","title":"Routed IPs","text":"<p>Shaken Fist v0.8 introduced the concept of routed IPs to support Kubernetes services in the K3S orchestration support. A routed IP is an address from the floating address pool which uses routing to deliver traffic to the relevant virtual network. An interface on the virtual network must then have been configured by the user to answer ARP requests for that address. This works well with metallb, which our K3S orchestration uses to expose services, but would work equally well for other traffic.</p> Tip <p>The fundamental difference between a floating IP and a routed IP is whether the destination of the traffic inside the virtual network is aware of the address. A floating IP is packet mangled on its way to an interface so that the interface can't tell that the traffic was sent to a floating IP. On the other hand, an interface with a routed address can tell that the traffic was intended for a specific floating IP, but in return must have been configured to use that floating IP.</p> <p>The implementation of routed IPs is relatively trivial. For each routed IP, a route on the network node into the relevant virtual network bridge is created. Such a route might look like this:</p> <pre><code>ip route add 192.168.15.29/32 dev br-vxlan-e2300f\n</code></pre>"},{"location":"release_notes/v07-v08/","title":"v0.7 to v0.8 release notes","text":""},{"location":"release_notes/v07-v08/#major-changes","title":"Major changes","text":"<ul> <li>You can now hot plug (add) a network interface to a running instance. This is   exposed by a POST to the <code>/instance/...instanceref.../interfaces</code> endpoint, passing   a network specification like you would at boot time. More details are available   in the</li> <li>The Shaken Fist client now has a plugin system, which allows additional commands   that may not be of interest to all users to be added without cluttering the   main codebase. Orchestration of k3s clusters via the <code>shakenfist-client-k3s</code>   plugin is the first example of one of these plugins.</li> <li>You can now optionally have DNS entries for the instances in a virtual network   provided to the instances on that network via the <code>provide_dns</code> argument on   network creation.</li> </ul>"},{"location":"release_notes/v07-v08/#rest-api","title":"REST API","text":"<ul> <li>There is now an API call (<code>GET /admin/resources</code>) which exposes the resource   utilization of the cluster to admin users.</li> <li>You can now POST to <code>/instance/...instanceref.../interfaces</code> as described   above to hot plug new network interfaces into an existing instance.</li> </ul>"},{"location":"release_notes/v07-v08/#supported-distributions","title":"Supported distributions","text":"<ul> <li>Debian 12 is now supported as a host OS.</li> <li>Ubuntu 22.04 is now supported as a host OS.</li> <li>Fedora 34, 38, and 29, as well as Ubuntu 22.04 now have canned guest images.</li> <li>Rocky 8 and 9 now have canned guest images.</li> </ul>"},{"location":"release_notes/v07-v08/#logging","title":"Logging","text":"<ul> <li>REST API request traces are now logged via the event logging mechanism with   the object type \"api-requests\" and the UUID being the request id.</li> </ul>"},{"location":"release_notes/v07-v08/#containers-and-kubernetes","title":"Containers and Kubernetes","text":"<ul> <li>The Shaken Fist client can now orchestrate k3s Kubernetes clusters for you. The   lifecycle support is relatively simple at the moment, with cluster creation and   deletion supported, as well as fetching the kubectl configuration from the   cluster. This will be expanded over time. This support is implemented entirely   in the Shaken Fist python client, and heavily utilizes the in guest agent   added in v0.7. The client side nature of the orchestration makes it easy for you   to customize the orchestration if desired without having to alter the main   server code.</li> </ul>"},{"location":"release_notes/v07-v08/#networking","title":"Networking","text":"<ul> <li>IP address management has moved to a new baseobject called IPAM. Events are   therefore recorded for address management as you would expect.</li> <li>Addresses released on any network (including the floating network) are now   quarantined for <code>IP_DELETION_HALO_DURATION</code> seconds after deletion before they   can be reused. The only exception to this is if a network is heavily congested   and an allocation attempt will fail. In that case the halo is temporarily   reduced to 30 seconds and a warning log message is emitted.</li> <li>You can now list the addresses in use for a given network with the   <code>sf-client network addresses ...uuid...</code> command.</li> <li>In order to support the K3S Kubernetes orchestration, the concept of routed   IPs was introduced. A routed IP is an address from the floating address pool   which uses routing to deliver traffic to the relevant virtual network. An   interface on the virtual network must then have been configured by the user to   answer ARP requests for that address. This works well with metallb, which our   K3S orchestration uses to expose services.</li> <li>Network orchestration now waits for <code>iptables</code> locks, instead of failing   commands in high load situations.</li> </ul>"},{"location":"release_notes/v07-v08/#instances","title":"Instances","text":"<ul> <li>Shaken Fist can now capture screenshots of instance consoles.</li> <li>Pause and unpause are now retried several times on failure, as sometimes libvirt   does not respond correctly.</li> <li>Specifying an incorrect disk bus now returns a more helpful error.</li> <li>Power on now implies creation of a config drive is one is specified for the   instance. That is, you can force re-creation of the config drive by powering   an instance off and then on again.</li> </ul>"},{"location":"release_notes/v07-v08/#artifacts","title":"Artifacts","text":"<ul> <li>When you refer to an artifact by name, and there is more than one match then   the match in your local namespace (if any) is now preferred instead of returning   an error.</li> </ul>"},{"location":"release_notes/v07-v08/#deployment","title":"Deployment","text":"<ul> <li>We no longer reset the authentication secret used to generate authentication   tokens on upgrade. This means tokens from before an upgrade will continue to work   for their normal lifetime.</li> <li>We now lock versions of upstream Ansible Galaxy dependencies.</li> <li>We now lock versions of all of our indirect python dependencies.</li> <li>Nodes can now transition directly from the missing state to the stopping state.</li> <li>The Ansible modules have been re-written to skip resources that are already in   existence and ask described by your request. The Ansible module is also now   documented at the user guide.</li> <li>TLS certificates on hypervisors which are within 30 days of expiry are now   automatically replaced.</li> </ul>"},{"location":"release_notes/v07-v08/#performance","title":"Performance","text":"<ul> <li>Events are no longer queued via etcd unless the eventlog node is down at the   time of the event. This reduces the number of etcd writes significantly during   CI runs and therefore improves the reliability of etcd. The new approach is   to make gRPC calls directly to the eventlog node if it is available.</li> <li>We now use gRPC calls to compact etcd, instead of relying on a python client   wrapper. This means we can now update our gRPC and protobuf dependencies to   much more recent versions.</li> <li>etcd traffic levels are now monitored in CI and we attempt to hold fewer   cluster level locks for local operations.</li> </ul>"},{"location":"release_notes/v07-v08/#minor-changes","title":"Minor changes","text":"<ul> <li>CI has been moved from relatively unreliable scraping of the instance serial   console over telnet to using the Shaken Fist in-guest agent to inspect the   state of instances for correctness.</li> <li>The slow lock warning threshold is no longer configurable (SLOW_LOCK_THRESHOLD).   Instead, a warning is emitted if a lot takes more than half of the specified   timeout period to be acquired. This change was made because in some places we   expect to wait a long time for a lock -- for example serialized fetches of a   single resource from outside the cluster, but we also wanted to enforce locks   didn't take a long time to acquire in CI.</li> <li>Shaken Fist now uses <code>Renovate</code> to keep the dependencies of the <code>develop</code>   branch up to date. This means that locking requirements at release time is no   longer required, and is therefore more reliable.</li> <li>The <code>qemu</code> commands generated now vary based on the version of <code>qemu</code> installed   on the machine. This was required to support the newer <code>qemu</code> version in   Ubuntu 22.04.</li> <li>The ansible modules have been rewritten to be more reliable.</li> </ul>"},{"location":"user_guide/affinity/","title":"Affinity","text":"<p>There are times when you want to express a preference (or anti-preference) for two instances sharing a hypervisor. For example, you might have two IO intensive instances and want to keep them apart, or you might have two instances which talk a lot over the network to each other and want to keep them together.</p> <p>Shaken Fist supports a simple affinity system for this use case. The system is built on top of an instance metadata entry called <code>tags</code>, where you specify the attributes of the instance. This metadata entry must be formatted as a valid JSON list. So for example we might set the following simple tag on an instance:</p> <pre><code>[\"webserver\"]\n</code></pre> <p>Or on the command line:</p> <p><code>sf-client instance set-metadata ...uuid... tags '[\"webserver\"]'</code></p> <p>Affinity is then set via the <code>affinity</code> metadata entry, and consists of a JSON dictionary specifying the weight to give to a given tag in scheduling decisions. In our current example, let's say we want to try quite hard to not have more than one of our web servers on a given hypervisor. We might therefore write an affinity metadata entry like this:</p> <pre><code>{\n    \"webserver\": -10\n}\n</code></pre> <p>Or on the command line:</p> <p><code>sf-client instance set-metadata ...uuid... affinity '{\"webserver\": -10}'</code></p> <p>There are no fixed rules for what the maximum and minimum numbers for this preference value are, although generally we recommend they range from -100 to 100, where 100 means you'd really really love to be on the same hypervisor, and -100 means you'd be very unhappy to be on the same hypervisor.</p> Info <p>Under the hood, Shaken Fist filters possible candidate hypervisors based on the affinity coefficients specified. Only tags from within your namespace are considered for this filtration. This decision is only made on the original start up of an instance, and does not apply later. That is, if you change the tags or affinity of an instance after instance creation it will not affect that instance in any way, although it might affect scheduling decisions for future instances.</p> <p>You can of course have more than one tag and affinity preference set at a time. So to extend our example, let's say that web servers do not prefer sharing with other web servers, but do like sharing with a cache server. You might write that like this:</p> <pre><code>{\n    \"webserver\": -10,\n    \"cache\": 10\n}\n</code></pre> <p>Or on the command line:</p> <p><code>sf-client instance set-metadata ...uuid... affinity '{\"webserver\": -10, \"cache\": 10}'</code></p> <p>Shaken Fist emits a series of events while making a scheduling decision for an instance, and those events are useful for debugging affinity operations. You can see the events for an instance with this command:</p> <p><code>sf-client instance events ...uuid...</code></p> <p>You can of course see the currently set metadata for an instance with the <code>sf-client instance show</code> command.</p>"},{"location":"user_guide/ansible/","title":"Ansible module","text":"<p>The Shaken Fist Ansible modules were re-written in v0.8. This documentation covers that newer version.</p>"},{"location":"user_guide/ansible/#installation","title":"Installation","text":"<p>The Shaken Fist command line client also ships with an Ansible module for orchestration of cloud resources. <code>getsf</code> installs this in the right place on the primary node, but its likely that you'll need to hand install the module code on other client machines.</p> <pre><code>$ sudo pip3 install shakenfist-client\n$ sudo cp venv/share/shakenfist/ansible/* /usr/share/ansible/plugins/modules/\n$ sudo chmod 0644 /usr/share/ansible/plugins/modules/sf_*\n</code></pre> Note <p>This example installs the Shaken Fist client in the system pip so that it is globally available to all Ansible users. The system pip is protected on modern Linux distributions, and you may need to include the <code>--break-system-packages</code> flag if your chosen Linux distribution does not package the Shaken Fist client.</p> <p>You'll know you need to do this if you see an error like this:</p> <pre><code>$ sudo pip3 install shakenfist-client\nerror: externally-managed-environment\n\n\u00d7 This environment is externally managed\n\u2570\u2500&gt; To install Python packages system-wide, try apt install\n    python3-xyz, where xyz is the package you are trying to\n    install.\n\n    If you wish to install a non-Debian-packaged Python package,\n    create a virtual environment using python3 -m venv path/to/venv.\n    Then use path/to/venv/bin/python and path/to/venv/bin/pip. Make\n    sure you have python3-full installed.\n\n    If you wish to install a non-Debian packaged Python application,\n    it may be easiest to use pipx install xyz, which will manage a\n    virtual environment for you. Make sure you have pipx installed.\n\n    See /usr/share/doc/python3.11/README.venv for more information.\n\nnote: If you believe this is a mistake, please contact your Python\ninstallation or OS distribution provider. You can override this, at\nthe risk of breaking your Python installation or OS, by passing\n--break-system-packages.\nhint: See PEP 668 for the detailed specification.\n</code></pre>"},{"location":"user_guide/ansible/#implementation","title":"Implementation","text":"<p>Ansible modules can be written in any language, although they are normally in python. In order to centralize the code for our Ansible module, the module files you install are simple <code>bash</code> redirects to the Shaken Fist command line client. The client then does the right things to make the module work correctly.</p> Note <p>Specifically, the command line <code>sf-client ansible ...</code> is what the bash redirect scripts use. The ansible command line module appears in help output for the command line client, but is not intended for direct user use.</p>"},{"location":"user_guide/ansible/#namespaces","title":"Namespaces","text":""},{"location":"user_guide/ansible/#parameters","title":"Parameters","text":"Parameter Comments namestring The name of the namespace. This must always be specified. statestring The state of the resource. Valid states are <code>present</code> or <code>absent</code>, defaults to <code>present</code>."},{"location":"user_guide/ansible/#return-value","title":"Return value","text":"<p>Unless an error is experienced the full REST API information for the namespace is returned in a dictionary element called <code>meta</code>. An example returned dictionary is:</p> <pre><code>{\n    \"changed\": true,\n    \"failed\": false,\n    \"log\": [...],\n    \"meta\": {\n        \"keys\": [],\n        \"metadata\": {},\n        \"name\": \"ci-003-peephie6Oo\",\n        \"state\": \"created\",\n        \"trust\": {\n            \"full\": [\n                \"system\"\n            ]\n        },\n        \"version\": 5\n    },\n    \"msg\": null\n}\n</code></pre>"},{"location":"user_guide/ansible/#examples","title":"Examples","text":"<p>Create a namespace:</p> <pre><code>- name: Create a namespace\nsf_namespace:\nname: \"{{ namespace_name }}\"\nstate: present\n</code></pre> <p>Delete a network:</p> <pre><code>- name: Delete the namespace\nsf_namespace:\nuuid: \"{{ namespace_name }}\"\nstate: absent\n</code></pre>"},{"location":"user_guide/ansible/#networks","title":"Networks","text":""},{"location":"user_guide/ansible/#parameters_1","title":"Parameters","text":"Parameter Comments dhcpboolean Whether to provide DHCP services on the network. Defaults to <code>true</code>. Changing this value from what is present in the Shaken Fist cluster if the network already exists implies re-creation of the network. namestring The name of the network. Either <code>name</code> or <code>uuid</code> must be included in all requests. When both <code>name</code> and <code>uuid</code> are specified, <code>uuid</code> is used for existing resource lookups. If a network is identified by its <code>uuid</code>, then the network will be recreated if you specify a <code>name</code> which does not match the network in the Shaken Fist cluster. natboolean Whether to provide NAT services on the network. Defaults to <code>true</code>. Changing this value from what is present in the Shaken Fist cluster if the network already exists implies re-creation of the network. statestring The state of the resource. Valid states are <code>present</code> or <code>absent</code>, defaults to <code>present</code>. uuidstring The UUID for the network. Either <code>name</code> or <code>uuid</code> must be included in all requests with <code>state: absent</code>. If you specify a UUID and the network does not exist in the Shaken Fist cluster, this argument will be ignored as UUIDs are randomly assigned on network creation."},{"location":"user_guide/ansible/#return-value_1","title":"Return value","text":"<p>Unless an error is experienced the full REST API information for the network is returned in a dictionary element called <code>meta</code>. An example returned dictionary is:</p> <pre><code>{\n    'changed': False,\n    'failed': False,\n    \"log\": [...],\n    'msg': None,\n    'meta': {\n        'floating_gateway': '192.168.10.230',\n        'metadata': {},\n        'name': 'ci',\n        'namespace': 'system',\n        'netblock': '10.0.0.0/24',\n        'provide_dhcp': True,\n        'provide_nat': True,\n        'provide_dns': False,\n        'state': 'created',\n        'uuid': 'a8a52ac5-49b6-4444-80d0-3ab6573343ad',\n        'version': 4,\n        'vxid': 1436254\n    }\n}\n</code></pre>"},{"location":"user_guide/ansible/#examples_1","title":"Examples","text":"<p>Create a network:</p> <pre><code>- name: Create a network for CI infrastructure\nsf_network:\nnetblock: \"10.0.0.0/24\"\nname: \"ci\"\nregister: ci_network\n</code></pre> <p>Delete a network:</p> <pre><code>- name: Delete the CI network\nsf_network:\nuuid: \"{{ ci_network['meta']['uuid'] }}\"\nstate: absent\n</code></pre>"},{"location":"user_guide/ansible/#instances","title":"Instances","text":""},{"location":"user_guide/ansible/#parameters_2","title":"Parameters","text":"Parameter Comments cpuinteger The number of vCPUs the instance should have. diskslist of strings A simpler format for specifying what disks an instance has that follows the same behaviour as the <code>-d</code> flag in the command line client. Specifications are of the form: <code>size@base</code> where base is optional and size is in GB. That is, <code>100@debian:11</code> is valid, but so is <code>100</code> for an empty 100gb disk. diskspecslist of strings A more verbose format for specifying what disks an instance has that models the <code>-D</code> flag in the command line client. Specifications are of the form: <code>size=20,base=debian:11,bus=sata;type=cdrom</code> where all elements are optional except for <code>size</code>. A more complete definition of this format is in the developer reference documentation. namestring The name of the instance. Either <code>name</code> or <code>uuid</code> must be included in all requests. When both <code>name</code> and <code>uuid</code> are specified, <code>uuid</code> is used for existing resource lookups. If a instance is identified by its <code>uuid</code>, then the instance will be recreated if you specify a <code>name</code> which does not match the instance in the Shaken Fist cluster. raminteger The amount of RAM the instance should have, in MB. statestring The state of the resource. Valid states are <code>present</code> or <code>absent</code>, defaults to <code>present</code>. uuidstring The UUID for the instance. Either <code>name</code> or <code>uuid</code> must be included in all requests with <code>state: absent</code>. If you specify a UUID and the instance does not exist in the Shaken Fist cluster, this argument will be ignored as UUIDs are randomly assigned on network creation. awaitboolean Whether to wait for the instance to be created. Only works for when state is <code>present</code>. Default is <code>false</code>. await_timeoutinteger How many seconds to wait in an <code>await</code>. Defaults to 600."},{"location":"user_guide/artifacts/","title":"Artifacts","text":"<p>Shaken Fist uses artifacts as disk templates for new instances. You therefore need to have a least one artifact before you can create your first instance, although there is a shorthand notation to create that artifact during instance creation.</p> <p>The following artifact types exist:</p> <ul> <li>images: these are generally downloaded from the Internet, although they can   also be created via an upload mechanism (see the artifact uploads section below   for a detailed introduction to uploading images to the cluster).</li> <li>snapshots: these are created by taking a copy of the disk(s) of a running   instance.</li> <li>labels: labels are a bit like symbolic links, although they still have   versioning like other forms of artifact.</li> <li>other: a catch all for artifacts which don't fall into any of the other   categories. For example captured instance console output archived after an   instance was deleted.</li> </ul> <p>Behind the scenes, artifacts are references to blobs. You can think of them as symlinks if you'd like. All types of artifact support versioning. This is implemented by having each artifact have a list of blobs. You can see this in the output of a <code>sf-client artifact show ...</code> command:</p> <pre><code>$ sf-client artifact show 3420f4ac-529a-4b34-b8d8-c05a838b9e0c\nuuid                     : 3420f4ac-529a-4b34-b8d8-c05a838b9e0c\nnamespace                : ci-images\ntype                     : label\nstate                    : created\nsource url               : sf://label/ci-images/debian-11\ncurrent version blob uuid: cc6a6a96-8182-474a-ab31-45f1f9310b44\nnumber of versions       : 3\nmaximum versions         : 3\nshared                   : False\n\nVersions:\n    4  : blob f6090574-321c-4dec-b381-0caf001eeba5 is 2964.1MB\n    5  : blob 77b9032a-0d3e-4cc2-bb73-1730ad3c3cb0 is 2960.1MB\n    6  : blob cc6a6a96-8182-474a-ab31-45f1f9310b44 is 2950.4MB in use by\n         instances 78d566f1-c664-46d9-aa46-cf717aa63743\n</code></pre> <p>Here we can see a few things:</p> <ul> <li>The artifact is a label in the ci-images namespace.</li> <li>There is a source URL, which is how you would reference this artifact when   starting an instance.</li> <li>There are three versions of the artifact currently stored (<code>number of versions</code>),   which is the maximum (<code>maximum versions</code>). However, there have been six versions   of this artifact ever (as shown by the indices of the versions being 4, 5, and   6).</li> <li>The most recent version is currently in use by an instance.</li> </ul>"},{"location":"user_guide/artifacts/#creating-an-image-artifact","title":"Creating an image artifact","text":"<p>Image artifacts are created by specifying the URL of an image to download. This can be either in the form of an explicit request to cache a URL with a <code>sf-client artifact cache</code> command, or implied by specifying the URL of the image in the specification for an instance.</p> <p>There is also a shorthand form of image URLs where you are using an image from https://images.shakenfist.com -- in that case you can use urls like <code>debian:11</code> so specify the latest version of a Debian 11 base image. The valid shorthands are those listed in the top level directory listing of that site. At the time of writing this is:</p> <ul> <li>centos (shorthand for centos:8-stream)</li> <li>centos:7</li> <li>centos:8-stream</li> <li>centos:9-stream</li> <li>debian (shorthand for debian:12)</li> <li>debian:10</li> <li>debian:11</li> <li>debian:12</li> <li>debian-docker:11 (debian 11 with docker pre-installed)</li> <li>debian-docker:12 (debian 12 with docker pre-installed)</li> <li>debian-gnome:11 (debian 11 with the gnome desktop pre-installed)</li> <li>debian-gnome:12 (debian 12 with the gnome desktop pre-installed)</li> <li>debian-xfce:11 (debian 11 with the xfce desktop pre-installed)</li> <li>debian-xfce:12 (debian 12 with the xfce desktop pre-installed)</li> <li>fedora (shorthand for fedora:40)</li> <li>fedora:34</li> <li>fedora:38</li> <li>fedora:39</li> <li>fedora:40</li> <li>ubuntu (shorthand for ubuntu:24.04)</li> <li>ubuntu:18.04</li> <li>ubuntu:20.04</li> <li>ubuntu:22.04</li> <li>ubnutu:24.04</li> </ul> <p>These images are updated nightly by an automated job from https://github.com/shakenfist/images.</p> <p>Whenever you specify a URL for an image (either a new <code>cache</code> command or at instance start), the URL is checked. If the image has changed a new version is downloaded, otherwise the already cached version is used.</p> <p>You can also create an image artifact by uploading it, but that's complicated enough that its covered separately in the developer guide section on artifacts.</p>"},{"location":"user_guide/artifacts/#creating-a-snapshot-artifact","title":"Creating a snapshot artifact","text":"<p>These are created by the <code>sf-client instance snapshot</code> command. You can specify which disk to snapshot on a multi-disk instance with the <code>--device</code> flag. Repeated snapshots of the same instance will result in multiple versions of the one artifact being created. Note that there is an artifact per device snapshotted, so a single snapshot of a multi-disk instance will create multiple artifacts.</p>"},{"location":"user_guide/artifacts/#creating-label-artifacts","title":"Creating label artifacts","text":"<p>So what's a label? Well downloading new versions of images automatically is great, but what if I want to ensure the version from two weeks ago that I tested is the one I use? Or what if I want to refer to my favourite instance snapshot by something more convenient than a snapshot URL like <code>sf://instance/78d566f1-c664-46d9-aa46-cf717aa63743/vda</code>? Well, labels are the answer to those questions.</p> <p>Labels are artifacts where you specify what the new version should be. So in the download example you'd test an image version and when you decide that its right, you'd add that version's blob UUID to your label of known tested versions.</p> <p>Blobs are reference counted, so even if the image artifact ages out a version, having that version referred to in a label artifact protects it from deletion.</p> <p>An example of labelling a known good version of an artifact would be something like this:</p> <pre><code>$ sf-client artifact show 3420f4ac-529a-4b34-b8d8-c05a838b9e0c\nuuid                     : 3420f4ac-529a-4b34-b8d8-c05a838b9e0c\nnamespace                : ci-images\ntype                     : label\nstate                    : created\nsource url               : sf://label/ci-images/debian-11\ncurrent version blob uuid: cc6a6a96-8182-474a-ab31-45f1f9310b44\nnumber of versions       : 3\nmaximum versions         : 3\nshared                   : False\n\nVersions:\n    4  : blob f6090574-321c-4dec-b381-0caf001eeba5 is 2964.1MB\n    5  : blob 77b9032a-0d3e-4cc2-bb73-1730ad3c3cb0 is 2960.1MB\n    6  : blob cc6a6a96-8182-474a-ab31-45f1f9310b44 is 2950.4MB in use by\n         instances 78d566f1-c664-46d9-aa46-cf717aa63743\n\n...test version 6 with blob UUID cc6a6a96-8182-474a-ab31-45f1f9310b44...\n\n$ sf-client label update my-tested-thing cc6a6a96-8182-474a-ab31-45f1f9310b44\n</code></pre> <p>If the label <code>my-tested-thing</code> does not exist, it will be created the first time you update it.</p>"},{"location":"user_guide/artifacts/#listing-and-deleting-artifacts","title":"Listing and deleting artifacts","text":"<p>Artifacts follow the same user interface patterns as other objects. That is, you can list artifacts with this command:</p> <p><code>sf-client artifact list</code></p> <p>And you can delete artifacts with a command like this:</p> <p><code>sf-client artifact delete ...name.or.uuid...</code></p> <p>Note that deleting an artifact does not necessarily imply deleting the associated blobs. If those blobs are in use by other objects (artifacts, instances, and so on) then they remain stored by the cluster until there are no remaining references.</p> <p>Additionally, you can also delete all artifacts in a given namespace by making a HTTP DELETE request to /artifacts REST API endpoint, which is also provided by the <code>delete_all_artifacts()</code> method in the Python API client. This functionality is not currently exposed in the command line client.</p> <p>Finally, deleting a namespace implies deleting all artifacts within that namespace, so show care when deleting namespaces to ensure they no longer contain any data you are fond of.</p>"},{"location":"user_guide/artifacts/#controlling-the-number-of-versions","title":"Controlling the number of versions","text":"<p>You can also control the number of versions stored by an artifact with the <code>sf-client artifact max-versions</code> command.</p>"},{"location":"user_guide/artifacts/#blob-replication","title":"Blob replication","text":"<p>You can control the number of copies of a given blob are stored in the cluster as well. This protects against machine or disk failures causing data loss. The default number of replicas is 2, but this is not configurable per-blob. It is configured with the <code>BLOB_REPLICATION_FACTOR</code> configuration variable.</p>"},{"location":"user_guide/artifacts/#artifact-uploads-and-downloads","title":"Artifact uploads and downloads","text":"<p>Artifacts may also be uploaded and downloaded. This means you can extract a snapshot from your cluster for offline backup (or movement to another cloud), or upload an image built with a tool like Hashicorp Packer.</p> <p>To upload an artifact, use the <code>sf-client artifact upload</code> command. To download an artifact, use the <code>sf-client artifact download</code> command.</p> <p>Shaken Fist will calculate a checksum for the new blob created by an upload, and if it already has a blob matching that checksum it will only store the data once. This makes uploading a given artifact more than once effectively free apart from a small amount of etcd storage.</p>"},{"location":"user_guide/authentication/","title":"Authentication","text":"<p>While there is a detailed discussion of the Shaken Fist authentication system in the developer guide, that is likely more detail than a day to day user of Shaken Fist is interested in. This page therefore provides the details in a simpler and more direct form.</p> <p>As a user of Shaken Fist, the administrator of the cluster you are using will have created a namespace to contain the resources you create in Shaken Fist. This namespace can have several authentication keys associated with it, which are simply strings you pass to Shaken Fist to prove your identity, much like API keys for GitHub or other web services. Normally your administrator will create a key per user, but its also possible to create a key per system -- there are not real rules imposed by Shaken Fist on when you should create a key not reuse an existing one.</p> <p>For most users, this key will be provided in the form of a file you should place at <code>.shakenfist</code> in your home direct. An example file might be:</p> <pre><code>{\n    \"namespace\": \"mynamespace\",\n    \"key\": \"oisoSe7T\",\n    \"apiurl\": \"https://shakenfist/api\"\n}\n</code></pre> <p>This file specifies your namespace, the key you will use to authenticate, and the location of the API server for that Shaken Fist cluster.</p> <p>Once you have that file in the correct location, the the Shaken Fist command line client and API client will function correctly with no further configuration required.</p>"},{"location":"user_guide/consoles/","title":"Consoles","text":"<p>Shaken Fist supports three types of instance consoles. This page describes each of those consoles and their functionality. Additionally, Shaken Fist can collect screen captures of your instance's consoles, which is also documented here.</p>"},{"location":"user_guide/consoles/#read-only-serial-console","title":"Read only serial console","text":"<p>Similarly to OpenStack, we support requesting a read only copy of the content of the serial console via our REST API. This console is based off a log of console activity, so can return events which have already occurred. You can access the console information from the command line like this:</p> <pre><code>sf-client instance consoledata ca8b3e3b-f681-47a2-99c5-6ddea00cc49f 1000\n[530]: |                       Self-hosted runner registration                        |\n[   74.594732] cloud-init[530]: |                                                                              |\n[   74.596442] cloud-init[530]: --------------------------------------------------------------------------------\n[   74.602452] cloud-init[530]: # Authentication\n[   79.099457] cloud-init[530]: \u221a Connected to GitHub\n[   79.184807] cloud-init[530]: # Runner Registration\n[   80.283666] cloud-init[530]: \u221a Runner successfully added\n[   83.608069] cloud-init[530]: \u221a Runner connection is good\n[   83.609389] cloud-init[530]: # Runner settings\n[   83.615351] cloud-init[530]: \u221a Settings Saved.\n[   86.194598] cloud-init[530]: \u221a Connected to GitHub\n[   87.331467] cloud-init[530]: Current runner version: '2.299.1'\n[   87.333703] cloud-init[530]: 2023-01-21 06:54:11Z: Listening for Jobs\n[   91.102179] cloud-init[530]: 2023-01-21 06:54:15Z: Running job: ubuntu-2004-slim-primary\n</code></pre> <p>The final argument is optional. In this example we are requesting the final 1,000 bytes of console output.</p>"},{"location":"user_guide/consoles/#interactive-serial-console","title":"Interactive serial console","text":"<p>There is also interactive access to that same serial console, although it requires direct network access to the hypervisor node at the moment. If you lookup the instance with a show command, you'll see a \"console port\" listed:</p> <pre><code>sf-client instance show c301ad4a-1ad4-49d7-b1e7-cb08ad3bf23d\nuuid          : c301ad4a-1ad4-49d7-b1e7-cb08ad3bf23d\nname          : sfcbr-s2SXNcZGKaJMywSd\n...\nnode          : sf-2\nconsole port  : 30049\nvdi port      : 37804\n...\n</code></pre> <p>If you telnet to the console port on the hypervisor node's IP, you'll land in an interactive console for the instance. So in this example:</p> <pre><code>telnet sf-2 30049\n</code></pre>"},{"location":"user_guide/consoles/#archival-of-the-serial-console","title":"Archival of the serial console","text":"<p>Optionally, the content of the serial console can be archived when an instance is deleted. This is useful for debugging ephemeral instances which might have been deleted by the time you notice a problem -- for example instances used for Continuous Integration environments.</p> <p>The time the serial console is kept for is configured with the ARCHIVE_INSTANCE_CONSOLE_DURATION configuration variable, which specifies how many days to keep the console for. On instance deletion, the console log is converted to an artifact and stored as any other. These artifacts have type 'other', and will have a source URL in the form of sf://instance/...uuid.../console within the same namespace as the instance. Set ARCHIVE_INSTANCE_CONSOLE_DURATION to 0 to disable this behavior.</p>"},{"location":"user_guide/consoles/#interactive-vdi-console","title":"Interactive VDI console","text":"<p>There is also a graphical console. Similarly to the telnet console, it requires direct network access to the hypervisor node, and is accessed at the \"vdi port\" TCP port. By default this console is SPICE since v0.7, although VNC is also available.</p> <p>You can select from 'vnc' or 'spice' (the default) by setting the <code>vdi</code> argument in your video specification for the instance. If you set <code>vdi=spiceconcurrent</code>, then experimental support for multiple users accessing the same SPICE console at the same time is enabled. For more details about the experimental nature of concurrent SPICE consoles, see https://www.spice-space.org/multiple-clients.html.</p> <p>And example video specification would be:</p> <pre><code>--video model=qxl,memory=65536,vdi=spiceconcurrent\n</code></pre>"},{"location":"user_guide/consoles/#screen-captures","title":"Screen captures","text":"<p>Since v0.78, Shaken Fist also provides an API for collecting screen captures of the console. This works for either serial consoles or graphical consoles, its literally the same was whatever would have been displayed on the monitor if the instance was a physical machine.</p> <p>You can take a screen capture of an instance using the python command line client like this:</p> <pre><code>sf-client instance screenshot ...uuid...\n</code></pre>"},{"location":"user_guide/events/","title":"Events","text":"<p>Events are Shaken Fist's audit log mechanism. Many operations, ranging from creation and subsequent use of an authentication token, to any change in the data for an object, will result in an event being created in the event log for the relevant object. Importantly, regular \"usage events\" are also emitted, which we expect would form the basis for a consumption based billing system.</p> <p>Events may be requested using the <code>sf-client ...object... events</code> command, for example <code>sf-client artifact events ...uuid...</code> will return the events for the relevant artifact.</p> <p>The schema for events is still in flux, so be careful implementing automated systems which consume events. This will remain true until we are more confident that all relevant audit lock events are being collected. At that point we will standardize and stabilize the interface.</p> <p>As of v0.7, each event log entry has a type. The currently implemented types are:</p> <ul> <li>audit: audit log entries such as object creation or deletion, and authentication.</li> <li>mutate: object modifications which are not an audit log entry, such as minor updates.</li> <li>status: status messages useful to a user, such as progress of fetching an image.</li> <li>usage: billing information.</li> <li>resources: cluster resource usage information of interest to an operator.</li> <li>prune: messages relating to pruning of other message types.</li> <li>historic: events from before the type system was introduced.</li> </ul> <p>For each of these types, an operator can configure a retention period. The default periods are:</p> <ul> <li>audit (MAX_AUDIT_EVENT_AGE): 90 days.</li> <li>mutate (MAX_MUTATE_EVENT_AGE): 90 days.</li> <li>status (MAX_STATUS_EVENT_AGE): 7 days.</li> <li>usage (MAX_USAGE_EVENT_AGE): 30 days.</li> <li>resources (MAX_RESOURCES_EVENT_AGE): 7 days.</li> <li>prune (MAX_PRUNE_EVENT_AGE): 30 days.</li> <li>historic (MAX_HISTORIC_EVENT_AGE): 90 days.</li> </ul> <p>To permanently retain a type of event log entry, set the corresponding configuration value to -1.</p>"},{"location":"user_guide/metadata/","title":"Object metadata","text":"<p>All objects in Shaken Fist support a simple metadata system. This system is presented as a series of key, value pairs which are stored against the relevant object. A worked example can be seen in the description of instance affinity which requires specific keys and formats for their values, but you're not limited to that -- other keys can have data of any format that you can express in an API call.</p> Note <p>It is not intended that you store large amounts of data in a metadata key. If you want to store more than a couple of kilobytes in a value, then instead store a reference to an external system or a blob which contains the data.</p> <p>You can set a metadata key's value on the command line like this:</p> <p><code>sf-client instance set-metadata ...uuid... key-name key-value</code></p> <p>Metadata values are show in the <code>show</code> output for the various object types, and there is no separate command to look them up. You can also delete a metadata key like this:</p> <p><code>sf-client instance delete-metadata ...uuid... key-name</code></p>"},{"location":"user_guide/objects/","title":"Objects","text":"<p>Everything that you interact with in Shaken Fist is an object. Objects are almost always referred to by a UUID (specifically a version 4 UUID) as a string. The exceptions are: <code>node</code>s; <code>namespace</code>s; and <code>key</code>s within a namespace.</p> <p>In general an object is referred to in the API or on the command line \"by reference\", which means you can either pass the object's name or its UUID to the command. So for example if we had an instance with the UUID 0a38d51e-2f72-4848-80fb-03031978633b named \"mikal\", then we could run either of the commands below to the same effect:</p> <pre><code>sf-client instance show 0a38d51e-2f72-4848-80fb-03031978633b\nsf-client instance show mikal\n</code></pre> <p>In the case where you refer to an object by name, a lookup occurs of all objects visible to you (those in your namespace, and namespaces that trust your namespace). Additionally, shared artifacts are included if you're using an artifact command.</p> <p>It is possible that the name you're using isn't unique. For example there might be two instances named \"mikal\" with different UUIDs. In that case, you will get an error indicating that there was more than one object which matched, and you'll need to use a UUID to refer to the object.</p>"},{"location":"user_guide/usage/","title":"Usage","text":"<p>This page attempts to provide a summary of the minimum amount of information you need to get started as a Shaken Fist user. The other pages in this section of the documentation provide deeper information about specific sub areas.</p>"},{"location":"user_guide/usage/#clients","title":"Clients","text":"<p>The primary Shaken Fist client is packaged and released in the <code>shakenfist-client</code> package from pypi. This client is released at the same time as any major release of Shaken Fist, but there is no guarantee that minor releases are done in sync. However, the Shaken Fist client knows how to probe the server for capabilities, so it is recommended that you keep the client as up to date as possible.</p> <p>The client is installed on the primary node as part of the operation of the Ansible based installer. Authentication details are also provided on the primary node. That means that you can just get started on the primary node without any further configuration.</p> <p>The <code>shakenfist-client</code> package contains two clients at the time of writing: a REST API client that can be imported at <code>shakenfist_client.apiclient</code>; and a command line client implemented with this REST API client. The command line client is exposed as <code>sf-client</code> once the python package is installed.</p> <p>The command line client can produce output in three formats: the standard \"pretty\" format, a mostly-csv format called \"simple\" (which is aimed at being easy to parse in shell scripts), and JSON. You select the output format with a flag like this:</p> <pre><code>sf-client --simple instance list\n</code></pre> <p>The default formatter is the \"pretty\" formatter, so you never need to specify that on the command line.</p> Command line client output options <ul> <li><code>--pretty</code> (also the default): ASCII art tables where appropriate human   readable output.</li> <li><code>--simple</code>: mostly comma delimited output intended to be easier to parse   in a shell script.</li> <li><code>--json</code>: JSON format output intended to be parsed by other programs. In   general this output is also exactly what the REST API returns, which can   be handy when developing with that API.</li> </ul> <p>You can explore what the command line client is capable of by asking it for help:</p> <pre><code>$ sf-client --help\nUsage: sf-client [OPTIONS] COMMAND [ARGS]...\n\nOptions:\n  --pretty\n  --simple\n  --json\n  --verbose / --no-verbose\n  --namespace TEXT\n  --key TEXT\n  --apiurl TEXT\n  --async-strategy, --async [continue|pause|block]\n  --help                          Show this message and exit.\n\nCommands:\n  admin      Admin commands\n  ansible    Ansible commands, intended to be used as modules\n  artifact   Artifact commands\n  backup     Backup commands\n  blob       Blob commands\n  instance   Instance commands\n  interface  Interface commands\n  k3s        k3s orchestration commands\n  label      Label commands\n  namespace  Namespace commands\n  network    Network commands\n  node       Node commands\n  version    Output the version of the client\n</code></pre> <p>This help is present at several levels, such as:</p> <pre><code>$ sf-client instance --help\nUsage: sf-client instance [OPTIONS] COMMAND [ARGS]...\n\n  Instance commands\n\nOptions:\n  --help  Show this message and exit.\n\nCommands:\n  add-interface    Add a network interface to an instance\n  await            Await an agent ready from the specified\n                   instance\n  consoledata      Get console data for an instance\n  consoledelete    Clear the console log for this instance\n  create           Create an instance.\n  delete           Delete an instance\n  delete-all       Delete ALL instances\n  delete-metadata  Delete a metadata item\n  download         Download a file from an instance\n  events           Display events for an instance\n  execute          Execute a command on an instance\n  list             List instances\n  pause            Pause an instance\n  poweroff         Power off an instance\n  poweron          Power on an instance\n  reboot           Reboot instance\n  screenshot       Download a screenshot of the console of\n                   an instance\n  set-metadata     Set a metadata item\n  show             Show an instance\n  snapshot         Snapshot instance\n  unpause          Unpause an instance\n  upload           Upload a file to an instance\n  vdiconsole       Launch a VDI console for the instance\n  vdiconsolefile   Download a .vv file for the VDI console\n</code></pre>"},{"location":"user_guide/usage/#networking-fundamentals","title":"Networking fundamentals","text":"<p>Virtual networks / micro segmentation is provided by VXLAN meshes between the instances. Hypervisors are joined to a given mesh when they start their first instance on that network. DHCP services are optionally offered from a \"network services\" node, which is just a hypervisor node with some extra dnsmasq process. NAT is also optionally available from the network services node. If your network provides NAT, it consumes an IP address from the floating IP pool to do so, and performs NAT in a network namespace on the network node.</p> <p>You create a network on the command line like this:</p> <pre><code>sf-client network create mynet 192.168.1.0/24\n</code></pre> <p>Where \"192.168.1.0/24\" is the CIDR network address range to use, and \"mynet\" is the name of the network. You'll get back output describing the network, including the UUID of the network, which is used in later calls.</p>"},{"location":"user_guide/usage/#instances","title":"Instances","text":""},{"location":"user_guide/usage/#config-drive","title":"Config drive","text":"<p>By default every instance gets a config drive, this config drive is always presented as a ISO9660 filesystem on a virtual hard drive. You can however disable the config drive if you want.</p> Supported config drive types <ul> <li><code>openstack</code> (also the default): an OpenStack style configuration drive.</li> <li><code>none</code>: no config drive at all.</li> </ul> <p>If a config drive is configured, it is always the second virtual disk attached to the VM (vdb on Linux if you're using virtio disks). There is no metadata server.</p>"},{"location":"user_guide/usage/#image-service-instance-flavors-or-types","title":"Image service, instance flavors or types","text":"<p>Additionally, there is no image service -- you specify the image to use by providing a URL. That URL is cached, but can be to any HTTP server anywhere. Even better, there are no flavors. You specify what resources your instance should have at boot time and that's what you get. No more being forced into a t-shirt sized description of your needs.</p>"},{"location":"user_guide/usage/#instance-reliability-features","title":"Instance reliability features","text":"<p>Instances are always cattle. Any feature that made instances feel like pets has not been implemented. That said, you can snapshot an instance. Snapshots aren't reliable backups, just like they're not really reliable backups on OpenStack. There is a small but real chance that a snapshot will contain an inconsistent state if you're snapshotting a busy database or something like that. One minor difference from OpenStack is that when you snapshot your instance you can snapshot all of the virtual disks (except the config drive) if you want to. Snapshots are delivered as artifacts much like other objects, and can be downloaded via the REST API and command line client.</p>"},{"location":"user_guide/usage/#starting-your-first-instance","title":"Starting your first instance","text":"<p>You start an instance like this:</p> <pre><code>sf-client instance create myinstance 1 2048 -d 8@cirros \\\n-n netuuid\n</code></pre> <p>Where myinstance is the name of the instance, in this example it has 1 vCPU, 2048MB of RAM, a single 8gb disk (more on this soon) and a single network interface on the network with the UUID \"netuuid\".</p>"},{"location":"user_guide/usage/#disk-specifications","title":"Disk specifications","text":"<p>\"8@cirros\" is a \"short disk specification\". These are in the form <code>size@image</code>, where the <code>@image</code> is optional. You can specify more than one disk, so this is valid:</p> <pre><code>sf-client instance create myinstance 1 2048 -d 8@cirros \\\n-d 8 -d 8 -n netuuid\n</code></pre> <p>In this case we have three disks, all of 8gb. The boot disk is imaged with cirros. The \"cirros\" here is shorthand. By default, you specify a URL for the image you want, so to boot a cirros instance you might use http://download.cirros-cloud.net/0.5.1/cirros-0.5.1-x86_64-disk.img -- that gets old though, so for common cloud images there is a shorthand format, where Shaken Fist knows how to generate the download URL from a short description. In this case \"cirros\" means \"the latest release of cirros\". You can also specify a version like this:</p> <pre><code>sf-client instance create myinstance 1 2048 -d 8@cirros:0.5.1 \\\n-d 8 -d 8 -n netuuid\n</code></pre> <p>While Cirros is special cased, there are a variety of other images you can use this shorthand format with. The list changes as different OSes are added, and now unsupported options are removed. The current list is those listed at https://images.shakenfist.com, which is where the images are fetched from. These images (apart from Cirros) also include the Shaken Fist in-guest agent pre-installed for your convenience.</p> <p>You can also use a \"detailed disk specification\", which is what fancy people use. Its syntax is similar:</p> <pre><code>sf-client instance create myinstance 1 2048 \\\n-D size=8,base=cirros,bus=ide,type=cdrom -d 8 -d 8 \\\n-n netuuid\n</code></pre> <p>The specification is composed of a series of key-value pairs. Valid keys are: size; base; bus; and type. If you don't specify a key, you'll get a reasonable default. Here's how the keys work:</p> <ul> <li>size as per the shorthand notation.</li> <li>base as per the shorthand notation, including version specification.</li> <li>bus is any valid disk bus for libvirt, which is virtio, ide, scsi, usb. Use   virtio unless you have a really good reason otherwise -- the performance of the   others are terrible. An example of a good reason is to install virtio drivers   into legacy operating systems that lack them natively.</li> <li>type can be one of disk or cdrom. Note that cdroms are excluded from snapshots.</li> </ul>"},{"location":"user_guide/usage/#network-specifications","title":"Network specifications","text":"<p>Similarly, networks have a \"short network specification\", where you can specify the UUID or name of a network, but also optionally the IP address to use for the interface. You can also have more than one network interface, so this is valid:</p> <pre><code>sf-client instance create myinstance 1 2048 -d 8@cirros \\\n-n netuuid1 -n netuuid2@10.0.0.4\n</code></pre> <p>Where netuuid1 and netuuid2 are both UUIDs of networks. You can also use the name of a network, so long as that name is unique in the namespace you are operating in. So for example, this is valid too:</p> <pre><code>sf-client network create testnet 10.0.0.0/24\nsf-client instance create testinstance 2 2048 -d 20@debian:12 \\\n-n testnet\n</code></pre> <p>Again, you can still assign a network address while using the network name, such as <code>testnet@10.0.0.42</code>.</p> <p>There is also a shorthand \"short network specification\" which implies immediately floating the interface. A \"floating\" interface is a routable IP address which is packet mangled to arrive at your virtual network address, much like in OpenStack. The details are the same as <code>-n</code>, except the flag is <code>-f</code>:</p> <pre><code>sf-client instance create myinstance 1 2048 -d 8@cirros \\\n-f netuuid1\n</code></pre> <p>There is a \"detailed network specification\" as well at <code>-N</code>, which is composed of the following keys:</p> <ul> <li>network_uuid is the UUID of the network to use.</li> <li>address is the IPv4 network address to use, if free. If its not free the   instance will fail to start. If you don't want an address on this interface,   use \"none\" as the value for address. If you do not specify any value for   address, an address on the network will be assigned to you.</li> <li>macaddress the mac address to use for the interface.</li> <li>model is the model of the network device, with options being ne2k_isa,   i82551, i82557b, i82559er, ne2k_pci, pcnet, rtl8139, e1000, and virtio. The   default model is virtio.</li> <li>float if true indicates to immediately float the interface once the instance   is created.</li> </ul> <p>So for example, this is valid:</p> <pre><code>sf-client instance create testinstance 2 2048 -d 20@debian:12 \\\n-N network_uuid=testnet,address=10.0.0.99,float=true\n</code></pre>"},{"location":"user_guide/usage/#missing-documentation","title":"Missing documentation","text":"<p>I really should document these as well:</p> <ul> <li>nodes</li> <li>networks: delete, list</li> <li>instance: show, delete, list, ssh keys, user data, reboots (hard and soft), poweroff, poweron, pause, unpause, snapshot</li> <li>images: pre-caching</li> <li>metadata</li> <li>authentication</li> </ul> <p>Maybe one day I will.</p>"}]}